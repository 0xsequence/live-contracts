import { ContractFactory, type ethers } from 'ethers'
import type { VerificationRequest } from 'scripts/types'

// https://github.com/0xsequence/wallet-contracts/blob/cb4e5aef9b22cb278b8da39e5419eed2b6d6714b/contracts/modules/MainModuleWebAuthnOnly.sol

const abi = [
  {
    inputs: [
      {
        internalType: 'address',
        name: '_factory',
        type: 'address'
      }
    ],
    stateMutability: 'nonpayable',
    type: 'constructor'
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: '_space',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '_provided',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '_current',
        type: 'uint256'
      }
    ],
    name: 'BadNonce',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'bytes',
        name: '_code',
        type: 'bytes'
      }
    ],
    name: 'CreateFailed',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'bytes4',
        name: '_signature',
        type: 'bytes4'
      }
    ],
    name: 'HookAlreadyExists',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'bytes4',
        name: '_signature',
        type: 'bytes4'
      }
    ],
    name: 'HookDoesNotExist',
    type: 'error'
  },
  {
    inputs: [],
    name: 'ImageHashIsZero',
    type: 'error'
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: 'bytes',
            name: 'authenticatorData',
            type: 'bytes'
          },
          {
            internalType: 'string',
            name: 'clientDataJSON',
            type: 'string'
          },
          {
            internalType: 'uint256',
            name: 'r',
            type: 'uint256'
          },
          {
            internalType: 'uint256',
            name: 's',
            type: 'uint256'
          },
          {
            internalType: 'uint256',
            name: 'x',
            type: 'uint256'
          },
          {
            internalType: 'uint256',
            name: 'y',
            type: 'uint256'
          },
          {
            internalType: 'bool',
            name: 'requireUserValidation',
            type: 'bool'
          },
          {
            internalType: 'bool',
            name: 'requireBackupSanityCheck',
            type: 'bool'
          },
          {
            internalType: 'uint256',
            name: 'challengeLocation',
            type: 'uint256'
          },
          {
            internalType: 'uint256',
            name: 'responseTypeLocation',
            type: 'uint256'
          },
          {
            internalType: 'bool',
            name: 'noChainId',
            type: 'bool'
          }
        ],
        internalType: 'struct ModuleWebAuthnOnly.DecodedSignature',
        name: 'decoded',
        type: 'tuple'
      }
    ],
    name: 'InvalidP256Signature',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'bytes32',
        name: '_hash',
        type: 'bytes32'
      },
      {
        internalType: 'bytes',
        name: '_signature',
        type: 'bytes'
      }
    ],
    name: 'InvalidSignature',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'bytes1',
        name: '_type',
        type: 'bytes1'
      }
    ],
    name: 'InvalidSignatureType',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'bytes',
        name: '_signature',
        type: 'bytes'
      },
      {
        internalType: 'uint256',
        name: 'threshold',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '_weight',
        type: 'uint256'
      }
    ],
    name: 'LowWeightChainedSignature',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: '_index',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '_requested',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '_available',
        type: 'uint256'
      }
    ],
    name: 'NotEnoughGas',
    type: 'error'
  },
  {
    inputs: [],
    name: 'OnlyDelegatecall',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '_sender',
        type: 'address'
      },
      {
        internalType: 'address',
        name: '_self',
        type: 'address'
      }
    ],
    name: 'OnlySelfAuth',
    type: 'error'
  },
  {
    inputs: [],
    name: 'UpdateUnsupported',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: '_current',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '_prev',
        type: 'uint256'
      }
    ],
    name: 'WrongChainedCheckpointOrder',
    type: 'error'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: 'address',
        name: '_contract',
        type: 'address'
      }
    ],
    name: 'CreatedContract',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: 'bytes4',
        name: '_signature',
        type: 'bytes4'
      },
      {
        indexed: false,
        internalType: 'address',
        name: '_implementation',
        type: 'address'
      }
    ],
    name: 'DefinedHook',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: 'bytes32',
        name: 'newImageHash',
        type: 'bytes32'
      }
    ],
    name: 'ImageHashUpdated',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: 'uint256',
        name: '_space',
        type: 'uint256'
      },
      {
        indexed: false,
        internalType: 'uint256',
        name: '_newNonce',
        type: 'uint256'
      }
    ],
    name: 'NonceChange',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'bytes32',
        name: '_tx',
        type: 'bytes32'
      },
      {
        indexed: false,
        internalType: 'uint256',
        name: '_index',
        type: 'uint256'
      }
    ],
    name: 'TxExecuted',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'bytes32',
        name: '_tx',
        type: 'bytes32'
      },
      {
        indexed: false,
        internalType: 'uint256',
        name: '_index',
        type: 'uint256'
      },
      {
        indexed: false,
        internalType: 'bytes',
        name: '_reason',
        type: 'bytes'
      }
    ],
    name: 'TxFailed',
    type: 'event'
  },
  {
    stateMutability: 'payable',
    type: 'fallback'
  },
  {
    inputs: [],
    name: 'FACTORY',
    outputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'INIT_CODE_HASH',
    outputs: [
      {
        internalType: 'bytes32',
        name: '',
        type: 'bytes32'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'SET_IMAGE_HASH_TYPE_HASH',
    outputs: [
      {
        internalType: 'bytes32',
        name: '',
        type: 'bytes32'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'WEB_AUTHN_IMAGEHASH',
    outputs: [
      {
        internalType: 'bytes32',
        name: '',
        type: 'bytes32'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes4',
        name: '_signature',
        type: 'bytes4'
      },
      {
        internalType: 'address',
        name: '_implementation',
        type: 'address'
      }
    ],
    name: 'addHook',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes',
        name: '_code',
        type: 'bytes'
      }
    ],
    name: 'createContract',
    outputs: [
      {
        internalType: 'address',
        name: 'addr',
        type: 'address'
      }
    ],
    stateMutability: 'payable',
    type: 'function'
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: 'bool',
            name: 'delegateCall',
            type: 'bool'
          },
          {
            internalType: 'bool',
            name: 'revertOnError',
            type: 'bool'
          },
          {
            internalType: 'uint256',
            name: 'gasLimit',
            type: 'uint256'
          },
          {
            internalType: 'address',
            name: 'target',
            type: 'address'
          },
          {
            internalType: 'uint256',
            name: 'value',
            type: 'uint256'
          },
          {
            internalType: 'bytes',
            name: 'data',
            type: 'bytes'
          }
        ],
        internalType: 'struct IModuleCalls.Transaction[]',
        name: '_txs',
        type: 'tuple[]'
      },
      {
        internalType: 'uint256',
        name: '_nonce',
        type: 'uint256'
      },
      {
        internalType: 'bytes',
        name: '_signature',
        type: 'bytes'
      }
    ],
    name: 'execute',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes32',
        name: '_hash',
        type: 'bytes32'
      },
      {
        internalType: 'bytes',
        name: '_signatures',
        type: 'bytes'
      }
    ],
    name: 'isValidSignature',
    outputs: [
      {
        internalType: 'bytes4',
        name: '',
        type: 'bytes4'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes',
        name: '_data',
        type: 'bytes'
      },
      {
        internalType: 'bytes',
        name: '_signatures',
        type: 'bytes'
      }
    ],
    name: 'isValidSignature',
    outputs: [
      {
        internalType: 'bytes4',
        name: '',
        type: 'bytes4'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'nonce',
    outputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      },
      {
        internalType: 'address',
        name: '',
        type: 'address'
      },
      {
        internalType: 'uint256[]',
        name: '',
        type: 'uint256[]'
      },
      {
        internalType: 'uint256[]',
        name: '',
        type: 'uint256[]'
      },
      {
        internalType: 'bytes',
        name: '',
        type: 'bytes'
      }
    ],
    name: 'onERC1155BatchReceived',
    outputs: [
      {
        internalType: 'bytes4',
        name: '',
        type: 'bytes4'
      }
    ],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      },
      {
        internalType: 'address',
        name: '',
        type: 'address'
      },
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256'
      },
      {
        internalType: 'bytes',
        name: '',
        type: 'bytes'
      }
    ],
    name: 'onERC1155Received',
    outputs: [
      {
        internalType: 'bytes4',
        name: '',
        type: 'bytes4'
      }
    ],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      },
      {
        internalType: 'address',
        name: '',
        type: 'address'
      },
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256'
      },
      {
        internalType: 'bytes',
        name: '',
        type: 'bytes'
      }
    ],
    name: 'onERC721Received',
    outputs: [
      {
        internalType: 'bytes4',
        name: '',
        type: 'bytes4'
      }
    ],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes4',
        name: '_signature',
        type: 'bytes4'
      }
    ],
    name: 'readHook',
    outputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: '_space',
        type: 'uint256'
      }
    ],
    name: 'readNonce',
    outputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes4',
        name: '_signature',
        type: 'bytes4'
      }
    ],
    name: 'removeHook',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: 'bool',
            name: 'delegateCall',
            type: 'bool'
          },
          {
            internalType: 'bool',
            name: 'revertOnError',
            type: 'bool'
          },
          {
            internalType: 'uint256',
            name: 'gasLimit',
            type: 'uint256'
          },
          {
            internalType: 'address',
            name: 'target',
            type: 'address'
          },
          {
            internalType: 'uint256',
            name: 'value',
            type: 'uint256'
          },
          {
            internalType: 'bytes',
            name: 'data',
            type: 'bytes'
          }
        ],
        internalType: 'struct IModuleCalls.Transaction[]',
        name: '_txs',
        type: 'tuple[]'
      }
    ],
    name: 'selfExecute',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes32',
        name: '_digest',
        type: 'bytes32'
      },
      {
        internalType: 'bytes',
        name: '_signature',
        type: 'bytes'
      }
    ],
    name: 'signatureRecovery',
    outputs: [
      {
        internalType: 'uint256',
        name: 'threshold',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: 'weight',
        type: 'uint256'
      },
      {
        internalType: 'bytes32',
        name: 'imageHash',
        type: 'bytes32'
      },
      {
        internalType: 'bytes32',
        name: 'subdigest',
        type: 'bytes32'
      },
      {
        internalType: 'uint256',
        name: 'checkpoint',
        type: 'uint256'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes4',
        name: '_interfaceID',
        type: 'bytes4'
      }
    ],
    name: 'supportsInterface',
    outputs: [
      {
        internalType: 'bool',
        name: '',
        type: 'bool'
      }
    ],
    stateMutability: 'pure',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes32',
        name: '_imageHash',
        type: 'bytes32'
      }
    ],
    name: 'updateImageHash',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    stateMutability: 'payable',
    type: 'receive'
  }
]

export class MainModuleWebAuthnOnly extends ContractFactory {
  constructor(signer: ethers.Signer) {
    super(
      abi,
      '0x60e06040523480156200001157600080fd5b5060405162002c7f38038062002c7f833981016040819052620000349162000089565b3060808190526c5af43d3d93803e602a57fd5bf3602190815260149190915273602c3d8160093d39f33d3d3d3d363d3d37363d7360009081526035600c20915260a0526001600160a01b031660c052620000bb565b6000602082840312156200009c57600080fd5b81516001600160a01b0381168114620000b457600080fd5b9392505050565b60805160a05160c051612b86620000f9600039600081816103ec0152611a2e01526000818161038a0152611a0c015260006108e70152612b866000f3fe6080604052600436106101635760003560e01c806361c2926c116100c0578063affed0e011610074578063bc197c8111610059578063bc197c8114610552578063eb51d25a1461059a578063f23a6e61146105ce5761016a565b8063affed0e01461051d578063b93ea7ad146105325761016a565b8063853c5068116100a5578063853c5068146104a25780638c3f5563146104ea57806390042baf1461050a5761016a565b806361c2926c146104625780637a9a1628146104825761016a565b8063257671f5116101175780632dd31000116100fc5780632dd31000146103da5780634fcf3eca1461040e57806357c56d6b1461042e5761016a565b8063257671f51461037857806329561426146103ba5761016a565b80631626ba7e116101485780631626ba7e146102f35780631a9b23371461031357806320c13b0b146103585761016a565b806301ffc9a714610248578063150b7a021461027d5761016a565b3661016a57005b600436106102465760006101a16000357fffffffff0000000000000000000000000000000000000000000000000000000016610614565b905073ffffffffffffffffffffffffffffffffffffffff811615610244576000808273ffffffffffffffffffffffffffffffffffffffff166000366040516101ea929190611e7c565b600060405180830381855af49150503d8060008114610225576040519150601f19603f3d011682016040523d82523d6000602084013e61022a565b606091505b50915091508161023c57805160208201fd5b805160208201f35b505b005b34801561025457600080fd5b50610268610263366004611ec1565b610668565b60405190151581526020015b60405180910390f35b34801561028957600080fd5b506102c2610298366004611f49565b7f150b7a020000000000000000000000000000000000000000000000000000000095945050505050565b6040517fffffffff000000000000000000000000000000000000000000000000000000009091168152602001610274565b3480156102ff57600080fd5b506102c261030e366004611fb8565b610673565b34801561031f57600080fd5b5061033361032e366004611ec1565b6106c0565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610274565b34801561036457600080fd5b506102c2610373366004612004565b6106cb565b34801561038457600080fd5b506103ac7f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610274565b3480156103c657600080fd5b506102466103d5366004612070565b610730565b3480156103e657600080fd5b506103337f000000000000000000000000000000000000000000000000000000000000000081565b34801561041a57600080fd5b50610246610429366004611ec1565b610782565b34801561043a57600080fd5b506103ac7f8713a7c4465f6fbee2b6e9d6646d1d9f83fec929edfc4baf661f3c865bdd04d181565b34801561046e57600080fd5b5061024661047d3660046120ce565b61084a565b34801561048e57600080fd5b5061024661049d366004612110565b6108d0565b3480156104ae57600080fd5b506104c26104bd366004611fb8565b6109d5565b604080519586526020860194909452928401919091526060830152608082015260a001610274565b3480156104f657600080fd5b506103ac610505366004612070565b6109fc565b610333610518366004612253565b610a28565b34801561052957600080fd5b506103ac610b12565b34801561053e57600080fd5b5061024661054d366004612288565b610b23565b34801561055e57600080fd5b506102c261056d3660046122bb565b7fbc197c810000000000000000000000000000000000000000000000000000000098975050505050505050565b3480156105a657600080fd5b506103ac7fb5746ef72e13a133ffeeec8be051251617d938d0e03c0e1408070d94aab89e6881565b3480156105da57600080fd5b506102c26105e9366004612376565b7ff23a6e61000000000000000000000000000000000000000000000000000000009695505050505050565b60006106627fbe27a319efc8734e89e26ba4bc95f5c788584163b959f03fa04e2d7ab4b9a1207fffffffff000000000000000000000000000000000000000000000000000000008416610bee565b92915050565b600061066282610c4c565b600080610681858585610ca8565b50905080156106b357507f1626ba7e0000000000000000000000000000000000000000000000000000000090506106b9565b50600090505b9392505050565b600061066282610614565b6000806106f086866040516106e1929190611e7c565b60405180910390208585610ca8565b509050801561072257507f20c13b0b000000000000000000000000000000000000000000000000000000009050610728565b50600090505b949350505050565b333014610776576040517fe12588940000000000000000000000000000000000000000000000000000000081523360048201523060248201526044015b60405180910390fd5b61077f81610ce6565b50565b3330146107c3576040517fe125889400000000000000000000000000000000000000000000000000000000815233600482015230602482015260440161076d565b60006107ce82610614565b73ffffffffffffffffffffffffffffffffffffffff160361083f576040517f1c3812cc0000000000000000000000000000000000000000000000000000000081527fffffffff000000000000000000000000000000000000000000000000000000008216600482015260240161076d565b61077f816000610d18565b33301461088b576040517fe125889400000000000000000000000000000000000000000000000000000000815233600482015230602482015260440161076d565b60006108be83836040516020016108a3929190612596565b60405160208183030381529060405280519060200120610dd8565b90506108cb818484610e5d565b505050565b73ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016300361093f576040517f0a57d61d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61094883610fe5565b600080610980858888604051602001610963939291906125de565b604051602081830303815290604052805190602001208585610ca8565b91509150816109c1578084846040517f8f4a234f00000000000000000000000000000000000000000000000000000000815260040161076d93929190612601565b6109cc818888610e5d565b50505050505050565b60008060008060006109e88888886110e2565b939c929b5090995097509095509350505050565b60006106627f8d0bf1fd623d628c741362c1289948e57b3e2905218c676d3e69abee36d6ae2e83610bee565b6000333014610a6b576040517fe125889400000000000000000000000000000000000000000000000000000000815233600482015230602482015260440161076d565b81516020830134f0905073ffffffffffffffffffffffffffffffffffffffff8116610ac457816040517f0d25719100000000000000000000000000000000000000000000000000000000815260040161076d9190612689565b60405173ffffffffffffffffffffffffffffffffffffffff821681527fa506ad4e7f05eceba62a023c3219e5bd98a615f4fa87e2afb08a2da5cf62bf0c9060200160405180910390a1919050565b6000610b1e60006109fc565b905090565b333014610b64576040517fe125889400000000000000000000000000000000000000000000000000000000815233600482015230602482015260440161076d565b6000610b6f83610614565b73ffffffffffffffffffffffffffffffffffffffff1614610be0576040517f5b4d6d6a0000000000000000000000000000000000000000000000000000000081527fffffffff000000000000000000000000000000000000000000000000000000008316600482015260240161076d565b610bea8282610d18565b5050565b6000808383604051602001610c0d929190918252602082015260400190565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0818403018152919052805160209091012054949350505050565b60007f6ffbd451000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831601610c9f57506001919050565b61066282611258565b6000806000806000610cbb8888886109d5565b50965091945092509050828210801590610cd95750610cd981611399565b9450505050935093915050565b6040517fc8683ec400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b604080517fbe27a319efc8734e89e26ba4bc95f5c788584163b959f03fa04e2d7ab4b9a1206020808301919091527fffffffff000000000000000000000000000000000000000000000000000000008516828401819052835180840385018152606084018086528151919093012073ffffffffffffffffffffffffffffffffffffffff8616908190559152608082015290517f0d7fc113eaf016db4681a1ba86d083ce3e0961f321062a75ac2b0aeb33deeed19181900360a00190a15050565b6040517f190100000000000000000000000000000000000000000000000000000000000060208201524660228201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000003060601b166042820152605681018290526000906076015b604051602081830303815290604052805190602001209050919050565b8060005b81811015610fde5736848483818110610e7c57610e7c61269c565b9050602002810190610e8e91906126cb565b90506040810135805a1015610ee35782815a6040517f2bb3e3ba00000000000000000000000000000000000000000000000000000000815260048101939093526024830191909152604482015260640161076d565b6000610ef26020840184612709565b15610f3157610f2a610f0a6080850160608601612724565b8315610f165783610f18565b5a5b610f2560a087018761273f565b6113a4565b9050610f6c565b610f69610f446080850160608601612724565b60808501358415610f555784610f57565b5a5b610f6460a088018861273f565b6113bf565b90505b8015610fb157877f5c4eeb02dabf8976016ab414d617f9a162936dcace3cdef8c69ef6e262ad5ae785604051610fa491815260200190565b60405180910390a2610fd3565b610fd3610fc46040850160208601612709565b8986610fce6113dc565b6113fb565b505050600101610e61565b5050505050565b606081901c6bffffffffffffffffffffffff82166000611004836109fc565b9050818114611050576040517f9b6514f400000000000000000000000000000000000000000000000000000000815260048101849052602481018390526044810182905260640161076d565b604080517f8d0bf1fd623d628c741362c1289948e57b3e2905218c676d3e69abee36d6ae2e60208083019190915281830186905282518083038401815260609092019092528051910120600183019081905560408051858152602081018390527f1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881910160405180910390a15050505050565b6000806000806000806110f58888611449565b9050806101400151156111125761110b8961173f565b925061111e565b61111b89610dd8565b92505b60008360405160200161113391815260200190565b60405160208183030381529060405290506111818183600001518460c001518560e00151866020015187610100015188610120015189604001518a606001518b608001518c60a001516117ac565b6111b957816040517f7ed694ef00000000000000000000000000000000000000000000000000000000815260040161076d91906127a4565b60019650600195506000925061124982608001518360a001518460c001518560e00151604080517fb5746ef72e13a133ffeeec8be051251617d938d0e03c0e1408070d94aab89e68602082015290810185905260608101849052821515608082015281151560a082015260009060c001604051602081830303815290604052805190602001209050949350505050565b94505050939792965093509350565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167fec6aba500000000000000000000000000000000000000000000000000000000014806112eb57507fffffffff0000000000000000000000000000000000000000000000000000000082167f4e2312e000000000000000000000000000000000000000000000000000000000145b8061133757507fffffffff0000000000000000000000000000000000000000000000000000000082167f150b7a0200000000000000000000000000000000000000000000000000000000145b8061138357507fffffffff0000000000000000000000000000000000000000000000000000000082167fc0ee0b8a00000000000000000000000000000000000000000000000000000000145b1561139057506001919050565b610662826119a8565b600061066282611a04565b60006040518284823760008084838989f49695505050505050565b6000604051828482376000808483898b8af1979650505050505050565b60603d604051915060208201818101604052818352816000823e505090565b831561140957805160208201fd5b827fab46c69f7f32e1bf09b0725853da82a211e5402a0600296ab499a2fb5ea3b419838360405161143b92919061287e565b60405180910390a250505050565b6114ac60405180610160016040528060608152602001606081526020016000815260200160008152602001600081526020016000815260200160001515815260200160001515815260200160008152602001600081526020016000151581525090565b828260008181106114bf576114bf61269c565b909101357f8000000000000000000000000000000000000000000000000000000000000000161590506115875760008060008060008060008060008060008d8d600190809261151093929190612897565b81019061151d91906128c1565b60408051610160810182529b8c5260208c019a909a52988a01979097526060890195909552608088019390935260a0870191909152151560c0860152151560e085015261010084015261012083015215156101408201529b506106629a5050505050505050505050565b60008383600081811061159c5761159c61269c565b7f4000000000000000000000000000000000000000000000000000000000000000920135918216151560c0850152507f2000000000000000000000000000000000000000000000000000000000000000811615156101408401527f10000000000000000000000000000000000000000000000000000000000000008116151560e08401527fff000000000000000000000000000000000000000000000000000000000000001690506003600185013560f01c61165c818301838789612897565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052509388525050508183018088013560f01c90600201935061ffff1690506116b683820184888a612897565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525050505060208601529190910194909401803560f090811c6101008501526002820135901c6101208401526004810135604084015260248101356060840152604481013560808401526064013560a08301525092915050565b6040517f190100000000000000000000000000000000000000000000000000000000000060208201526000602282018190527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000003060601b1660428301526056820183905290607601610e40565b600060258b5110806117ff57506117fd8b6020815181106117cf576117cf61269c565b01602001517fff00000000000000000000000000000000000000000000000000000000000000168b8b611a6f565b155b1561180c57506000611999565b60408051808201909152601581527f2274797065223a22776562617574686e2e676574220000000000000000000000602082015261184b898289611b68565b611859576000915050611999565b60006118648e611b91565b90506000816040516020016118799190612994565b60405160208183030381529060405290506118958b828c611b68565b6118a55760009350505050611999565b600060028f60028e6040516118ba9190612a00565b602060405180830381855afa1580156118d7573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906118fa9190612a12565b60405160200161190b929190612a2b565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905261194391612a00565b602060405180830381855afa158015611960573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906119839190612a12565b9050611992818a8a8a8a611cf1565b9450505050505b9b9a5050505050505050505050565b60007fe4a77bbc000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316016119fb57506001919050565b61066282611d65565b600030611a527f0000000000000000000000000000000000000000000000000000000000000000847f0000000000000000000000000000000000000000000000000000000000000000611d70565b73ffffffffffffffffffffffffffffffffffffffff161492915050565b60007f010000000000000000000000000000000000000000000000000000000000000084811614611aa2575060006106b9565b828015611ad157507f040000000000000000000000000000000000000000000000000000000000000084811614155b15611ade575060006106b9565b8115611b5e577f080000000000000000000000000000000000000000000000000000000000000084811614611b5e577ff0000000000000000000000000000000000000000000000000000000000000007f1000000000000000000000000000000000000000000000000000000000000000851601611b5e575060006106b9565b5060019392505050565b600083518210611b7a575060006106b9565b508151602092830181902093909101909101201490565b60608151600003611bb057505060408051602081019091526000815290565b6000604051806060016040528060408152602001612b116040913990506000600384516004611bdf9190612a7c565b611be99190612ac2565b9050600060038551611bfb9190612ad6565b1115611c3357600160038551611c119190612ad6565b611c1b9190612aea565b611c26906002612aea565b611c309082612afd565b90505b60008167ffffffffffffffff811115611c4e57611c4e612179565b6040519080825280601f01601f191660200182016040528015611c78576020820181803683370190505b509050600183016020820186875188015b80821015611ce4576003820191508151603f8160121c168501518453600184019350603f81600c1c168501518453600184019350603f8160061c168501518453600184019350603f8116850151845350600183019250611c89565b5092979650505050505050565b60006040518681528560208201528460408201528360608201528260808201526020600060a0836101005afa3d611d535760203d60a08473c2b78104907f722dabac4c69f826a522b2754de45afa90503d611d535763d0d5039b3d526004601cfd5b60005160011416979650505050505050565b600061066282611d92565b600060ff60005350603592835260601b60015260155260556000908120915290565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167fac6a444e000000000000000000000000000000000000000000000000000000001480611e2557507fffffffff0000000000000000000000000000000000000000000000000000000082167f36e7817500000000000000000000000000000000000000000000000000000000145b15611e3257506001919050565b7f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000831614610662565b8183823760009101908152919050565b80357fffffffff0000000000000000000000000000000000000000000000000000000081168114611ebc57600080fd5b919050565b600060208284031215611ed357600080fd5b6106b982611e8c565b803573ffffffffffffffffffffffffffffffffffffffff81168114611ebc57600080fd5b60008083601f840112611f1257600080fd5b50813567ffffffffffffffff811115611f2a57600080fd5b602083019150836020828501011115611f4257600080fd5b9250929050565b600080600080600060808688031215611f6157600080fd5b611f6a86611edc565b9450611f7860208701611edc565b935060408601359250606086013567ffffffffffffffff811115611f9b57600080fd5b611fa788828901611f00565b969995985093965092949392505050565b600080600060408486031215611fcd57600080fd5b83359250602084013567ffffffffffffffff811115611feb57600080fd5b611ff786828701611f00565b9497909650939450505050565b6000806000806040858703121561201a57600080fd5b843567ffffffffffffffff8082111561203257600080fd5b61203e88838901611f00565b9096509450602087013591508082111561205757600080fd5b5061206487828801611f00565b95989497509550505050565b60006020828403121561208257600080fd5b5035919050565b60008083601f84011261209b57600080fd5b50813567ffffffffffffffff8111156120b357600080fd5b6020830191508360208260051b8501011115611f4257600080fd5b600080602083850312156120e157600080fd5b823567ffffffffffffffff8111156120f857600080fd5b61210485828601612089565b90969095509350505050565b60008060008060006060868803121561212857600080fd5b853567ffffffffffffffff8082111561214057600080fd5b61214c89838a01612089565b909750955060208801359450604088013591508082111561216c57600080fd5b50611fa788828901611f00565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126121b957600080fd5b813567ffffffffffffffff808211156121d4576121d4612179565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561221a5761221a612179565b8160405283815286602085880101111561223357600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561226557600080fd5b813567ffffffffffffffff81111561227c57600080fd5b610728848285016121a8565b6000806040838503121561229b57600080fd5b6122a483611e8c565b91506122b260208401611edc565b90509250929050565b60008060008060008060008060a0898b0312156122d757600080fd5b6122e089611edc565b97506122ee60208a01611edc565b9650604089013567ffffffffffffffff8082111561230b57600080fd5b6123178c838d01612089565b909850965060608b013591508082111561233057600080fd5b61233c8c838d01612089565b909650945060808b013591508082111561235557600080fd5b506123628b828c01611f00565b999c989b5096995094979396929594505050565b60008060008060008060a0878903121561238f57600080fd5b61239887611edc565b95506123a660208801611edc565b94506040870135935060608701359250608087013567ffffffffffffffff8111156123d057600080fd5b6123dc89828a01611f00565b979a9699509497509295939492505050565b80358015158114611ebc57600080fd5b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b81835260006020808501808196508560051b810191508460005b8781101561258957828403895281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff418836030181126124a057600080fd5b870160c06124ad826123ee565b151586526124bc8783016123ee565b15158688015260408281013590870152606073ffffffffffffffffffffffffffffffffffffffff6124ee828501611edc565b16908701526080828101359087015260a080830135368490037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe101811261253457600080fd5b90920187810192903567ffffffffffffffff81111561255257600080fd5b80360384131561256157600080fd5b828289015261257383890182866123fe565b9c89019c97505050928601925050600101612461565b5091979650505050505050565b60408152600560408201527f73656c663a0000000000000000000000000000000000000000000000000000006060820152608060208201526000610728608083018486612447565b8381526040602082015260006125f8604083018486612447565b95945050505050565b8381526040602082015260006125f86040830184866123fe565b60005b8381101561263657818101518382015260200161261e565b50506000910152565b6000815180845261265781602086016020860161261b565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006106b9602083018461263f565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600082357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff418336030181126126ff57600080fd5b9190910192915050565b60006020828403121561271b57600080fd5b6106b9826123ee565b60006020828403121561273657600080fd5b6106b982611edc565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261277457600080fd5b83018035915067ffffffffffffffff82111561278f57600080fd5b602001915036819003821315611f4257600080fd5b60208152600082516101608060208501526127c361018085018361263f565b915060208501517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08584030160408601526127fe838261263f565b9250506040850151606085015260608501516080850152608085015160a085015260a085015160c085015260c085015161283c60e086018215159052565b5060e08501516101006128528187018315159052565b860151610120868101919091528601516101408087019190915290950151151593019290925250919050565b828152604060208201526000610728604083018461263f565b600080858511156128a757600080fd5b838611156128b457600080fd5b5050820193919092039150565b60008060008060008060008060008060006101608c8e0312156128e357600080fd5b67ffffffffffffffff808d3511156128fa57600080fd5b6129078e8e358f016121a8565b9b508060208e0135111561291a57600080fd5b5061292b8d60208e01358e016121a8565b995060408c0135985060608c0135975060808c0135965060a08c0135955061295560c08d016123ee565b945061296360e08d016123ee565b93506101008c013592506101208c013591506129826101408d016123ee565b90509295989b509295989b9093969950565b7f226368616c6c656e6765223a22000000000000000000000000000000000000008152600082516129cc81600d85016020870161261b565b7f2200000000000000000000000000000000000000000000000000000000000000600d939091019283015250600e01919050565b600082516126ff81846020870161261b565b600060208284031215612a2457600080fd5b5051919050565b60008351612a3d81846020880161261b565b9190910191825250602001919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b808202811582820484141761066257610662612a4d565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600082612ad157612ad1612a93565b500490565b600082612ae557612ae5612a93565b500690565b8181038181111561066257610662612a4d565b8082018082111561066257610662612a4d56fe4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392d5fa2646970667358221220c20b88f14e7dfe0e5241c65f6332e9ca844f384023d62a35f26f3a40263c95ef64736f6c63430008130033',
      signer
    )
  }
}

export const MAINMODULEWEBAUTHNONLY_VERIFICATION: Omit<VerificationRequest, 'waitForSuccess'> = {
  contractToVerify: 'contracts/modules/MainModuleWebAuthnOnly.sol:MainModuleWebAuthnOnly',
  version: 'v0.8.19+commit.7dd6d404',
  licenceType: 'Apache-2.0',
  compilerInput: {
    language: 'Solidity',
    sources: {
      'contracts/modules/MainModuleWebAuthnOnly.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./commons/ModuleWebAuthnOnly.sol";\nimport "./commons/ModuleHooks.sol";\nimport "./commons/ModuleCalls.sol";\nimport "./commons/ModuleCreator.sol";\n\n\n/**\n *  Implement a Sequence MainModule that uses WebAuthn for authentication\n *  it only allows a 1/1 WebAuthn signature, without the possibility of rotating the key\n */\ncontract MainModuleWebAuthnOnly is\n  ModuleWebAuthnOnly,\n  ModuleCalls,\n  ModuleHooks,\n  ModuleCreator\n{\n  constructor(\n    address _factory\n  ) ModuleWebAuthnOnly(\n    _factory\n  ) { }\n\n  function _isValidImage(\n    bytes32 _imageHash\n  ) internal override(\n    IModuleAuth,\n    ModuleWebAuthnOnly\n  ) view returns (bool) {\n    return super._isValidImage(_imageHash);\n  }\n\n  function signatureRecovery(\n    bytes32 _digest,\n    bytes calldata _signature\n  ) public override(\n    ModuleWebAuthnOnly,\n    IModuleAuth\n  ) virtual view returns (\n    uint256 threshold,\n    uint256 weight,\n    bytes32 imageHash,\n    bytes32 subdigest,\n    uint256 checkpoint\n  ) {\n    return super.signatureRecovery(_digest, _signature);\n  }\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(\n    bytes4 _interfaceID\n  ) public override(\n    ModuleWebAuthnOnly,\n    ModuleCalls,\n    ModuleHooks,\n    ModuleCreator\n  ) pure returns (bool) {\n    return super.supportsInterface(_interfaceID);\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleWebAuthnOnly.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./ModuleAuth.sol";\nimport "./ModuleUpdate.sol";\nimport "./ModuleSelfAuth.sol";\n\nimport "../../utils/LibClone.sol";\nimport "../../utils/LibBytesPointer.sol";\nimport "../../libs/p256-verifier/WebAuthn.sol";\nimport "../../Wallet.sol";\n\n/**\n *  Implements ModuleAuth by validating a 1/1 WebAuthn signature\n */\nabstract contract ModuleWebAuthnOnly is ModuleSelfAuth, ModuleAuth {\n  using LibBytesPointer for bytes;\n\n  bytes32 public immutable INIT_CODE_HASH;\n  address public immutable FACTORY;\n\n  bytes32 public constant WEB_AUTHN_IMAGEHASH = keccak256(\n    "WebAuthn(uint256 x, uint256 y, bool requireUserValidation, bool requireBackupSanityCheck)"\n  );\n\n  error InvalidP256Signature(DecodedSignature decoded);\n  error UpdateUnsupported();\n\n  constructor(address _factory) {\n    // Build init code hash of the deployed wallets using that module\n    bytes32 initCodeHash = LibClone.initCodeHash(address(this));\n\n    INIT_CODE_HASH = initCodeHash;\n    FACTORY = _factory;\n  }\n\n  function _updateImageHash(bytes32) internal override virtual {\n    revert UpdateUnsupported();\n  }\n\n  function _hashWebAuthnConfiguration(\n    uint256 _x,\n    uint256 _y,\n    bool _requireUserValidation,\n    bool _requireBackupSanityCheck\n  ) internal pure returns (bytes32) {\n    return keccak256(\n      abi.encode(\n        WEB_AUTHN_IMAGEHASH,\n        _x,\n        _y,\n        _requireUserValidation,\n        _requireBackupSanityCheck\n      )\n    );\n  }\n\n  struct DecodedSignature {\n    bytes authenticatorData;\n    string clientDataJSON;\n    uint256 r;\n    uint256 s;\n    uint256 x;\n    uint256 y;\n    bool requireUserValidation;\n    bool requireBackupSanityCheck;\n    uint256 challengeLocation;\n    uint256 responseTypeLocation;\n    bool noChainId;\n  }\n\n  function _decodeSignature(\n    bytes calldata _signature\n  ) internal pure returns (\n    DecodedSignature memory decoded\n  ) {\n    unchecked {\n      // Read first byte, it contains all booleans\n      // The first bit determines if this is a packet or unpacked signature\n      // unpacked signatures are less efficient, but it allows expressing a signature\n      // that may not fit under the packed format\n      if((_signature[0] & 0x80) != 0) {\n        // Unpacked signature\n        // just use the abi.decode\n        (\n          bytes memory authenticatorData,\n          string memory clientDataJSON,\n          uint256 r,\n          uint256 s,\n          uint256 x,\n          uint256 y,\n          bool requireUserValidation,\n          bool requireBackupSanityCheck,\n          uint256 challengeLocation,\n          uint256 responseTypeLocation,\n          bool noChainId\n        ) = abi.decode(_signature[1:], (\n          bytes,\n          string,\n          uint256,\n          uint256,\n          uint256,\n          uint256,\n          bool,\n          bool,\n          uint256,\n          uint256,\n          bool\n        ));\n\n        decoded = DecodedSignature({\n          authenticatorData: authenticatorData,\n          clientDataJSON: clientDataJSON,\n          r: r,\n          s: s,\n          x: x,\n          y: y,\n          requireUserValidation: requireUserValidation,\n          requireBackupSanityCheck: requireBackupSanityCheck,\n          challengeLocation: challengeLocation,\n          responseTypeLocation: responseTypeLocation,\n          noChainId: noChainId\n        });\n      } else {\n        bytes1 flags = _signature[0];\n\n        // Read the flags\n        // 0100 0000 - requireUserValidation\n        // 0010 0000 - noChainId\n        // 0001 0000 - requireBackupSanityCheck\n        decoded.requireUserValidation = (flags & 0x40) != 0;\n        decoded.noChainId = (flags & 0x20) != 0;\n        decoded.requireBackupSanityCheck = (flags & 0x10) != 0;\n\n        // Packed signature\n        uint256 index = 1;\n\n        // Read authenticatorData\n        uint256 sizeAuthData; (sizeAuthData, index) = _signature.readUint16(index);\n        decoded.authenticatorData = _signature[index:index + sizeAuthData];\n\n        // Read clientDataJSON\n        uint256 sizeClientData; (sizeClientData, index) = _signature.readUint16(index + sizeAuthData);\n        decoded.clientDataJSON = string(_signature[index:index + sizeClientData]);\n\n        // Read challengeLocation and responseTypeLocation\n        (decoded.challengeLocation, index) = _signature.readUint16(index + sizeClientData);\n        (decoded.responseTypeLocation, index) = _signature.readUint16(index);\n\n        // Read r, s, x, y\n        (decoded.r, index) = _signature.readUint256(index);\n        (decoded.s, index) = _signature.readUint256(index);\n        (decoded.x, index) = _signature.readUint256(index);\n        (decoded.y, index) = _signature.readUint256(index);\n      }\n    }\n  }\n\n  function signatureRecovery(\n    bytes32 _digest,\n    bytes calldata _signature\n  ) public override(ModuleAuth) virtual view returns (\n    uint256 threshold,\n    uint256 weight,\n    bytes32 imageHash,\n    bytes32 subdigest,\n    uint256 checkpoint\n  ) {\n    DecodedSignature memory decoded = _decodeSignature(_signature);\n\n    // The challenge is the subdigest\n    if (decoded.noChainId) {\n      subdigest = SequenceNoChainIdSig.subdigest(_digest);\n    } else {\n      subdigest = SequenceBaseSig.subdigest(_digest);\n    }\n\n    bytes memory challenge = abi.encodePacked(subdigest);\n\n    // Validate the signature\n    if (!WebAuthn.verifySignature(\n      challenge,\n      decoded.authenticatorData,\n      decoded.requireUserValidation,\n      decoded.requireBackupSanityCheck,\n      decoded.clientDataJSON,\n      decoded.challengeLocation,\n      decoded.responseTypeLocation,\n      decoded.r,\n      decoded.s,\n      decoded.x,\n      decoded.y\n    )) {\n      revert InvalidP256Signature(decoded);\n    }\n\n    // The threshold and weight are always 1 and 1\n    threshold = 1;\n    weight = 1;\n\n    // Checkpoint always zero\n    checkpoint = 0;\n\n    // The imageHash is a special case of hashing:\n    // - Magic constant\n    // - X and Y coordinates of the public key\n    // - Require user validation flag\n    // - Require backup sanity check flag\n    imageHash = _hashWebAuthnConfiguration(\n      decoded.x, decoded.y, decoded.requireUserValidation, decoded.requireBackupSanityCheck\n    );\n  }\n\n  /**\n   * @notice Validates the signature image with the salt used to deploy the contract\n   * @param _imageHash Hash image of signature\n   * @return true if the signature image is valid\n   */\n  function _isValidImage(bytes32 _imageHash) internal override virtual view returns (bool) {\n    return LibClone.predictDeterministicAddress(INIT_CODE_HASH, _imageHash, FACTORY) == address(this);\n  }\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(bytes4 _interfaceID) public override(ModuleAuth) virtual pure returns (bool) {\n    return super.supportsInterface(_interfaceID);\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleHooks.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./interfaces/IModuleHooks.sol";\n\nimport "./ModuleSelfAuth.sol";\nimport "./ModuleStorage.sol";\nimport "./ModuleERC165.sol";\n\nimport "../../interfaces/receivers/IERC1155Receiver.sol";\nimport "../../interfaces/receivers/IERC721Receiver.sol";\nimport "../../interfaces/receivers/IERC223Receiver.sol";\n\n\ncontract ModuleHooks is IERC1155Receiver, IERC721Receiver, IModuleHooks, ModuleERC165, ModuleSelfAuth {\n  //                       HOOKS_KEY = keccak256("org.arcadeum.module.hooks.hooks");\n  bytes32 private constant HOOKS_KEY = bytes32(0xbe27a319efc8734e89e26ba4bc95f5c788584163b959f03fa04e2d7ab4b9a120);\n\n  /**\n   * @notice Reads the implementation hook of a signature\n   * @param _signature Signature function\n   * @return The address of the implementation hook, address(0) if none\n  */\n  function readHook(bytes4 _signature) external override virtual view returns (address) {\n    return _readHook(_signature);\n  }\n\n  /**\n   * @notice Adds a new hook to handle a given function selector\n   * @param _signature Signature function linked to the hook\n   * @param _implementation Hook implementation contract\n   * @dev Can\'t overwrite hooks that are part of the main module (those defined below)\n   */\n  function addHook(bytes4 _signature, address _implementation) external override virtual onlySelf {\n    if (_readHook(_signature) != address(0)) revert HookAlreadyExists(_signature);\n    _writeHook(_signature, _implementation);\n  }\n\n  /**\n   * @notice Removes a registered hook\n   * @param _signature Signature function linked to the hook\n   * @dev Can\'t remove hooks that are part of the main module (those defined below)\n   *      without upgrading the wallet\n   */\n  function removeHook(bytes4 _signature) external override virtual onlySelf {\n    if (_readHook(_signature) == address(0)) revert HookDoesNotExist(_signature);\n    _writeHook(_signature, address(0));\n  }\n\n  /**\n   * @notice Reads the implementation hook of a signature\n   * @param _signature Signature function\n   * @return The address of the implementation hook, address(0) if none\n  */\n  function _readHook(bytes4 _signature) private view returns (address) {\n    return address(uint160(uint256(ModuleStorage.readBytes32Map(HOOKS_KEY, _signature))));\n  }\n\n  /**\n   * @notice Writes the implementation hook of a signature\n   * @param _signature Signature function\n   * @param _implementation Hook implementation contract\n  */\n  function _writeHook(bytes4 _signature, address _implementation) private {\n    ModuleStorage.writeBytes32Map(HOOKS_KEY, _signature, bytes32(uint256(uint160(_implementation))));\n    emit DefinedHook(_signature, _implementation);\n  }\n\n  /**\n   * @notice Handle the receipt of a single ERC1155 token type.\n   * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n   */\n  function onERC1155Received(\n    address,\n    address,\n    uint256,\n    uint256,\n    bytes calldata\n  ) external override virtual returns (bytes4) {\n    return ModuleHooks.onERC1155Received.selector;\n  }\n\n  /**\n   * @notice Handle the receipt of multiple ERC1155 token types.\n   * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n   */\n  function onERC1155BatchReceived(\n    address,\n    address,\n    uint256[] calldata,\n    uint256[] calldata,\n    bytes calldata\n  ) external override virtual returns (bytes4) {\n    return ModuleHooks.onERC1155BatchReceived.selector;\n  }\n\n  /**\n   * @notice Handle the receipt of a single ERC721 token.\n   * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n   */\n  function onERC721Received(address, address, uint256, bytes calldata) external override virtual returns (bytes4) {\n    return ModuleHooks.onERC721Received.selector;\n  }\n\n  /**\n   * @notice Routes fallback calls through hooks\n   */\n  fallback() external payable {\n    if (msg.data.length >= 4) {\n      address target = _readHook(msg.sig);\n      if (target != address(0)) {\n        (bool success, bytes memory result) = target.delegatecall(msg.data);\n        assembly {\n          if iszero(success)  {\n            revert(add(result, 0x20), mload(result))\n          }\n\n          return(add(result, 0x20), mload(result))\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Allows the wallet to receive ETH\n   */\n  receive() external payable { }\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\n    if (\n      _interfaceID == type(IModuleHooks).interfaceId ||\n      _interfaceID == type(IERC1155Receiver).interfaceId ||\n      _interfaceID == type(IERC721Receiver).interfaceId ||\n      _interfaceID == type(IERC223Receiver).interfaceId\n    ) {\n      return true;\n    }\n\n    return super.supportsInterface(_interfaceID);\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleCalls.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./ModuleSelfAuth.sol";\nimport "./ModuleStorage.sol";\nimport "./ModuleERC165.sol";\nimport "./ModuleNonce.sol";\nimport "./ModuleOnlyDelegatecall.sol";\n\nimport "./interfaces/IModuleCalls.sol";\nimport "./interfaces/IModuleAuth.sol";\n\nimport "./submodules/nonce/SubModuleNonce.sol";\nimport "./submodules/auth/SequenceBaseSig.sol";\n\nimport "../../utils/LibOptim.sol";\n\n\nabstract contract ModuleCalls is IModuleCalls, IModuleAuth, ModuleERC165, ModuleOnlyDelegatecall, ModuleSelfAuth, ModuleNonce {\n  /**\n   * @notice Allow wallet owner to execute an action\n   * @dev Relayers must ensure that the gasLimit specified for each transaction\n   *      is acceptable to them. A user could specify large enough that it could\n   *      consume all the gas available.\n   * @param _txs        Transactions to process\n   * @param _nonce      Signature nonce (may contain an encoded space)\n   * @param _signature  Encoded signature\n   */\n  function execute(\n    Transaction[] calldata _txs,\n    uint256 _nonce,\n    bytes calldata _signature\n  ) external override virtual onlyDelegatecall {\n    // Validate and update nonce\n    _validateNonce(_nonce);\n\n    // Hash and verify transaction bundle\n    (bool isValid, bytes32 txHash) = _signatureValidation(\n      keccak256(\n        abi.encode(\n          _nonce,\n          _txs\n        )\n      ),\n      _signature\n    );\n\n    if (!isValid) {\n      revert InvalidSignature(txHash, _signature);\n    }\n\n    // Execute the transactions\n    _execute(txHash, _txs);\n  }\n\n  /**\n   * @notice Allow wallet to execute an action\n   *   without signing the message\n   * @param _txs  Transactions to execute\n   */\n  function selfExecute(\n    Transaction[] calldata _txs\n  ) external override virtual onlySelf {\n    // Hash transaction bundle\n    bytes32 txHash = SequenceBaseSig.subdigest(\n      keccak256(\n        abi.encode(\'self:\', _txs)\n      )\n    );\n\n    // Execute the transactions\n    _execute(txHash, _txs);\n  }\n\n  /**\n   * @notice Executes a list of transactions\n   * @param _txHash  Hash of the batch of transactions\n   * @param _txs  Transactions to execute\n   */\n  function _execute(\n    bytes32 _txHash,\n    Transaction[] calldata _txs\n  ) private {\n    unchecked {\n      // Execute transaction\n      uint256 size = _txs.length;\n      for (uint256 i = 0; i < size; i++) {\n        Transaction calldata transaction = _txs[i];\n        uint256 gasLimit = transaction.gasLimit;\n\n        if (gasleft() < gasLimit) revert NotEnoughGas(i, gasLimit, gasleft());\n\n        bool success;\n        if (transaction.delegateCall) {\n          success = LibOptim.delegatecall(\n            transaction.target,\n            gasLimit == 0 ? gasleft() : gasLimit,\n            transaction.data\n          );\n        } else {\n          success = LibOptim.call(\n            transaction.target,\n            transaction.value,\n            gasLimit == 0 ? gasleft() : gasLimit,\n            transaction.data\n          );\n        }\n\n        if (success) {\n          emit TxExecuted(_txHash, i);\n        } else {\n          // Avoid copy of return data until neccesary\n          _revertBytes(\n            transaction.revertOnError,\n            _txHash,\n            i,\n            LibOptim.returnData()\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Logs a failed transaction, reverts if the transaction is not optional\n   * @param _revertOnError  Signals if it should revert or just log\n   * @param _txHash         Hash of the transaction\n   * @param _index          Index of the transaction in the batch\n   * @param _reason         Encoded revert message\n   */\n  function _revertBytes(\n    bool _revertOnError,\n    bytes32 _txHash,\n    uint256 _index,\n    bytes memory _reason\n  ) internal {\n    if (_revertOnError) {\n      assembly { revert(add(_reason, 0x20), mload(_reason)) }\n    } else {\n      emit TxFailed(_txHash, _index, _reason);\n    }\n  }\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\n    if (_interfaceID == type(IModuleCalls).interfaceId) {\n      return true;\n    }\n\n    return super.supportsInterface(_interfaceID);\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleCreator.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./interfaces/IModuleCreator.sol";\n\nimport "./ModuleSelfAuth.sol";\nimport "./ModuleERC165.sol";\n\n\ncontract ModuleCreator is IModuleCreator, ModuleERC165, ModuleSelfAuth {\n  event CreatedContract(address _contract);\n\n  /**\n   * @notice Creates a contract forwarding eth value\n   * @param _code Creation code of the contract\n   * @return addr The address of the created contract\n   */\n  function createContract(bytes memory _code) public override virtual payable onlySelf returns (address addr) {\n    assembly { addr := create(callvalue(), add(_code, 32), mload(_code)) }\n    if (addr == address(0)) revert CreateFailed(_code);\n    emit CreatedContract(addr);\n  }\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\n    if (_interfaceID == type(IModuleCreator).interfaceId) {\n      return true;\n    }\n\n    return super.supportsInterface(_interfaceID);\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleAuth.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "../../utils/LibBytes.sol";\nimport "../../interfaces/IERC1271Wallet.sol";\n\nimport "./interfaces/IModuleAuth.sol";\n\nimport "./ModuleERC165.sol";\n\nimport "./submodules/auth/SequenceBaseSig.sol";\nimport "./submodules/auth/SequenceDynamicSig.sol";\nimport "./submodules/auth/SequenceNoChainIdSig.sol";\nimport "./submodules/auth/SequenceChainedSig.sol";\n\n\nabstract contract ModuleAuth is\n  IModuleAuth,\n  ModuleERC165,\n  IERC1271Wallet,\n  SequenceChainedSig\n{\n  using LibBytes for bytes;\n\n  bytes1 internal constant LEGACY_TYPE = hex"00";\n  bytes1 internal constant DYNAMIC_TYPE = hex"01";\n  bytes1 internal constant NO_CHAIN_ID_TYPE = hex"02";\n  bytes1 internal constant CHAINED_TYPE = hex"03";\n\n  bytes4 internal constant SELECTOR_ERC1271_BYTES_BYTES = 0x20c13b0b;\n  bytes4 internal constant SELECTOR_ERC1271_BYTES32_BYTES = 0x1626ba7e;\n\n  /**\n   * @notice Recovers the threshold, weight, imageHash, subdigest, and checkpoint of a signature.\n   * @dev The signature must be prefixed with a type byte, which is used to determine the recovery method.\n   *\n   * @param _digest Digest of the signed data.\n   * @param _signature A Sequence signature.\n   *\n   * @return threshold The required number of signatures needed to consider the signature valid.\n   * @return weight The actual number of signatures collected in the signature.\n   * @return imageHash The imageHash of the configuration that signed the message.\n   * @return subdigest A modified version of the original digest, unique for each wallet/network.\n   * @return checkpoint A nonce that is incremented every time a new configuration is set.\n   */\n  function signatureRecovery(\n    bytes32 _digest,\n    bytes calldata _signature\n  ) public override virtual view returns (\n    uint256 threshold,\n    uint256 weight,\n    bytes32 imageHash,\n    bytes32 subdigest,\n    uint256 checkpoint\n  ) {\n    bytes1 signatureType = _signature[0];\n\n    if (signatureType == LEGACY_TYPE) {\n      // networkId digest + base recover\n      subdigest = SequenceBaseSig.subdigest(_digest);\n      (threshold, weight, imageHash, checkpoint) = SequenceBaseSig.recover(subdigest, _signature);\n      return (threshold, weight, imageHash, subdigest, checkpoint);\n    }\n\n    if (signatureType == DYNAMIC_TYPE) {\n      // networkId digest + dynamic recover\n      subdigest = SequenceBaseSig.subdigest(_digest);\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\n      return (threshold, weight, imageHash, subdigest, checkpoint);\n    }\n\n    if (signatureType == NO_CHAIN_ID_TYPE) {\n      // noChainId digest + dynamic recover\n      subdigest = SequenceNoChainIdSig.subdigest(_digest);\n      (threshold, weight, imageHash, checkpoint) = SequenceDynamicSig.recover(subdigest, _signature);\n      return (threshold, weight, imageHash, subdigest, checkpoint);\n    }\n\n    if (signatureType == CHAINED_TYPE) {\n      // original digest + chained recover\n      // (subdigest will be computed in the chained recover)\n      return chainedRecover(_digest, _signature);\n    }\n\n    revert InvalidSignatureType(signatureType);\n  }\n\n  /**\n   * @dev Validates a signature.\n   *\n   * @param _digest Digest of the signed data.\n   * @param _signature A Sequence signature.\n   *\n   * @return isValid Indicates whether the signature is valid or not.\n   * @return subdigest A modified version of the original digest, unique for each wallet/network.\n   */\n  function _signatureValidation(\n    bytes32 _digest,\n    bytes calldata _signature\n  ) internal override virtual view returns (\n    bool isValid,\n    bytes32 subdigest\n  ) {\n    uint256 threshold; uint256 weight; bytes32 imageHash;\n    (threshold, weight, imageHash, subdigest,) = signatureRecovery(_digest, _signature);\n    isValid = weight >= threshold && _isValidImage(imageHash);\n  }\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256("isValidSignature(bytes,bytes)"))\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\n   * @param _signatures Signature byte array associated with _data.\n   *                    Encoded as abi.encode(Signature[], Configs)\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes calldata _data,\n    bytes calldata _signatures\n  ) public override virtual view returns (bytes4) {\n    // Validate signatures\n    (bool isValid,) = _signatureValidation(keccak256(_data), _signatures);\n    if (isValid) {\n      return SELECTOR_ERC1271_BYTES_BYTES;\n    }\n\n    return bytes4(0);\n  }\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\n   *   > The bytes4 magic value to return when signature is valid is 0x1626ba7e : bytes4(keccak256("isValidSignature(bytes32,bytes)"))\n   * @param _hash       keccak256 hash that was signed\n   * @param _signatures Signature byte array associated with _data.\n   *                    Encoded as abi.encode(Signature[], Configs)\n   * @return magicValue Magic value 0x1626ba7e if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes calldata _signatures\n  ) public override virtual view returns (bytes4) {\n    // Validate signatures\n    (bool isValid,) = _signatureValidation(_hash, _signatures);\n    if (isValid) {\n      return SELECTOR_ERC1271_BYTES32_BYTES;\n    }\n\n    return bytes4(0);\n  }\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\n    if (\n      _interfaceID == type(IModuleAuth).interfaceId ||\n      _interfaceID == type(IERC1271Wallet).interfaceId\n    ) {\n      return true;\n    }\n\n    return super.supportsInterface(_interfaceID);\n  }\n\n  /**\n   * @notice Updates the signers configuration of the wallet\n   * @param _imageHash New required image hash of the signature\n   */\n  function updateImageHash(bytes32 _imageHash) external override virtual onlySelf {\n    _updateImageHash(_imageHash);\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleUpdate.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./interfaces/IModuleUpdate.sol";\n\nimport "./Implementation.sol";\nimport "./ModuleSelfAuth.sol";\nimport "./ModuleERC165.sol";\n\nimport "../../utils/LibAddress.sol";\n\n\ncontract ModuleUpdate is IModuleUpdate, ModuleERC165, ModuleSelfAuth, Implementation {\n  using LibAddress for address;\n\n  event ImplementationUpdated(address newImplementation);\n\n  /**\n   * @notice Updates the implementation of the base wallet\n   * @param _implementation New main module implementation\n   * @dev WARNING Updating the implementation can brick the wallet\n   */\n  function updateImplementation(address _implementation) external override virtual onlySelf {\n    _updateImplementation(_implementation);\n  }\n\n  /**\n   * @notice Updates the implementation of the base wallet, used internally.\n   * @param _implementation New main module implementation\n   * @dev WARNING Updating the implementation can brick the wallet\n   */\n  function _updateImplementation(address _implementation) internal override virtual {\n    if (!_implementation.isContract()) revert InvalidImplementation(_implementation);\n    _setImplementation(_implementation);\n    emit ImplementationUpdated(_implementation);\n  }\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\n    if (_interfaceID == type(IModuleUpdate).interfaceId) {\n      return true;\n    }\n\n    return super.supportsInterface(_interfaceID);\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleSelfAuth.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ncontract ModuleSelfAuth {\n  error OnlySelfAuth(address _sender, address _self);\n\n  modifier onlySelf() {\n    if (msg.sender != address(this)) {\n      revert OnlySelfAuth(msg.sender, address(this));\n    }\n    _;\n  }\n}\n'
      },
      'contracts/utils/LibClone.sol': {
        content:
          '// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\n//\nlibrary LibClone {\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*             CUSTOM ERRORS                                  */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Unable to deploy the clone.\n  error DeploymentFailed();\n\n  /// @dev The salt must start with either the zero address or `by`.\n  error SaltDoesNotStartWith();\n\n  /// @dev The ETH transfer has failed.\n  error ETHTransferFailed();\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*          MINIMAL PROXY OPERATIONS                          */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Deploys a clone of `implementation`.\n  function clone(address implementation) internal returns (address instance) {\n    instance = clone(0, implementation);\n  }\n\n  /// @dev Deploys a clone of `implementation`.\n  /// Deposits `value` ETH during deployment.\n  function clone(uint256 value, address implementation) internal returns (address instance) {\n    /// @solidity memory-safe-assembly\n    assembly {\n    /**\n      * --------------------------------------------------------------------------+\n      * CREATION (9 bytes)                                                        |\n      * --------------------------------------------------------------------------|\n      * Opcode     | Mnemonic          | Stack     | Memory                       |\n      * --------------------------------------------------------------------------|\n      * 60 runSize | PUSH1 runSize     | r         |                              |\n      * 3d         | RETURNDATASIZE    | 0 r       |                              |\n      * 81         | DUP2              | r 0 r     |                              |\n      * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n      * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n      * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n      * f3         | RETURN            |           | [0..runSize): runtime code   |\n      * --------------------------------------------------------------------------|\n      * RUNTIME (44 bytes)                                                        |\n      * --------------------------------------------------------------------------|\n      * Opcode  | Mnemonic       | Stack                  | Memory                |\n      * --------------------------------------------------------------------------|\n      *                                                                           |\n      * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n      * 3d      | RETURNDATASIZE | 0                      |                       |\n      * 3d      | RETURNDATASIZE | 0 0                    |                       |\n      * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n      * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n      *                                                                           |\n      * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n      * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n      * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n      * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n      * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n      *                                                                           |\n      * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n      * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n      * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n      * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n      * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n      * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n      *                                                                           |\n      * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n      * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n      * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n      * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n      * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n      * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n      *                                                                           |\n      * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n      * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n      *                                                                           |\n      * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n      * fd      | REVERT         |                        | [0..rds): returndata  |\n      *                                                                           |\n      * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n      * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n      * f3      | RETURN         |                        | [0..rds): returndata  |\n      * --------------------------------------------------------------------------+\n      */\n      mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n      mstore(0x14, implementation)\n      mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n      instance := create(value, 0x0c, 0x35)\n      if iszero(instance) {\n        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n    }\n  }\n\n  /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n  function cloneDeterministic(address implementation, bytes32 salt)\n    internal\n    returns (address instance)\n  {\n    instance = cloneDeterministic(0, implementation, salt);\n  }\n\n  /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n  /// Deposits `value` ETH during deployment.\n  function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n    internal\n    returns (address instance)\n  {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n      mstore(0x14, implementation)\n      mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n      instance := create2(value, 0x0c, 0x35, salt)\n      if iszero(instance) {\n        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n        revert(0x1c, 0x04)\n      }\n      mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n    }\n  }\n\n  /// @dev Returns the initialization code of the clone of `implementation`.\n  function initCode(address implementation) internal pure returns (bytes memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := mload(0x40)\n      mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n      mstore(add(result, 0x28), implementation)\n      mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n      mstore(result, 0x35) // Store the length.\n      mstore(0x40, add(result, 0x60)) // Allocate memory.\n    }\n  }\n\n  /// @dev Returns the initialization code hash of the clone of `implementation`.\n  /// Used for mining vanity addresses with create2crunch.\n  function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n      mstore(0x14, implementation)\n      mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n      hash := keccak256(0x0c, 0x35)\n      mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n    }\n  }\n\n  /// @dev Returns the address of the deterministic clone of `implementation`,\n  /// with `salt` by `deployer`.\n  /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n  function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n    internal\n    pure\n    returns (address predicted)\n  {\n    bytes32 hash = initCodeHash(implementation);\n    predicted = predictDeterministicAddress(hash, salt, deployer);\n  }\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*            OTHER OPERATIONS                                */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Returns the address when a contract with initialization code hash,\n  /// `hash`, is deployed with `salt`, by `deployer`.\n  /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n  function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n    internal\n    pure\n    returns (address predicted)\n  {\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Compute and store the bytecode hash.\n      mstore8(0x00, 0xff) // Write the prefix.\n      mstore(0x35, hash)\n      mstore(0x01, shl(96, deployer))\n      mstore(0x15, salt)\n      predicted := keccak256(0x00, 0x55)\n      mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n    }\n  }\n}\n'
      },
      'contracts/utils/LibBytesPointer.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\n/**\n * @title Library for reading data from bytes arrays with a pointer\n * @author Agustin Aguilar (aa@horizon.io)\n * @notice This library contains functions for reading data from bytes arrays with a pointer.\n *\n * @dev These functions do not check if the input index is within the bounds of the data array.\n *         Reading out of bounds may return dirty values.\n */\nlibrary LibBytesPointer {\n\n  /**\n   * @dev Returns the first uint16 value in the input data and updates the pointer.\n   * @param _data The input data.\n   * @return a The first uint16 value.\n   * @return newPointer The new pointer.\n   */\n  function readFirstUint16(\n    bytes calldata _data\n  ) internal pure returns (\n    uint16 a,\n    uint256 newPointer\n  ) {\n    assembly {\n      let word := calldataload(_data.offset)\n      a := shr(240, word)\n      newPointer := 2\n    }\n  }\n\n  /**\n   * @notice Returns the uint8 value at the given index in the input data and updates the pointer.\n   * @param _data The input data.\n   * @param _index The index of the value to retrieve.\n   * @return a The uint8 value at the given index.\n   * @return newPointer The new pointer.\n   */\n  function readUint8(\n    bytes calldata _data,\n    uint256 _index\n  ) internal pure returns (\n    uint8 a,\n    uint256 newPointer\n  ) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(248, word)\n      newPointer := add(_index, 1)\n    }\n  }\n\n  /**\n   * @notice Returns the uint8 value and the address at the given index in the input data and updates the pointer.\n   * @param _data The input data.\n   * @param _index The index of the value to retrieve.\n   * @return a The uint8 value at the given index.\n   * @return b The following address value.\n   * @return newPointer The new pointer.\n   */\n  function readUint8Address(\n    bytes calldata _data,\n    uint256 _index\n  ) internal pure returns (\n    uint8 a,\n    address b,\n    uint256 newPointer\n  ) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(248, word)\n      b := and(shr(88, word), 0xffffffffffffffffffffffffffffffffffffffff)\n      newPointer := add(_index, 21)\n    }\n  }\n\n  /**\n   * @notice Returns the uint16 value at the given index in the input data and updates the pointer.\n   * @param _data The input data.\n   * @param _index The index of the value to retrieve.\n   * @return a The uint16 value at the given index.\n   * @return newPointer The new pointer.\n   */\n  function readUint16(\n    bytes calldata _data,\n    uint256 _index\n  ) internal pure returns (\n    uint16 a,\n    uint256 newPointer\n  ) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := and(shr(240, word), 0xffff)\n      newPointer := add(_index, 2)\n    }\n  }\n\n  /**\n   * @notice Returns the uint24 value at the given index in the input data and updates the pointer.\n   * @param _data The input data.\n   * @param _index The index of the value to retrieve.\n   * @return a The uint24 value at the given index.\n   * @return newPointer The new pointer.\n   */\n  function readUint24(\n    bytes calldata _data,\n    uint256 _index\n  ) internal pure returns (\n    uint24 a,\n    uint256 newPointer\n  ) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := and(shr(232, word), 0xffffff)\n      newPointer := add(_index, 3)\n    }\n  }\n\n  /**\n   * @notice Returns the uint64 value at the given index in the input data and updates the pointer.\n   * @param _data The input data.\n   * @param _index The index of the value to retrieve.\n   * @return a The uint64 value at the given index.\n   * @return newPointer The new pointer.\n   */\n  function readUint64(\n    bytes calldata _data,\n    uint256 _index\n  ) internal pure returns (\n    uint64 a,\n    uint256 newPointer\n  ) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := and(shr(192, word), 0xffffffffffffffff)\n      newPointer := add(_index, 8)\n    }\n  }\n\n  /**\n   * @notice Returns the bytes32 value at the given index in the input data and updates the pointer.\n   * @param _data The input data.\n   * @param _pointer The index of the value to retrieve.\n   * @return a The bytes32 value at the given index.\n   * @return newPointer The new pointer.\n   */\n  function readBytes32(\n    bytes calldata _data,\n    uint256 _pointer\n  ) internal pure returns (\n    bytes32 a,\n    uint256 newPointer\n  ) {\n    assembly {\n      a := calldataload(add(_pointer, _data.offset))\n      newPointer := add(_pointer, 32)\n    }\n  }\n\n  /**\n   * @notice Returns the uint256 value at the given index in the input data and updates the pointer.\n   * @param _data The input data.\n   * @param _pointer The index of the value to retrieve.\n   * @return a The uint256 value at the given index.\n   * @return newPointer The new pointer.\n   */\n  function readUint256(\n    bytes calldata _data,\n    uint256 _pointer\n  ) internal pure returns (\n    uint256 a,\n    uint256 newPointer\n  ) {\n    assembly {\n      a := calldataload(add(_pointer, _data.offset))\n      newPointer := add(_pointer, 32)\n    }\n  }\n}\n'
      },
      'contracts/libs/p256-verifier/WebAuthn.sol': {
        content:
          '// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport "../../utils/LibString.sol";\nimport "./P256.sol";\n\n/**\n * Helper library for external contracts to verify WebAuthn signatures.\n * based on p256 verifier https://github.com/daimo-eth/p256-verifier/blob/master/src/WebAuthn.sol\n * MIT License\n **/\nlibrary WebAuthn {\n  bytes1 private constant AUTH_DATA_FLAGS_UP = 0x01; // Bit 0\n  bytes1 private constant AUTH_DATA_FLAGS_UV = 0x04; // Bit 2\n  bytes1 private constant AUTH_DATA_FLAGS_BE = 0x08; // Bit 3\n  bytes1 private constant AUTH_DATA_FLAGS_BS = 0x10; // Bit 4\n\n  /// Verifies the authFlags in authenticatorData. Numbers in inline comment\n  /// correspond to the same numbered bullets in\n  /// https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion.\n  function checkAuthFlags(\n    bytes1 flags,\n    bool requireUserVerification,\n    bool requireBackupSanityCheck\n  ) internal pure returns (bool) {\n    // 17. Verify that the UP bit of the flags in authData is set.\n    if (flags & AUTH_DATA_FLAGS_UP != AUTH_DATA_FLAGS_UP) {\n      return false;\n    }\n\n    // 18. If user verification was determined to be required, verify that\n    // the UV bit of the flags in authData is set. Otherwise, ignore the\n    // value of the UV flag.\n    if (\n      requireUserVerification &&\n      (flags & AUTH_DATA_FLAGS_UV) != AUTH_DATA_FLAGS_UV\n    ) {\n      return false;\n    }\n\n    // // 19. If the BE bit of the flags in authData is not set, verify that\n    // // the BS bit is not set.\n    if (requireBackupSanityCheck) {\n      if (flags & AUTH_DATA_FLAGS_BE != AUTH_DATA_FLAGS_BE) {\n        if (flags & AUTH_DATA_FLAGS_BS == AUTH_DATA_FLAGS_BS) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Verifies a Webauthn P256 signature (Authentication Assertion) as described\n   * in https://www.w3.org/TR/webauthn-2/#sctn-verifying-assertion. We do not\n   * verify all the steps as described in the specification, only ones relevant\n   * to our context. Please carefully read through this list before usage.\n   * Specifically, we do verify the following:\n   * - Verify that authenticatorData (which comes from the authenticator,\n   *   such as iCloud Keychain) indicates a well-formed assertion. If\n   *   requireUserVerification is set, checks that the authenticator enforced\n   *   user verification. User verification should be required if,\n   *   and only if, options.userVerification is set to required in the request\n   * - Verifies that the client JSON is of type "webauthn.get", i.e. the client\n   *   was responding to a request to assert authentication.\n   * - Verifies that the client JSON contains the requested challenge.\n   * - Finally, verifies that (r, s) constitute a valid signature over both\n   *   the authenicatorData and client JSON, for public key (x, y).\n   *\n   * We make some assumptions about the particular use case of this verifier,\n   * so we do NOT verify the following:\n   * - Does NOT verify that the origin in the clientDataJSON matches the\n   *   Relying Party\'s origin: It is considered the authenticator\'s\n   *   responsibility to ensure that the user is interacting with the correct\n   *   RP. This is enforced by most high quality authenticators properly,\n   *   particularly the iCloud Keychain and Google Password Manager were\n   *   tested.\n   * - Does NOT verify That c.topOrigin is well-formed: We assume c.topOrigin\n   *   would never be present, i.e. the credentials are never used in a\n   *   cross-origin/iframe context. The website/app set up should disallow\n   *   cross-origin usage of the credentials. This is the default behaviour for\n   *   created credentials in common settings.\n   * - Does NOT verify that the rpIdHash in authData is the SHA-256 hash of an\n   *   RP ID expected by the Relying Party: This means that we rely on the\n   *   authenticator to properly enforce credentials to be used only by the\n   *   correct RP. This is generally enforced with features like Apple App Site\n   *   Association and Google Asset Links. To protect from edge cases in which\n   *   a previously-linked RP ID is removed from the authorised RP IDs,\n   *   we recommend that messages signed by the authenticator include some\n   *   expiry mechanism.\n   * - Does NOT verify the credential backup state: This assumes the credential\n   *   backup state is NOT used as part of Relying Party business logic or\n   *   policy.\n   * - Does NOT verify the values of the client extension outputs: This assumes\n   *   that the Relying Party does not use client extension outputs.\n   * - Does NOT verify the signature counter: Signature counters are intended\n   *   to enable risk scoring for the Relying Party. This assumes risk scoring\n   *   is not used as part of Relying Party business logic or policy.\n   * - Does NOT verify the attestation object: This assumes that\n   *   response.attestationObject is NOT present in the response, i.e. the\n   *   RP does not intend to verify an attestation.\n   */\n  function verifySignature(\n    bytes memory challenge,\n    bytes memory authenticatorData,\n    bool requireUserVerification,\n    bool requireBackupSanityCheck,\n    string memory clientDataJSON,\n    uint256 challengeLocation,\n    uint256 responseTypeLocation,\n    uint256 r,\n    uint256 s,\n    uint256 x,\n    uint256 y\n  ) internal view returns (bool) {\n    // Check that authenticatorData has good flags\n    if (\n      authenticatorData.length < 37 ||\n      !checkAuthFlags(authenticatorData[32], requireUserVerification, requireBackupSanityCheck)\n    ) {\n      return false;\n    }\n\n    // Check that response is for an authentication assertion\n    string memory responseType = \'"type":"webauthn.get"\';\n    if (!LibString.contains(clientDataJSON, responseType, responseTypeLocation)) {\n      return false;\n    }\n\n    // Check that challenge is in the clientDataJSON\n    string memory challengeB64url = LibString.bytesToBase64URL(challenge);\n    string memory challengeProperty = string.concat(\n      \'"challenge":"\',\n      challengeB64url,\n      \'"\'\n    );\n\n    if (!LibString.contains(clientDataJSON, challengeProperty, challengeLocation)) {\n      return false;\n    }\n\n    // Check that the public key signed sha256(authenticatorData || sha256(clientDataJSON))\n    bytes32 messageHash = sha256(\n      abi.encodePacked(authenticatorData, sha256(bytes(clientDataJSON)))\n    );\n\n    return P256.verifySignature(messageHash, r, s, x, y);\n  }\n}\n'
      },
      'contracts/Wallet.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n/**\n    Minimal upgradeable proxy implementation, delegates all calls to the address\n    defined by the storage slot matching the wallet address.\n\n    Inspired by EIP-1167 Implementation (https://eips.ethereum.org/EIPS/eip-1167)\n\n    deployed code:\n\n        0x00    0x36         0x36      CALLDATASIZE      cds\n        0x01    0x3d         0x3d      RETURNDATASIZE    0 cds\n        0x02    0x3d         0x3d      RETURNDATASIZE    0 0 cds\n        0x03    0x37         0x37      CALLDATACOPY\n        0x04    0x3d         0x3d      RETURNDATASIZE    0\n        0x05    0x3d         0x3d      RETURNDATASIZE    0 0\n        0x06    0x3d         0x3d      RETURNDATASIZE    0 0 0\n        0x07    0x36         0x36      CALLDATASIZE      cds 0 0 0\n        0x08    0x3d         0x3d      RETURNDATASIZE    0 cds 0 0 0\n        0x09    0x30         0x30      ADDRESS           addr 0 cds 0 0 0\n        0x0A    0x54         0x54      SLOAD             imp 0 cds 0 0 0\n        0x0B    0x5a         0x5a      GAS               gas imp 0 cds 0 0 0\n        0x0C    0xf4         0xf4      DELEGATECALL      suc 0\n        0x0D    0x3d         0x3d      RETURNDATASIZE    rds suc 0\n        0x0E    0x82         0x82      DUP3              0 rds suc 0\n        0x0F    0x80         0x80      DUP1              0 0 rds suc 0\n        0x10    0x3e         0x3e      RETURNDATACOPY    suc 0\n        0x11    0x90         0x90      SWAP1             0 suc\n        0x12    0x3d         0x3d      RETURNDATASIZE    rds 0 suc\n        0x13    0x91         0x91      SWAP2             suc 0 rds\n        0x14    0x60 0x18    0x6018    PUSH1             0x18 suc 0 rds\n    /-- 0x16    0x57         0x57      JUMPI             0 rds\n    |   0x17    0xfd         0xfd      REVERT\n    \\-> 0x18    0x5b         0x5b      JUMPDEST          0 rds\n        0x19    0xf3         0xf3      RETURN\n\n    flat deployed code: 0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n\n    deploy function:\n\n        0x00    0x60 0x3a    0x603a    PUSH1             0x3a\n        0x02    0x60 0x0e    0x600e    PUSH1             0x0e 0x3a\n        0x04    0x3d         0x3d      RETURNDATASIZE    0 0x0e 0x3a\n        0x05    0x39         0x39      CODECOPY\n        0x06    0x60 0x1a    0x601a    PUSH1             0x1a\n        0x08    0x80         0x80      DUP1              0x1a 0x1a\n        0x09    0x51         0x51      MLOAD             imp 0x1a\n        0x0A    0x30         0x30      ADDRESS           addr imp 0x1a\n        0x0B    0x55         0x55      SSTORE            0x1a\n        0x0C    0x3d         0x3d      RETURNDATASIZE    0 0x1a\n        0x0D    0xf3         0xf3      RETURN\n        [...deployed code]\n\n    flat deploy function: 0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n*/\nlibrary Wallet {\n  bytes internal constant creationCode = hex"603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3";\n}\n'
      },
      'contracts/modules/commons/interfaces/IModuleHooks.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ninterface IModuleHooks {\n  // Errors\n  error HookAlreadyExists(bytes4 _signature);\n  error HookDoesNotExist(bytes4 _signature);\n\n  // Events\n  event DefinedHook(bytes4 _signature, address _implementation);\n\n  /**\n   * @notice Reads the implementation hook of a signature\n   * @param _signature Signature function\n   * @return The address of the implementation hook, address(0) if none\n  */\n  function readHook(bytes4 _signature) external view returns (address);\n\n  /**\n   * @notice Adds a new hook to handle a given function selector\n   * @param _signature Signature function linked to the hook\n   * @param _implementation Hook implementation contract\n   */\n  function addHook(bytes4 _signature, address _implementation) external;\n\n  /**\n   * @notice Removes a registered hook\n   * @param _signature Signature function linked to the hook\n   */\n  function removeHook(bytes4 _signature) external;\n}\n'
      },
      'contracts/modules/commons/ModuleStorage.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\nlibrary ModuleStorage {\n  function writeBytes32(bytes32 _key, bytes32 _val) internal {\n    assembly { sstore(_key, _val) }\n  }\n\n  function readBytes32(bytes32 _key) internal view returns (bytes32 val) {\n    assembly { val := sload(_key) }\n  }\n\n  function writeBytes32Map(bytes32 _key, bytes32 _subKey, bytes32 _val) internal {\n    bytes32 key = keccak256(abi.encode(_key, _subKey));\n    assembly { sstore(key, _val) }\n  }\n\n  function readBytes32Map(bytes32 _key, bytes32 _subKey) internal view returns (bytes32 val) {\n    bytes32 key = keccak256(abi.encode(_key, _subKey));\n    assembly { val := sload(key) }\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleERC165.sol': {
        content:
          "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\nabstract contract ModuleERC165 {\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @dev Adding new hooks will not lead to them being reported by this function\n   *      without upgrading the wallet. In addition, developers must ensure that\n   *      all inherited contracts by the main module don't conflict and are accounted\n   *      to be supported by the supportsInterface method.\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(bytes4 _interfaceID) virtual public pure returns (bool) {\n    return _interfaceID == this.supportsInterface.selector;\n  }\n}\n"
      },
      'contracts/interfaces/receivers/IERC1155Receiver.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ninterface IERC1155Receiver {\n  function onERC1155Received(address, address, uint256, uint256, bytes calldata) external returns (bytes4);\n  function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external returns (bytes4);\n}\n'
      },
      'contracts/interfaces/receivers/IERC721Receiver.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ninterface IERC721Receiver {\n  function onERC721Received(address, address, uint256, bytes calldata) external returns (bytes4);\n}\n'
      },
      'contracts/interfaces/receivers/IERC223Receiver.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ninterface IERC223Receiver {\n  function tokenFallback(address, uint256, bytes calldata) external;\n}\n'
      },
      'contracts/modules/commons/ModuleNonce.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./ModuleStorage.sol";\n\nimport "./submodules/nonce/SubModuleNonce.sol";\n\n\ncontract ModuleNonce {\n  // Events\n  event NonceChange(uint256 _space, uint256 _newNonce);\n\n  // Errors\n  error BadNonce(uint256 _space, uint256 _provided, uint256 _current);\n\n  //                       NONCE_KEY = keccak256("org.arcadeum.module.calls.nonce");\n  bytes32 private constant NONCE_KEY = bytes32(0x8d0bf1fd623d628c741362c1289948e57b3e2905218c676d3e69abee36d6ae2e);\n\n  /**\n   * @notice Returns the next nonce of the default nonce space\n   * @dev The default nonce space is 0x00\n   * @return The next nonce\n   */\n  function nonce() external virtual view returns (uint256) {\n    return readNonce(0);\n  }\n\n  /**\n   * @notice Returns the next nonce of the given nonce space\n   * @param _space Nonce space, each space keeps an independent nonce count\n   * @return The next nonce\n   */\n  function readNonce(uint256 _space) public virtual view returns (uint256) {\n    return uint256(ModuleStorage.readBytes32Map(NONCE_KEY, bytes32(_space)));\n  }\n\n  /**\n   * @notice Changes the next nonce of the given nonce space\n   * @param _space Nonce space, each space keeps an independent nonce count\n   * @param _nonce Nonce to write on the space\n   */\n  function _writeNonce(uint256 _space, uint256 _nonce) internal {\n    ModuleStorage.writeBytes32Map(NONCE_KEY, bytes32(_space), bytes32(_nonce));\n  }\n\n  /**\n   * @notice Verify if a nonce is valid\n   * @param _rawNonce Nonce to validate (may contain an encoded space)\n   */\n  function _validateNonce(uint256 _rawNonce) internal virtual {\n    // Retrieve current nonce for this wallet\n    (uint256 space, uint256 providedNonce) = SubModuleNonce.decodeNonce(_rawNonce);\n\n    uint256 currentNonce = readNonce(space);\n    if (currentNonce != providedNonce) {\n      revert BadNonce(space, providedNonce, currentNonce);\n    }\n\n    unchecked {\n      uint256 newNonce = providedNonce + 1;\n\n      _writeNonce(space, newNonce);\n      emit NonceChange(space, newNonce);\n      return;\n    }\n  }\n}\n'
      },
      'contracts/modules/commons/ModuleOnlyDelegatecall.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ncontract ModuleOnlyDelegatecall {\n  address private immutable self;\n\n  error OnlyDelegatecall();\n\n  constructor() {\n    self = address(this);\n  }\n\n  /**\n   * @notice Modifier that only allows functions to be called via delegatecall.\n   */\n  modifier onlyDelegatecall() {\n    if (address(this) == self) {\n      revert OnlyDelegatecall();\n    }\n    _;\n  }\n}\n'
      },
      'contracts/modules/commons/interfaces/IModuleCalls.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ninterface IModuleCalls {\n  // Events\n  event TxFailed(bytes32 indexed _tx, uint256 _index, bytes _reason);\n  event TxExecuted(bytes32 indexed _tx, uint256 _index);\n\n  // Errors\n  error NotEnoughGas(uint256 _index, uint256 _requested, uint256 _available);\n  error InvalidSignature(bytes32 _hash, bytes _signature);\n\n  // Transaction structure\n  struct Transaction {\n    bool delegateCall;   // Performs delegatecall\n    bool revertOnError;  // Reverts transaction bundle if tx fails\n    uint256 gasLimit;    // Maximum gas to be forwarded\n    address target;      // Address of the contract to call\n    uint256 value;       // Amount of ETH to pass with the call\n    bytes data;          // calldata to pass\n  }\n\n  /**\n   * @notice Allow wallet owner to execute an action\n   * @param _txs        Transactions to process\n   * @param _nonce      Signature nonce (may contain an encoded space)\n   * @param _signature  Encoded signature\n   */\n  function execute(\n    Transaction[] calldata _txs,\n    uint256 _nonce,\n    bytes calldata _signature\n  ) external;\n\n  /**\n   * @notice Allow wallet to execute an action\n   *   without signing the message\n   * @param _txs  Transactions to execute\n   */\n  function selfExecute(\n    Transaction[] calldata _txs\n  ) external;\n}\n'
      },
      'contracts/modules/commons/interfaces/IModuleAuth.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\nabstract contract IModuleAuth {\n  //                        IMAGE_HASH_KEY = keccak256("org.arcadeum.module.auth.upgradable.image.hash");\n  bytes32 internal constant IMAGE_HASH_KEY = bytes32(0xea7157fa25e3aa17d0ae2d5280fa4e24d421c61842aa85e45194e1145aa72bf8);\n\n  event ImageHashUpdated(bytes32 newImageHash);\n\n  // Errors\n  error ImageHashIsZero();\n  error InvalidSignatureType(bytes1 _type);\n\n  function _signatureValidation(\n    bytes32 _digest,\n    bytes calldata _signature\n  ) internal virtual view returns (\n    bool isValid,\n    bytes32 subdigest\n  );\n\n  function signatureRecovery(\n    bytes32 _digest,\n    bytes calldata _signature\n  ) public virtual view returns (\n    uint256 threshold,\n    uint256 weight,\n    bytes32 imageHash,\n    bytes32 subdigest,\n    uint256 checkpoint\n  );\n\n  /**\n   * @notice Validates the signature image\n   * @return true if the signature image is valid\n   */\n  function _isValidImage(bytes32) internal virtual view returns (bool) {\n    return false;\n  }\n\n  /**\n   * @notice Updates the signers configuration of the wallet\n   * @param _imageHash New required image hash of the signature\n   */\n  function updateImageHash(bytes32 _imageHash) external virtual;\n\n  /**\n   * @notice Updates the signers configuration of the wallet\n   * @param _imageHash New required image hash of the signature\n   */\n  function _updateImageHash(bytes32 _imageHash) internal virtual;\n}\n'
      },
      'contracts/modules/commons/submodules/nonce/SubModuleNonce.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\nlibrary SubModuleNonce {\n  // Nonce schema\n  //\n  // - space[160]:nonce[96]\n  //\n  uint256 internal constant NONCE_BITS = 96;\n  bytes32 internal constant NONCE_MASK = bytes32(uint256(type(uint96).max));\n\n  /**\n   * @notice Decodes a raw nonce\n   * @dev Schema: space[160]:type[96]\n   * @param _rawNonce Nonce to be decoded\n   * @return _space The nonce space of the raw nonce\n   * @return _nonce The nonce of the raw nonce\n   */\n  function decodeNonce(uint256 _rawNonce) internal pure returns (\n    uint256 _space,\n    uint256 _nonce\n  ) {\n    unchecked {\n      // Decode nonce\n      _space = _rawNonce >> NONCE_BITS;\n      _nonce = uint256(bytes32(_rawNonce) & NONCE_MASK);\n    }\n  }\n}\n'
      },
      'contracts/modules/commons/submodules/auth/SequenceBaseSig.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "../../../../utils/SignatureValidator.sol";\nimport "../../../../utils/LibBytesPointer.sol";\nimport "../../../../utils/LibBytes.sol";\nimport "../../../../utils/LibOptim.sol";\n\n\n/**\n * @title SequenceBaseSig Library\n * @author Agustin Aguilar (aa@horizon.io)\n * @notice A Solidity implementation for handling signatures in the Sequence protocol.\n */\nlibrary SequenceBaseSig {\n  using LibBytesPointer for bytes;\n\n  uint256 private constant FLAG_SIGNATURE = 0;\n  uint256 private constant FLAG_ADDRESS = 1;\n  uint256 private constant FLAG_DYNAMIC_SIGNATURE = 2;\n  uint256 private constant FLAG_NODE = 3;\n  uint256 private constant FLAG_BRANCH = 4;\n  uint256 private constant FLAG_SUBDIGEST = 5;\n  uint256 private constant FLAG_NESTED = 6;\n\n  error InvalidNestedSignature(bytes32 _hash, address _addr, bytes _signature);\n  error InvalidSignatureFlag(uint256 _flag);\n\n  /**\n  * @notice Generates a subdigest for the input digest (unique for this wallet and network).\n  * @param _digest The input digest to generate the subdigest from.\n  * @return bytes32 The subdigest generated from the input digest.\n  */\n  function subdigest(\n    bytes32 _digest\n  ) internal view returns (bytes32) {\n    return keccak256(\n      abi.encodePacked(\n        "\\x19\\x01",\n        block.chainid,\n        address(this),\n        _digest\n      )\n    );\n  }\n\n  /**\n  * @notice Generates the leaf for an address and weight.\n  * @dev The leaf is generated by concatenating the address and weight.\n  *\n  * @param _addr The address to generate the leaf for.\n  * @param _weight The weight to generate the leaf for.\n  * @return bytes32 The leaf generated from the address and weight.\n  */\n  function _leafForAddressAndWeight(\n    address _addr,\n    uint96 _weight\n  ) internal pure returns (bytes32) {\n    unchecked {\n      return bytes32(uint256(_weight) << 160 | uint256(uint160(_addr)));\n    }\n  }\n\n  /**\n  * @notice Generates the leaf for a hardcoded subdigest.\n  * @dev The leaf is generated by hashing \'Sequence static digest:\\n\' and the subdigest.\n  * @param _subdigest The subdigest to generate the leaf for.\n  * @return bytes32 The leaf generated from the hardcoded subdigest.\n  */\n  function _leafForHardcodedSubdigest(\n    bytes32 _subdigest\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\'Sequence static digest:\\n\', _subdigest));\n  }\n\n  /**\n  * @notice Generates the leaf for a nested tree node.\n  * @dev The leaf is generated by hashing \'Sequence nested config:\\n\', the node, the threshold and the weight.\n  *\n  * @param _node The root of the node to generate the leaf for.\n  * @param _threshold The internal threshold of the tree.\n  * @param _weight The external weight of the tree.\n  * @return bytes32 The leaf generated from the nested tree.\n  */\n  function _leafForNested(\n    bytes32 _node,\n    uint256 _threshold,\n    uint256 _weight\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\'Sequence nested config:\\n\', _node, _threshold, _weight));\n  }\n\n  /**\n   * @notice Returns the weight and root of a signature branch.\n   * @dev If the signature contains a hardcoded subdigest, and it matches the input digest, then the weight is set to 2 ** 256 - 1.\n   *\n   * @param _subdigest The digest to verify the signature against.\n   * @param _signature The signature branch to recover.\n   * @return weight The total weight of the recovered signatures.\n   * @return root The root hash of the recovered configuration.\n   */\n  function recoverBranch(\n    bytes32 _subdigest,\n    bytes calldata _signature\n  ) internal view returns (\n    uint256 weight,\n    bytes32 root\n  ) {\n    unchecked {\n      uint256 rindex;\n\n      // Iterate until the image is completed\n      while (rindex < _signature.length) {\n        // Read next item type\n        uint256 flag;\n        (flag, rindex) = _signature.readUint8(rindex);\n\n        if (flag == FLAG_ADDRESS) {\n          // Read plain address\n          uint8 addrWeight; address addr;\n          (addrWeight, addr, rindex) = _signature.readUint8Address(rindex);\n\n          // Write weight and address to image\n          bytes32 node = _leafForAddressAndWeight(addr, addrWeight);\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\n          continue;\n        }\n\n        if (flag == FLAG_SIGNATURE) {\n          // Read weight\n          uint8 addrWeight;\n          (addrWeight, rindex) = _signature.readUint8(rindex);\n\n          // Read single signature and recover signer\n          uint256 nrindex = rindex + 66;\n          address addr = SignatureValidator.recoverSigner(_subdigest, _signature[rindex:nrindex]);\n          rindex = nrindex;\n\n          // Acumulate total weight of the signature\n          weight += addrWeight;\n\n          // Write weight and address to image\n          bytes32 node = _leafForAddressAndWeight(addr, addrWeight);\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\n          continue;\n        }\n\n        if (flag == FLAG_DYNAMIC_SIGNATURE) {\n          // Read signer and weight\n          uint8 addrWeight; address addr;\n          (addrWeight, addr, rindex) = _signature.readUint8Address(rindex);\n\n          // Read signature size\n          uint256 size;\n          (size, rindex) = _signature.readUint24(rindex);\n\n          // Read dynamic size signature\n          uint256 nrindex = rindex + size;\n          if (!SignatureValidator.isValidSignature(_subdigest, addr, _signature[rindex:nrindex])) {\n            revert InvalidNestedSignature(_subdigest, addr, _signature[rindex:nrindex]);\n          }\n          rindex = nrindex;\n\n          // Acumulate total weight of the signature\n          weight += addrWeight;\n\n          // Write weight and address to image\n          bytes32 node = _leafForAddressAndWeight(addr, addrWeight);\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\n          continue;\n        }\n\n        if (flag == FLAG_NODE) {\n          // Read node hash\n          bytes32 node;\n          (node, rindex) = _signature.readBytes32(rindex);\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\n          continue;\n        }\n\n        if (flag == FLAG_BRANCH) {\n          // Enter a branch of the signature merkle tree\n          uint256 size;\n          (size, rindex) = _signature.readUint24(rindex);\n          uint256 nrindex = rindex + size;\n\n          uint256 nweight; bytes32 node;\n          (nweight, node) = recoverBranch(_subdigest, _signature[rindex:nrindex]);\n\n          weight += nweight;\n          root = LibOptim.fkeccak256(root, node);\n\n          rindex = nrindex;\n          continue;\n        }\n\n        if (flag == FLAG_NESTED) {\n          // Enter a branch of the signature merkle tree\n          // but with an internal threshold and an external fixed weight\n          uint256 externalWeight;\n          (externalWeight, rindex) = _signature.readUint8(rindex);\n\n          uint256 internalThreshold;\n          (internalThreshold, rindex) = _signature.readUint16(rindex);\n\n          uint256 size;\n          (size, rindex) = _signature.readUint24(rindex);\n          uint256 nrindex = rindex + size;\n\n          uint256 internalWeight; bytes32 internalRoot;\n          (internalWeight, internalRoot) = recoverBranch(_subdigest, _signature[rindex:nrindex]);\n          rindex = nrindex;\n\n          if (internalWeight >= internalThreshold) {\n            weight += externalWeight;\n          }\n\n          bytes32 node = _leafForNested(internalRoot, internalThreshold, externalWeight);\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\n\n          continue;\n        }\n\n        if (flag == FLAG_SUBDIGEST) {\n          // A hardcoded always accepted digest\n          // it pushes the weight to the maximum\n          bytes32 hardcoded;\n          (hardcoded, rindex) = _signature.readBytes32(rindex);\n          if (hardcoded == _subdigest) {\n            weight = type(uint256).max;\n          }\n\n          bytes32 node = _leafForHardcodedSubdigest(hardcoded);\n          root = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\n          continue;\n        }\n\n        revert InvalidSignatureFlag(flag);\n      }\n    }\n  }\n\n  /**\n   * @notice Returns the threshold, weight, root, and checkpoint of a signature.\n   * @dev To verify the signature, the weight must be greater than or equal to the threshold, and the root\n   *      must match the expected `imageHash` of the wallet.\n   *\n   * @param _subdigest The digest to verify the signature against.\n   * @param _signature The signature to recover.\n   * @return threshold The minimum weight required for the signature to be valid.\n   * @return weight The total weight of the recovered signatures.\n   * @return imageHash The root hash of the recovered configuration\n   * @return checkpoint The checkpoint of the signature.\n   */\n  function recover(\n    bytes32 _subdigest,\n    bytes calldata _signature\n  ) internal view returns (\n    uint256 threshold,\n    uint256 weight,\n    bytes32 imageHash,\n    uint256 checkpoint\n  ) {\n    unchecked {\n      (weight, imageHash) = recoverBranch(_subdigest, _signature[6:]);\n\n      // Threshold & checkpoint are the top nodes\n      // (but they are first on the signature)\n      threshold = LibBytes.readFirstUint16(_signature);\n      checkpoint = LibBytes.readUint32(_signature, 2);\n\n      imageHash = LibOptim.fkeccak256(imageHash, bytes32(threshold));\n      imageHash = LibOptim.fkeccak256(imageHash, bytes32(checkpoint));\n    }\n  }\n}\n'
      },
      'contracts/utils/LibOptim.sol': {
        content:
          "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n/**\n * @title Library for optimized EVM operations\n * @author Agustin Aguilar (aa@horizon.io)\n * @notice This library contains functions for optimizing certain EVM operations.\n */\nlibrary LibOptim {\n\n  /**\n   * @notice Computes the keccak256 hash of two 32-byte inputs.\n   * @dev It uses only scratch memory space.\n   * @param _a The first 32 bytes of the hash.\n   * @param _b The second 32 bytes of the hash.\n   * @return c The keccak256 hash of the two 32-byte inputs.\n   */\n  function fkeccak256(\n    bytes32 _a,\n    bytes32 _b\n  ) internal pure returns (bytes32 c) {\n    assembly {\n      mstore(0, _a)\n      mstore(32, _b)\n      c := keccak256(0, 64)\n    }\n  }\n\n  /**\n   * @notice Returns the return data from the last call.\n   * @return r The return data from the last call.\n   */\n  function returnData() internal pure returns (bytes memory r) {\n    assembly {\n      let size := returndatasize()\n      r := mload(0x40)\n      let start := add(r, 32)\n      mstore(0x40, add(start, size))\n      mstore(r, size)\n      returndatacopy(start, 0, size)\n    }\n  }\n\n  /**\n   * @notice Calls another contract with the given parameters.\n   * @dev This method doesn't increase the memory pointer.\n   * @param _to The address of the contract to call.\n   * @param _val The value to send to the contract.\n   * @param _gas The amount of gas to provide for the call.\n   * @param _data The data to send to the contract.\n   * @return r The success status of the call.\n   */\n  function call(\n    address _to,\n    uint256 _val,\n    uint256 _gas,\n    bytes calldata _data\n  ) internal returns (bool r) {\n    assembly {\n      let tmp := mload(0x40)\n      calldatacopy(tmp, _data.offset, _data.length)\n\n      r := call(\n        _gas,\n        _to,\n        _val,\n        tmp,\n        _data.length,\n        0,\n        0\n      )\n    }\n  }\n\n  /**\n   * @notice Calls another contract with the given parameters, using delegatecall.\n   * @dev This method doesn't increase the memory pointer.\n   * @param _to The address of the contract to call.\n   * @param _gas The amount of gas to provide for the call.\n   * @param _data The data to send to the contract.\n   * @return r The success status of the call.\n   */\n  function delegatecall(\n    address _to,\n    uint256 _gas,\n    bytes calldata _data\n  ) internal returns (bool r) {\n    assembly {\n      let tmp := mload(0x40)\n      calldatacopy(tmp, _data.offset, _data.length)\n\n      r := delegatecall(\n        _gas,\n        _to,\n        tmp,\n        _data.length,\n        0,\n        0\n      )\n    }\n  }\n}\n"
      },
      'contracts/modules/commons/interfaces/IModuleCreator.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ninterface IModuleCreator {\n  error CreateFailed(bytes _code);\n\n  /**\n   * @notice Creates a contract forwarding eth value\n   * @param _code Creation code of the contract\n   * @return addr The address of the created contract\n   */\n  function createContract(bytes calldata _code) external payable returns (address addr);\n}\n'
      },
      'contracts/utils/LibBytes.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\n/**\n * @title Library for reading data from bytes arrays\n * @author Agustin Aguilar (aa@horizon.io)\n * @notice This library contains functions for reading data from bytes arrays.\n *\n * @dev These functions do not check if the input index is within the bounds of the data array.\n *         Reading out of bounds may return dirty values.\n */\nlibrary LibBytes {\n\n  /**\n   * @notice Returns the bytes32 value at the given index in the input data.\n   * @param data The input data.\n   * @param index The index of the value to retrieve.\n   * @return a The bytes32 value at the given index.\n   */\n  function readBytes32(\n    bytes calldata data,\n    uint256 index\n  ) internal pure returns (\n    bytes32 a\n  ) {\n    assembly {\n      a := calldataload(add(data.offset, index))\n    }\n  }\n\n  /**\n   * @notice Returns the uint8 value at the given index in the input data.\n   * @param data The input data.\n   * @param index The index of the value to retrieve.\n   * @return a The uint8 value at the given index.\n   */\n  function readUint8(\n    bytes calldata data,\n    uint256 index\n  ) internal pure returns (\n    uint8 a\n  ) {\n    assembly {\n      let word := calldataload(add(index, data.offset))\n      a := shr(248, word)\n    }\n  }\n\n  /**\n   * @notice Returns the first uint16 value in the input data.\n   * @param data The input data.\n   * @return a The first uint16 value in the input data.\n   */\n  function readFirstUint16(\n    bytes calldata data\n  ) internal pure returns (\n    uint16 a\n  ) {\n    assembly {\n      let word := calldataload(data.offset)\n      a := shr(240, word)\n    }\n  }\n\n  /**\n   * @notice Returns the uint32 value at the given index in the input data.\n   * @param data The input data.\n   * @param index The index of the value to retrieve.\n   * @return a The uint32 value at the given index.\n   */\n  function readUint32(\n    bytes calldata data,\n    uint256 index\n  ) internal pure returns (\n    uint32 a\n  ) {\n    assembly {\n      let word := calldataload(add(index, data.offset))\n      a := shr(224, word)\n    }\n  }\n}\n'
      },
      'contracts/interfaces/IERC1271Wallet.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\ninterface IERC1271Wallet {\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256("isValidSignature(bytes,bytes)")\n   *   > This function MAY modify Ethereum\'s state\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\n   * @param _signature  Signature byte array associated with _data\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes calldata _data,\n    bytes calldata _signature)\n    external\n    view\n    returns (bytes4 magicValue);\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256("isValidSignature(bytes,bytes)")\n   *   > This function MAY modify Ethereum\'s state\n   * @param _hash       keccak256 hash that was signed\n   * @param _signature  Signature byte array associated with _data\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes calldata _signature)\n    external\n    view\n    returns (bytes4 magicValue);\n}'
      },
      'contracts/modules/commons/submodules/auth/SequenceDynamicSig.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./SequenceBaseSig.sol";\n\n\nlibrary SequenceDynamicSig {\n\n  /**\n   * @notice Recover a "dynamically encoded" Sequence signature.\n   * @dev The Signature is stripped of the first byte, which is the encoding flag.\n   *\n   * @param _subdigest The digest of the signature.\n   * @param _signature The Sequence signature.\n   * @return threshold The threshold weight required to validate the signature.\n   * @return weight The weight of the signature.\n   * @return imageHash The hash of the recovered configuration.\n   * @return checkpoint The checkpoint of the configuration.\n   */\n  function recover(\n    bytes32 _subdigest,\n    bytes calldata _signature\n  ) internal view returns (\n    uint256 threshold,\n    uint256 weight,\n    bytes32 imageHash,\n    uint256 checkpoint\n  ) {\n    return SequenceBaseSig.recover(_subdigest, _signature[1:]);\n  }\n}\n'
      },
      'contracts/modules/commons/submodules/auth/SequenceNoChainIdSig.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\nlibrary SequenceNoChainIdSig {\n\n  /**\n   * @notice Computes a subdigest for a Sequence signature that works on all chains.\n   * @dev The subdigest is computed by removing the chain ID from the digest (using 0 instead).\n   * @param _digest The digest of the chain of signatures.\n   * @return bytes32 The subdigest with no chain ID.\n   */\n  function subdigest(bytes32 _digest) internal view returns (bytes32) {\n    return keccak256(\n      abi.encodePacked(\n        "\\x19\\x01",\n        uint256(0),\n        address(this),\n        _digest\n      )\n    );\n  }\n}\n'
      },
      'contracts/modules/commons/submodules/auth/SequenceChainedSig.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "./SequenceBaseSig.sol";\n\nimport "../../interfaces/IModuleAuth.sol";\n\nimport "../../ModuleSelfAuth.sol";\nimport "../../ModuleStorage.sol";\n\nimport "../../../../utils/LibBytesPointer.sol";\nimport "../../../../utils/LibOptim.sol";\n\n/**\n * @title Sequence chained auth recovery submodule\n * @author Agustin Aguilar (aa@horizon.io)\n * @notice Defines Sequence signatures that work by delegating control to new configurations.\n * @dev The delegations can be chained together, the first signature is the one that is used to validate\n *      the message, the last signature must match the current on-chain configuration of the wallet.\n */\nabstract contract SequenceChainedSig is IModuleAuth, ModuleSelfAuth {\n  using LibBytesPointer for bytes;\n\n  bytes32 public constant SET_IMAGE_HASH_TYPE_HASH = keccak256("SetImageHash(bytes32 imageHash)");\n\n  error LowWeightChainedSignature(bytes _signature, uint256 threshold, uint256 _weight);\n  error WrongChainedCheckpointOrder(uint256 _current, uint256 _prev);\n\n  /**\n   * @notice Defined the special token that must be signed to delegate control to a new configuration.\n   * @param _imageHash The hash of the new configuration.\n   * @return bytes32 The message hash to be signed.\n   */\n  function _hashSetImageHashStruct(bytes32 _imageHash) internal pure returns (bytes32) {\n    return LibOptim.fkeccak256(SET_IMAGE_HASH_TYPE_HASH, _imageHash);\n  }\n\n  /**\n   * @notice Returns the threshold, weight, root, and checkpoint of a (chained) signature.\n   * \n   * @dev This method return the `threshold`, `weight` and `imageHash` of the last signature in the chain.\n   *      Intermediate signatures are validated directly in this method. The `subdigest` is the one of the\n   *      first signature in the chain (since that\'s the one that is used to validate the message).\n   *\n   * @param _digest The digest to recover the signature from.\n   * @param _signature The signature to recover.\n   * @return threshold The threshold of the (last) signature.\n   * @return weight The weight of the (last) signature.\n   * @return imageHash The image hash of the (last) signature.\n   * @return subdigest The subdigest of the (first) signature in the chain.\n   * @return checkpoint The checkpoint of the (last) signature.\n   */\n  function chainedRecover(\n    bytes32 _digest,\n    bytes calldata _signature\n  ) internal view returns (\n    uint256 threshold,\n    uint256 weight,\n    bytes32 imageHash,\n    bytes32 subdigest,\n    uint256 checkpoint\n  ) {\n    uint256 rindex = 1;\n    uint256 sigSize;\n\n    //\n    // First signature out of the loop\n    //\n\n    // First uint24 is the size of the signature\n    (sigSize, rindex) = _signature.readUint24(rindex);\n    uint256 nrindex = sigSize + rindex;\n\n    (\n      threshold,\n      weight,\n      imageHash,\n      subdigest,\n      checkpoint\n    ) = signatureRecovery(\n      _digest,\n      _signature[rindex:nrindex]\n    );\n\n    if (weight < threshold) {\n      revert LowWeightChainedSignature(_signature[rindex:nrindex], threshold, weight);\n    }\n\n    rindex = nrindex;\n\n    // The following signatures are handled by this loop.\n    // This is done this way because the first signature does not have a\n    // checkpoint to be validated against.\n    while (rindex < _signature.length) {\n      // First uint24 is the size of the signature\n      (sigSize, rindex) = _signature.readUint24(rindex);\n      nrindex = sigSize + rindex;\n\n      uint256 nextCheckpoint;\n\n      (\n        threshold,\n        weight,\n        imageHash,,\n        // Do not change the subdigest;\n        // it should remain that of the first signature.\n        nextCheckpoint\n      ) = signatureRecovery(\n        _hashSetImageHashStruct(imageHash),\n        _signature[rindex:nrindex]\n      );\n\n      // Validate signature\n      if (weight < threshold) {\n        revert LowWeightChainedSignature(_signature[rindex:nrindex], threshold, weight);\n      }\n\n      // Checkpoints must be provided in descending order\n      // since the first signature is the one that is used to validate the message\n      // and the last signature is the one that is used to validate the current configuration\n      if (nextCheckpoint >= checkpoint) {\n        revert WrongChainedCheckpointOrder(nextCheckpoint, checkpoint);\n      }\n\n      checkpoint = nextCheckpoint;\n      rindex = nrindex;\n    }\n  }\n}\n'
      },
      'contracts/modules/commons/interfaces/IModuleUpdate.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\nabstract contract IModuleUpdate {\n  // Errors\n  error InvalidImplementation(address _implementation);\n\n  /**\n   * @notice Updates the implementation of the base wallet\n   * @param _implementation New main module implementation\n   * @dev WARNING Updating the implementation can brick the wallet\n   */\n  function updateImplementation(address _implementation) external virtual;\n\n  /**\n   * @notice Updates the implementation of the base wallet, used internally.\n   * @param _implementation New main module implementation\n   * @dev WARNING Updating the implementation can brick the wallet\n   */\n  function _updateImplementation(address _implementation) internal virtual;\n}\n'
      },
      'contracts/modules/commons/Implementation.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n/**\n * @dev Allows modules to access the implementation slot\n */\ncontract Implementation {\n  /**\n   * @notice Updates the Wallet implementation\n   * @param _imp New implementation address\n   * @dev The wallet implementation is stored on the storage slot\n   *   defined by the address of the wallet itself\n   *   WARNING updating this value may break the wallet and users\n   *   must be confident that the new implementation is safe.\n   */\n  function _setImplementation(address _imp) internal {\n    assembly {\n      sstore(address(), _imp)\n    }\n  }\n\n  /**\n   * @notice Returns the Wallet implementation\n   * @return _imp The address of the current Wallet implementation\n   */\n  function _getImplementation() internal view returns (address _imp) {\n    assembly {\n      _imp := sload(address())\n    }\n  }\n}\n'
      },
      'contracts/utils/LibAddress.sol': {
        content:
          "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n\nlibrary LibAddress {\n  /**\n   * @notice Will return true if provided address is a contract\n   * @param account Address to verify if contract or not\n   * @dev This contract will return false if called within the constructor of\n   *      a contract's deployment, as the code is not yet stored on-chain.\n   */\n  function isContract(address account) internal view returns (bool) {\n    uint256 csize;\n    // solhint-disable-next-line no-inline-assembly\n    assembly { csize := extcodesize(account) }\n    return csize != 0;\n  }\n}\n"
      },
      'contracts/utils/LibString.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\n/**\n * @title Library for string manipulation operations\n * @notice This library contains functions for manipulating strings in Solidity.\n */\nlibrary LibString {\n  bytes private constant ALPHABET_HEX_16 = \'0123456789abcdef\';\n  bytes private constant ALPHABET_32 = \'abcdefghijklmnopqrstuvwxyz234567\';\n  bytes private constant ALPHABET_64_URL = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";\n\n  /**\n   * @notice Checks if `_str` contains `_substr` starting at `_location`.\n   * @param _substr Substring to search for.\n   * @param _str String to search within.\n   * @param _location Starting index in `_str` for the search.\n   * @return True if `_substr` is found at `_location` in `_str`, otherwise false.\n   */\n  function contains(\n    string memory _str,\n    string memory _substr,\n    uint256 _location\n  ) internal pure returns (bool) {\n    if (_location >= bytes(_str).length) {\n      return false;\n    }\n\n    uint256 strLen = bytes(_substr).length;\n\n    bytes32 result1;\n    bytes32 result2;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result1 := keccak256(add(_substr, 32), strLen)\n      result2 := keccak256(add(_str, add(32, _location)), strLen)\n    }\n\n    return result1 == result2;\n  }\n\n  /**\n   * @notice Prefixes a hexadecimal string with "0x".\n   * @param _hex The hexadecimal string to prefix.\n   * @return The prefixed hexadecimal string.\n   */\n  function prefixHexadecimal(string memory _hex) internal pure returns (string memory) {\n    return string(abi.encodePacked(\'0x\', _hex));\n  }\n\n  /**\n   * @notice Prefixes a base32 string with "b".\n   * @param _base32 The base32 string to prefix.\n   * @return The prefixed base32 string.\n   */\n  function prefixBase32(string memory _base32) internal pure returns (string memory) {\n    return string(abi.encodePacked(\'b\', _base32));\n  }\n\n  /**\n   * @notice Converts a byte array to a hexadecimal string.\n   * @param _bytes The byte array to convert.\n   * @return The resulting hexadecimal string.\n   */\n  function bytesToHexadecimal(bytes memory _bytes) internal pure returns (string memory) {\n    uint256 bytesLength = _bytes.length;\n    bytes memory bytesArray = new bytes(bytesLength << 1);\n\n    unchecked {\n      for (uint256 i = 0; i < bytesLength; i++) {\n        uint256 word = uint8(_bytes[i]);\n        uint256 ib = i << 1;\n        bytesArray[ib] = bytes1(ALPHABET_HEX_16[word >> 4]);\n        bytesArray[ib + 1] = bytes1(ALPHABET_HEX_16[word & 0xf]);\n      }\n    }\n\n    return string(bytesArray);\n  }\n\n  /**\n   * @notice Converts a byte array to a base32 string.\n   * @param _bytes The byte array to convert.\n   * @return The resulting base32 string.\n   */\n  function bytesToBase32(bytes memory _bytes) internal pure returns (string memory) {\n    uint256 bytesLength = _bytes.length;\n\n    uint256 t1 = bytesLength << 3;\n\n    unchecked {\n      // base32-encoded length = ceil(# of bits / 5)\n      bytes memory bytesArray = new bytes((t1 + 4) / 5);\n\n      uint256 bits = 0;\n      uint256 buffer = 0;\n      uint256 pointer = 0;\n\n      for (uint256 i = 0; i < bytesLength; i++) {\n        buffer = (buffer << 8) | uint8(_bytes[i]);\n        bits += 8;\n\n        while (bits >= 5) {\n          bits -= 5;\n          bytesArray[pointer] = bytes1(ALPHABET_32[(buffer >> bits) & 0x1f]);\n          pointer++;\n        }\n      }\n\n      if (bits > 0) {\n        bytesArray[pointer] = bytes1(ALPHABET_32[(buffer << (5 - bits)) & 0x1f]);\n      }\n\n      return string(bytesArray);\n    }\n  }\n\n  /**\n   * @notice Converts a byte array to a base64 URL string.\n   * @param _bytes The byte array to convert.\n   * @return The resulting base64 URL string.\n   * @dev This function is based on the implementation provided by OpenZeppelin:\n   * - MIT license - OpenZeppelin Contracts (last updated v5.0.0) (utils/Base64.sol)\n   */\n  function bytesToBase64URL(bytes memory _bytes) internal pure returns (string memory) {\n    /**\n     * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n     * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n     */\n    if (_bytes.length == 0) return "";\n\n    // Loads the table into memory\n    bytes memory table = ALPHABET_64_URL;\n\n    // Encoding takes 3-byte chunks of binary data from the `_bytes` parameter\n    // and splits them into 4 numbers of 6 bits each.\n    // For no-padding Base64 URL, the final length should be the exact number of required characters,\n    // without rounding up to the nearest multiple of 4.\n    // - `4 * _bytes.length / 3` computes the base length (ignoring leftover bytes)\n    // - The conditional adds extra characters for leftover bytes (if any):\n    //   - If there\'s 1 leftover byte, 2 extra characters are needed.\n    //   - If there are 2 leftover bytes, 3 extra characters are needed.\n    uint256 encodedLen = 4 * _bytes.length / 3; \n    if (_bytes.length % 3 > 0) { \n        encodedLen += 2 - (_bytes.length % 3 - 1); \n    }\n    string memory result = new string(encodedLen);\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      // Prepare the lookup table (skip the first "length" byte)\n      let tablePtr := add(table, 1)\n\n      // Prepare result pointer, jump over length\n      let resultPtr := add(result, 32)\n\n      // Run over the input, 3 bytes at a time\n      for {\n        let dataPtr := _bytes\n        let endPtr := add(_bytes, mload(_bytes))\n      } lt(dataPtr, endPtr) { } {\n        // Advance 3 bytes\n        dataPtr := add(dataPtr, 3)\n        let input := mload(dataPtr)\n\n        // To write each character, shift the 3 bytes (18 bits) chunk\n        // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n        // and apply logical AND with 0x3F which is the number of\n        // the previous character in the ASCII table prior to the Base64 Table\n        // The result is then added to the table to get the character to write,\n        // and finally write it in the result pointer but with a left shift\n        // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n\n        mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n        resultPtr := add(resultPtr, 1) // Advance\n      }\n    }\n\n    return result;\n  }\n}\n'
      },
      'contracts/libs/p256-verifier/P256.sol': {
        content:
          "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n\n/**\n * Helper library for external contracts to verify P256 signatures.\n * Provided by: https://github.com/Vectorized/solady/blob/main/src/utils/P256.sol\n **/\nlibrary P256 {\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                        CUSTOM ERRORS                       */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Unable to verify the P256 signature, due to missing\n  /// RIP-7212 P256 verifier precompile and missing Daimo P256 verifier.\n  error P256VerificationFailed();\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                         CONSTANTS                          */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Address of the Daimo P256 verifier.\n  address internal constant VERIFIER = 0xc2b78104907F722DABAc4C69f826a522B2754De4;\n\n  /// @dev Address of the RIP-7212 P256 verifier precompile.\n  /// Currently, we don't support EIP-7212's precompile at 0x0b as it has not been finalized.\n  /// See: https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md\n  address internal constant RIP_PRECOMPILE = 0x0000000000000000000000000000000000000100;\n\n  /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n  /*                P256 VERIFICATION OPERATIONS                */\n  /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n  /// @dev Returns if the signature (`r`, `s`) is valid for `hash` and public key (`x`, `y`).\n  /// Does NOT include the malleability check.\n  function verifySignature(\n      bytes32 hash,\n      uint256 r,\n      uint256 s,\n      uint256 x,\n      uint256 y\n  ) internal view returns (bool isValid) {\n    /// @solidity memory-safe-assembly\n    assembly {\n      let m := mload(0x40)\n      mstore(m, hash)\n      mstore(add(m, 0x20), r)\n      mstore(add(m, 0x40), s)\n      mstore(add(m, 0x60), x)\n      mstore(add(m, 0x80), y)\n      let success := staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20)\n      // `returndatasize` is `0x20` if verifier exists and sufficient gas, else `0x00`.\n      if iszero(returndatasize()) {\n        // The verifier may actually revert, as it has `abi.decode` and `assert`.\n        success := staticcall(gas(), VERIFIER, m, 0xa0, returndatasize(), 0x20)\n        if iszero(returndatasize()) {\n          mstore(returndatasize(), 0xd0d5039b) // `P256VerificationFailed()`.\n          revert(0x1c, 0x04)\n        }\n      }\n      isValid := and(eq(1, mload(0x00)), success)\n    }\n  }\n}\n"
      },
      'contracts/utils/SignatureValidator.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport "../interfaces/IERC1271Wallet.sol";\n\nimport "./LibBytes.sol";\n\n/**\n * @dev Contains logic for signature validation.\n * Signatures from wallet contracts assume ERC-1271 support (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md)\n * Notes: Methods are strongly inspired by contracts in https://github.com/0xProject/0x-monorepo/blob/development/\n */\nlibrary SignatureValidator {\n  // Errors\n  error InvalidSignatureLength(bytes _signature);\n  error EmptySignature();\n  error InvalidSValue(bytes _signature, bytes32 _s);\n  error InvalidVValue(bytes _signature, uint256 _v);\n  error UnsupportedSignatureType(bytes _signature, uint256 _type, bool _recoverMode);\n  error SignerIsAddress0(bytes _signature);\n\n  using LibBytes for bytes;\n\n  /***********************************|\n  |             Variables             |\n  |__________________________________*/\n\n  // bytes4(keccak256("isValidSignature(bytes,bytes)"))\n  bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\n\n  // bytes4(keccak256("isValidSignature(bytes32,bytes)"))\n  bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\n\n  // Allowed signature types.\n  uint256 private constant SIG_TYPE_EIP712 = 1;\n  uint256 private constant SIG_TYPE_ETH_SIGN = 2;\n  uint256 private constant SIG_TYPE_WALLET_BYTES32 = 3;\n\n  /***********************************|\n  |        Signature Functions        |\n  |__________________________________*/\n\n /**\n   * @notice Recover the signer of hash, assuming it\'s an EOA account\n   * @dev Only for SignatureType.EIP712 and SignatureType.EthSign signatures\n   * @param _hash      Hash that was signed\n   *   encoded as (bytes32 r, bytes32 s, uint8 v, ... , SignatureType sigType)\n   */\n  function recoverSigner(\n    bytes32 _hash,\n    bytes calldata _signature\n  ) internal pure returns (address signer) {\n    if (_signature.length != 66) revert InvalidSignatureLength(_signature);\n    uint256 signatureType = _signature.readUint8(_signature.length - 1);\n\n    // Variables are not scoped in Solidity.\n    uint8 v = _signature.readUint8(64);\n    bytes32 r = _signature.readBytes32(0);\n    bytes32 s = _signature.readBytes32(32);\n\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    //\n    // Source OpenZeppelin\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/cryptography/ECDSA.sol\n\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      revert InvalidSValue(_signature, s);\n    }\n\n    if (v != 27 && v != 28) {\n      revert InvalidVValue(_signature, v);\n    }\n\n    // Signature using EIP712\n    if (signatureType == SIG_TYPE_EIP712) {\n      signer = ecrecover(_hash, v, r, s);\n\n    // Signed using web3.eth_sign() or Ethers wallet.signMessage()\n    } else if (signatureType == SIG_TYPE_ETH_SIGN) {\n      signer = ecrecover(\n        keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _hash)),\n        v,\n        r,\n        s\n      );\n\n    } else {\n      // We cannot recover the signer for any other signature type.\n      revert UnsupportedSignatureType(_signature, signatureType, true);\n    }\n\n    // Prevent signer from being 0x0\n    if (signer == address(0x0)) revert SignerIsAddress0(_signature);\n\n    return signer;\n  }\n\n /**\n   * @notice Returns true if the provided signature is valid for the given signer.\n   * @dev Supports SignatureType.EIP712, SignatureType.EthSign, and ERC1271 signatures\n   * @param _hash      Hash that was signed\n   * @param _signer    Address of the signer candidate\n   * @param _signature Signature byte array\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    address _signer,\n    bytes calldata _signature\n  ) internal view returns (bool valid) {\n    if (_signature.length == 0) {\n      revert EmptySignature();\n    }\n\n    uint256 signatureType = uint8(_signature[_signature.length - 1]);\n    if (signatureType == SIG_TYPE_EIP712 || signatureType == SIG_TYPE_ETH_SIGN) {\n      // Recover signer and compare with provided\n      valid = recoverSigner(_hash, _signature) == _signer;\n\n    } else if (signatureType == SIG_TYPE_WALLET_BYTES32) {\n      // Remove signature type before calling ERC1271, restore after call\n      valid = ERC1271_MAGICVALUE_BYTES32 == IERC1271Wallet(_signer).isValidSignature(_hash, _signature[0:_signature.length - 1]);\n\n    } else {\n      // We cannot validate any other signature type.\n      // We revert because we can say nothing about its validity.\n      revert UnsupportedSignatureType(_signature, signatureType, false);\n    }\n  }\n}\n'
      }
    },
    settings: {
      optimizer: {
        enabled: true,
        runs: 10000000
      },
      outputSelection: {
        '*': {
          '*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']
        }
      },
      evmVersion: 'paris',
      viaIR: false,
      libraries: {},
      remappings: [
        'ds-test/=lib/forge-std/lib/ds-test/src/',
        'forge-std/=lib/forge-std/src/',
        '@ensdomains/=node_modules/@ensdomains/',
        'eth-gas-reporter/=node_modules/eth-gas-reporter/',
        'foundry-huff/=lib/foundry-huff/src/',
        'hardhat/=node_modules/hardhat/',
        'solidity-stringutils/=lib/foundry-huff/lib/solidity-stringutils/',
        'stringutils/=lib/foundry-huff/lib/solidity-stringutils/'
      ]
    }
  }
}
