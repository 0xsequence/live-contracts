import { ContractFactory, type ethers } from 'ethers'
import type { VerificationRequest } from 'scripts/types'

// https://github.com/0xsequence/contracts-library/blob/1353b8c00c6f496342e5948056842ab9d0f0eb36/src/tokens/wrappers/clawback/ClawbackMetadata.sol

const abi = [
  {
    inputs: [],
    name: 'InvalidTokenType',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'string',
        name: 'key',
        type: 'string'
      },
      {
        internalType: 'address',
        name: 'tokenAddr',
        type: 'address'
      },
      {
        internalType: 'bytes',
        name: 'callData',
        type: 'bytes'
      }
    ],
    name: 'getStringProperty',
    outputs: [
      {
        components: [
          {
            internalType: 'string',
            name: 'key',
            type: 'string'
          },
          {
            internalType: 'string',
            name: 'value',
            type: 'string'
          }
        ],
        internalType: 'struct ClawbackMetadata.MetadataProperty',
        name: '',
        type: 'tuple'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'string',
        name: 'key',
        type: 'string'
      },
      {
        internalType: 'address',
        name: 'tokenAddr',
        type: 'address'
      },
      {
        internalType: 'bytes',
        name: 'callData',
        type: 'bytes'
      }
    ],
    name: 'getUint256Property',
    outputs: [
      {
        components: [
          {
            internalType: 'string',
            name: 'key',
            type: 'string'
          },
          {
            internalType: 'string',
            name: 'value',
            type: 'string'
          }
        ],
        internalType: 'struct ClawbackMetadata.MetadataProperty',
        name: '',
        type: 'tuple'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'clawbackAddr',
        type: 'address'
      },
      {
        internalType: 'uint256',
        name: 'wrappedTokenId',
        type: 'uint256'
      }
    ],
    name: 'metadata',
    outputs: [
      {
        internalType: 'string',
        name: '',
        type: 'string'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: 'enum IClawbackFunctions.TokenType',
            name: 'tokenType',
            type: 'uint8'
          },
          {
            internalType: 'uint32',
            name: 'templateId',
            type: 'uint32'
          },
          {
            internalType: 'uint56',
            name: 'lockedAt',
            type: 'uint56'
          },
          {
            internalType: 'address',
            name: 'tokenAddr',
            type: 'address'
          },
          {
            internalType: 'uint256',
            name: 'tokenId',
            type: 'uint256'
          }
        ],
        internalType: 'struct IClawbackFunctions.TokenDetails',
        name: 'details',
        type: 'tuple'
      },
      {
        components: [
          {
            internalType: 'bool',
            name: 'destructionOnly',
            type: 'bool'
          },
          {
            internalType: 'bool',
            name: 'transferOpen',
            type: 'bool'
          },
          {
            internalType: 'uint56',
            name: 'duration',
            type: 'uint56'
          },
          {
            internalType: 'address',
            name: 'admin',
            type: 'address'
          }
        ],
        internalType: 'struct IClawbackFunctions.Template',
        name: 'template',
        type: 'tuple'
      }
    ],
    name: 'metadataProperties',
    outputs: [
      {
        components: [
          {
            internalType: 'string',
            name: 'key',
            type: 'string'
          },
          {
            internalType: 'string',
            name: 'value',
            type: 'string'
          }
        ],
        internalType: 'struct ClawbackMetadata.MetadataProperty[]',
        name: 'properties',
        type: 'tuple[]'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'bytes4',
        name: 'interfaceID',
        type: 'bytes4'
      }
    ],
    name: 'supportsInterface',
    outputs: [
      {
        internalType: 'bool',
        name: '',
        type: 'bool'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  }
]

export class ClawbackMetadata extends ContractFactory {
  constructor(signer: ethers.Signer) {
    super(
      abi,
      '608060405234601c57600e6020565b61314161002b823961314190f35b6026565b60405190565b5f80fdfe60806040526004361015610013575b610797565b61001d5f3561006c565b806301ffc9a71461006757806316689bce146100625780636edc3d701461005d5780639be5ce6d146100585763a08206c90361000e57610761565b6106ac565b6103ce565b610395565b6100f8565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61009981610084565b036100a057565b5f80fd5b905035906100b182610090565b565b906020828203126100cc576100c9915f016100a4565b90565b61007c565b151590565b6100df906100d1565b9052565b91906100f6905f602085019401906100d6565b565b346101285761012461011361010e3660046100b3565b61079f565b61011b610072565b918291826100e3565b0390f35b610078565b5f80fd5b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061015d90610135565b810190811067ffffffffffffffff82111761017757604052565b61013f565b9061018f610188610072565b9283610153565b565b67ffffffffffffffff81116101af576101ab602091610135565b0190565b61013f565b90825f939282370152565b909291926101d46101cf82610191565b61017c565b938185526020850190828401116101f0576101ee926101b4565b565b610131565b9080601f8301121561021357816020610210933591016101bf565b90565b61012d565b60018060a01b031690565b61022c90610218565b90565b61023881610223565b0361023f57565b5f80fd5b905035906102508261022f565b565b5f80fd5b5f80fd5b909182601f830112156102945781359167ffffffffffffffff831161028f57602001926001830284011161028a57565b610256565b610252565b61012d565b916060838303126102fe575f83013567ffffffffffffffff81116102f957826102c39185016101f5565b926102d18360208301610243565b92604082013567ffffffffffffffff81116102f4576102f0920161025a565b9091565b610080565b610080565b61007c565b5190565b60209181520190565b90825f9392825e0152565b61033a6103436020936103489361033181610303565b93848093610307565b95869101610310565b610135565b0190565b61037a916020610369604083015f8501518482035f86015261031b565b92015190602081840391015261031b565b90565b6103929160208201915f81840391015261034c565b90565b346103c9576103c56103b46103ab366004610299565b92919091610976565b6103bc610072565b9182918261037d565b0390f35b610078565b34610402576103fe6103ed6103e4366004610299565b92919091610a1b565b6103f5610072565b9182918261037d565b0390f35b610078565b5f80fd5b5f80fd5b6003111561041957565b5f80fd5b9050359061042a8261040f565b565b63ffffffff1690565b61043e8161042c565b0361044557565b5f80fd5b9050359061045682610435565b565b66ffffffffffffff1690565b61046d81610458565b0361047457565b5f80fd5b9050359061048582610464565b565b90565b61049381610487565b0361049a57565b5f80fd5b905035906104ab8261048a565b565b919060a08382031261051d57610516906104c760a061017c565b936104d4825f830161041d565b5f8601526104e58260208301610449565b60208601526104f78260408301610478565b60408601526105098260608301610243565b606086015260800161049e565b6080830152565b610407565b61052b816100d1565b0361053257565b5f80fd5b9050359061054382610522565b565b91906080838203126105a35761059c9061055f608061017c565b9361056c825f8301610536565b5f86015261057d8260208301610536565b602086015261058f8260408301610478565b6040860152606001610243565b6060830152565b610407565b9190610120838203126105d157806105c56105ce925f86016104ad565b9360a001610545565b90565b61007c565b5190565b60209181520190565b60200190565b610617916020610606604083015f8501518482035f86015261031b565b92015190602081840391015261031b565b90565b90610624916105e9565b90565b60200190565b9061064161063a836105d6565b80926105da565b9081610652602083028401946105e3565b925f915b83831061066557505050505090565b909192939460206106876106818385600195038752895161061a565b97610627565b9301930191939290610656565b6106a99160208201915f81840391015261062d565b90565b346106dd576106d96106c86106c23660046105a8565b90611196565b6106d0610072565b91829182610694565b0390f35b610078565b919060408382031261070a57806106fe610707925f8601610243565b9360200161049e565b90565b61007c565b60209181520190565b6107376107406020936107459361072e81610303565b9384809361070f565b95869101610310565b610135565b0190565b61075e9160208201915f818403910152610718565b90565b346107925761078e61077d6107773660046106e2565b90611de7565b610785610072565b91829182610749565b0390f35b610078565b5f80fd5b5f90565b6107a761079b565b50806107c26107bc6301ffc9a760e01b610084565b91610084565b149081156107d9575b506107d4575f90565b600190565b90506107f46107ee63a08206c960e01b610084565b91610084565b145f6107cb565b610805604061017c565b90565b606090565b6108156107fb565b9060208083610822610808565b81520161082d610808565b81525050565b61083b61080d565b90565b905090565b9091826108538161085a9361083e565b80936101b4565b0190565b909161086992610843565b90565b67ffffffffffffffff811161088a57610886602091610135565b0190565b61013f565b906108a161089c8361086c565b61017c565b918252565b606090565b3d5f146108c6576108bb3d61088f565b903d5f602084013e5b565b6108ce6108a6565b906108c4565b909291926108e96108e482610191565b61017c565b938185526020850190828401116109055761090392610310565b565b610131565b9080601f8301121561092857816020610925935191016108d4565b90565b61012d565b9060208282031261095d575f82015167ffffffffffffffff811161095857610955920161090a565b90565b610080565b61007c565b5190565b610970604061017c565b90565b52565b92915f928392610984610833565b509161099a610991610072565b9283928361085e565b03915afa906109a76108ab565b916109b0575f80fd5b6109ce6109eb919260206109c382610962565b81830101910161092d565b6109e26109d9610966565b935f8501610973565b60208301610973565b90565b905051906109fb8261048a565b565b90602082820312610a1657610a13915f016109ee565b90565b61007c565b92915f928392610a29610833565b5091610a3f610a36610072565b9283928361085e565b03915afa90610a4c6108ab565b91610a55575f80fd5b610a7b610a76610a9892936020610a6b82610962565b8183010191016109fd565b6120d6565b610a8f610a86610966565b935f8501610973565b60208301610973565b90565b606090565b634e487b7160e01b5f52602160045260245ffd5b60031115610abe57565b610aa0565b90610acd82610ab4565b565b610ad99051610ac3565b90565b90565b60ff1690565b90565b610afc610af7610b0192610adc565b610ae5565b610adf565b90565b90565b610b1b610b16610b2092610b04565b610ae5565b610adf565b90565b610b37610b32610b3c92610adf565b610ae5565b610487565b90565b67ffffffffffffffff8111610b575760208091020190565b61013f565b90610b6e610b6983610b3f565b61017c565b918252565b610b7b61080d565b90565b5f5b828110610b8c57505050565b602090610b97610b73565b8184015201610b80565b90610bc6610bae83610b5c565b92602080610bbc8693610b3f565b9201910390610b7e565b565b90610bda610bd583610191565b61017c565b918252565b5f7f746f6b656e5f7479706500000000000000000000000000000000000000000000910152565b610c10600a610bc8565b90610c1d60208301610bdf565b565b610c27610c06565b90565b634e487b7160e01b5f52603260045260245ffd5b90610c48826105d6565b811015610c59576020809102010190565b610c2a565b90565b610c75610c70610c7a92610c5e565b610ae5565b610487565b90565b610c879051610223565b90565b5f7f746f6b656e5f6164647265737300000000000000000000000000000000000000910152565b610cbb600d610bc8565b90610cc860208301610c8a565b565b610cd2610cb1565b90565b90565b610cec610ce7610cf192610cd5565b610ae5565b610487565b90565b610cfe905161042c565b90565b610d15610d10610d1a9261042c565b610ae5565b610487565b90565b5f7f74656d706c6174655f6964000000000000000000000000000000000000000000910152565b610d4e600b610bc8565b90610d5b60208301610d1d565b565b610d65610d44565b90565b90565b610d7f610d7a610d8492610d68565b610ae5565b610487565b90565b610d919051610458565b90565b610da8610da3610dad92610458565b610ae5565b610487565b90565b5f7f6c6f636b65645f61740000000000000000000000000000000000000000000000910152565b610de16009610bc8565b90610dee60208301610db0565b565b610df8610dd7565b90565b90565b610e12610e0d610e1792610dfb565b610ae5565b610487565b90565b5f7f756e6c6f636b735f696e00000000000000000000000000000000000000000000910152565b610e4b600a610bc8565b90610e5860208301610e1a565b565b610e62610e41565b90565b90565b610e7c610e77610e8192610e65565b610ae5565b610487565b90565b5f7f6475726174696f6e000000000000000000000000000000000000000000000000910152565b610eb56008610bc8565b90610ec260208301610e84565b565b610ecc610eab565b90565b90565b610ee6610ee1610eeb92610ecf565b610ae5565b610487565b90565b610ef890516100d1565b90565b5f7f6465737472756374696f6e5f6f6e6c7900000000000000000000000000000000910152565b610f2c6010610bc8565b90610f3960208301610efb565b565b610f43610f22565b90565b90565b610f5d610f58610f6292610f46565b610ae5565b610487565b90565b5f7f7472616e736665725f6f70656e00000000000000000000000000000000000000910152565b610f96600d610bc8565b90610fa360208301610f65565b565b610fad610f8c565b90565b90565b610fc7610fc2610fcc92610fb0565b610ae5565b610487565b90565b610fd99051610487565b90565b5f7f746f6b656e5f6964000000000000000000000000000000000000000000000000910152565b61100d6008610bc8565b9061101a60208301610fdc565b565b611024611003565b90565b61103b61103661104092610adc565b610ae5565b610487565b90565b61104c90610487565b9052565b9190611063905f60208501940190611043565b565b5f7f6f726967696e616c5f5552490000000000000000000000000000000000000000910152565b611096600c610bc8565b906110a360208301611065565b565b6110ad61108c565b90565b5f0190565b5f7f6f726967696e616c5f6e616d6500000000000000000000000000000000000000910152565b6110e6600d610bc8565b906110f3602083016110b5565b565b6110fd6110dc565b90565b5f7f6f726967696e616c5f73796d626f6c0000000000000000000000000000000000910152565b611131600f610bc8565b9061113e60208301611100565b565b611148611127565b90565b5f7f6f726967696e616c5f646563696d616c73000000000000000000000000000000910152565b61117c6011610bc8565b906111896020830161114b565b565b611193611172565b90565b9190916111a1610a9b565b506111ad5f8201610acf565b6111c06111ba6001610ac3565b91610ac3565b1480156118d2575b805f146118b25761154c6114fe6114f960206111f56111f06111ea6009610b07565b5b610b23565b610ba1565b9761125861120c6112075f8a01610acf565b61220a565b611233611217610966565b9161122b611223610c1f565b5f8501610973565b858301610973565b6112528b915f9061124c61124683610c61565b85610c3e565b52610c61565b90610c3e565b51506112be61127161126c60608a01610c7d565b61229f565b61129861127c610966565b91611290611288610cca565b5f8501610973565b858301610973565b6112b88b916001906112b26112ac83610cd8565b85610c3e565b52610cd8565b90610c3e565b515061132b6112de6112d96112d4858b01610cf4565b610d01565b6120d6565b6113056112e9610966565b916112fd6112f5610d5d565b5f8501610973565b858301610973565b6113258b9160029061131f61131983610d6b565b85610c3e565b52610d6b565b90610c3e565b515061139961134c61134761134260408b01610d87565b610d94565b6120d6565b611373611357610966565b9161136b611363610df0565b5f8501610973565b858301610973565b6113938b9160039061138d61138783610dfe565b85610c3e565b52610dfe565b90610c3e565b515061141e6113d16113ad60408a01610d87565b6113cb6113c56113bf60408701610d87565b92610d94565b91610d94565b90612427565b6113f86113dc610966565b916113f06113e8610e5a565b5f8501610973565b858301610973565b6114188b9160049061141261140c83610e68565b85610c3e565b52610e68565b90610c3e565b515061148c61143f61143a61143560408501610d87565b610d94565b612768565b61146661144a610966565b9161145e611456610ec4565b5f8501610973565b858301610973565b6114868b9160059061148061147a83610ed2565b85610c3e565b52610ed2565b90610c3e565b51506114f16114a461149f5f8401610eee565b612b4f565b6114cb6114af610966565b916114c36114bb610f3b565b5f8501610973565b858301610973565b6114eb8b916006906114e56114df83610f49565b85610c3e565b52610f49565b90610c3e565b515001610eee565b612b4f565b611526611509610966565b9161151d611515610fa5565b5f8501610973565b60208301610973565b611546869160079061154061153a83610fb3565b85610c3e565b52610fb3565b90610c3e565b5150611846575b61155e5f8201610acf565b61157061156a5f610ac3565b91610ac3565b145f1461167957600490611631606061162a846115db816116759899611597868901610c7d565b906115cd6306fdde0360e01b6115be6115ae610072565b95869260208401908152016110b0565b60208201810382520384610153565b6115d56110f5565b90612ca5565b6115e6848701610c7d565b9061161c6395d89b4160e01b61160d6115fd610072565b95869260208401908152016110b0565b60208201810382520384610153565b611624611140565b90612ca5565b9201610c7d565b9061166763313ce56760e01b611658611648610072565b95869260208401908152016110b0565b60208201810382520384610153565b61166f61118b565b90612d43565b905b565b6116845f8201610acf565b6116976116916001610ac3565b91610ac3565b145f146117b15760049061174e826116fe816117aa96976116ba60608701610c7d565b906116f06306fdde0360e01b6116e16116d1610072565b95869260208401908152016110b0565b60208201810382520384610153565b6116f86110f5565b90612ca5565b61170a60608501610c7d565b906117406395d89b4160e01b611731611721610072565b95869260208401908152016110b0565b60208201810382520384610153565b611748611140565b90612ca5565b61179c61175d60608401610c7d565b9261178d611775608063c87b56dd60e01b9301610fcf565b61177d610072565b9687936020850190815201611050565b60208201810382520384610153565b6117a46110a5565b90612ca5565b905b611677565b6117bc5f8201610acf565b6117cf6117c96002610ac3565b91610ac3565b146117db575b506117ac565b60049061183f92936118316117f260608401610c7d565b9261182261180a60806303a24d0760e21b9301610fcf565b611812610072565b9687936020850190815201611050565b60208201810382520384610153565b6118396110a5565b90612ca5565b905f6117d5565b6118ab61185d61185860808401610fcf565b6120d6565b611885611868610966565b9161187c61187461101c565b5f8501610973565b60208301610973565b6118a5859160089061189f61189983611027565b85610c3e565b52611027565b90610c3e565b5150611553565b61154c6114fe6114f960206111f56111f06118cd6008610ae8565b6111eb565b506118de5f8201610acf565b6118f16118eb6002610ac3565b91610ac3565b146111c8565b606090565b61191061190b61191592610218565b610ae5565b610218565b90565b611921906118fc565b90565b61192d90611918565b90565b611939906118fc565b90565b61194590611930565b90565b60e01b90565b9050519061195b8261040f565b565b9050519061196a82610435565b565b9050519061197982610464565b565b905051906119888261022f565b565b919060a0838203126119fa576119f3906119a460a061017c565b936119b1825f830161194e565b5f8601526119c2826020830161195d565b60208601526119d4826040830161196c565b60408601526119e6826060830161197b565b60608601526080016109ee565b6080830152565b610407565b9060a082820312611a1857611a15915f0161198a565b90565b61007c565b611a25610072565b3d5f823e3d90fd5b90505190611a3a82610522565b565b9190608083820312611a9a57611a9390611a56608061017c565b93611a63825f8301611a2d565b5f860152611a748260208301611a2d565b6020860152611a86826040830161196c565b604086015260600161197b565b6060830152565b610407565b90608082820312611ab857611ab5915f01611a3c565b90565b61007c565b611ac69061042c565b9052565b9190611add905f60208501940190611abd565b565b5f7f7b226e616d65223a2022436c61776261636b2041737365742023000000000000910152565b611b10601a610bc8565b90611b1d60208301611adf565b565b611b27611b06565b90565b60207f6574206f66200000000000000000000000000000000000000000000000000000917f222c20226465736372697074696f6e223a2022412077726170706564206173735f8201520152565b611b816026610bc8565b90611b8e60208301611b2a565b565b611b98611b77565b90565b5f7f2000000000000000000000000000000000000000000000000000000000000000910152565b611bcc6001610bc8565b90611bd960208301611b9b565b565b611be3611bc2565b90565b5f7f2023000000000000000000000000000000000000000000000000000000000000910152565b611c176002610bc8565b90611c2460208301611be6565b565b611c2e611c0d565b90565b7f222c2022696d616765223a2022222c2022646563696d616c73223a20302c20225f82015260206d70726f70657274696573223a207b60901b910152565b611c79602e610bc8565b90611c8660208301611c31565b565b611c90611c6f565b90565b5f7f2c20000000000000000000000000000000000000000000000000000000000000910152565b611cc46002610bc8565b90611cd160208301611c93565b565b611cdb611cba565b90565b5f601160f91b910152565b611cf36001610bc8565b90611d0060208301611cde565b565b611d0a611ce9565b90565b5f63111d101160e11b910152565b611d256004610bc8565b90611d3260208301611d0d565b565b611d3c611d1b565b90565b6001611d4b9101610487565b90565b5f7f7d7d000000000000000000000000000000000000000000000000000000000000910152565b611d7f6002610bc8565b90611d8c60208301611d4e565b565b611d96611d75565b90565b5f7f646174613a6170706c69636174696f6e2f6a736f6e3b6261736536342c000000910152565b611dca601d610bc8565b90611dd760208301611d99565b565b611de1611dc0565b90565b90565b611dff611e3591939293611df96118f7565b50611924565b9260a0611e0b8561193c565b63c1e0372890611e2a8492611e1e610072565b96879485938493611948565b835260048301611050565b03915afa80156120d157611e57608091611e8c945f916120a3575b509561193c565b634edaaca890611e81611e6c60208901610cf4565b92611e75610072565b96879485938493611948565b835260048301611aca565b03915afa90811561209e57611f4c611f32611f24611f0a611efc611f5a95611ef7611ee9611ed1611ecc5f8f9c611f609e8291612070575b509c01610acf565b61220a565b92611ee3611edd611b1f565b916120d6565b90612de1565b611ef1611b90565b90612de1565b612de1565b611f04611bdb565b90612de1565b611f1e611f1960608b01610c7d565b61229f565b90612de1565b611f2c611c26565b90612de1565b611f46611f4160808901610fcf565b6120d6565b90612de1565b611f54611c88565b90612de1565b93611196565b91611f6a836105d6565b91611f745f610c61565b915b82611f89611f8386610487565b91610487565b101561203357612010612002611fec611fde611fc96120169588611fb5611faf5f610c61565b91610487565b1161201c575b611fc3611d02565b90612de1565b5f611fd58b8a90610c3e565b51015190612de1565b611fe6611d34565b90612de1565b6020611ff9898890610c3e565b51015190612de1565b61200a611d02565b90612de1565b92611d3f565b91611f76565b61202e90612028611cd3565b90612de1565b611fbb565b90935061206d925061204e9150612048611d8e565b90612de1565b61206761206261205c611dd9565b92611de4565b612e11565b90612de1565b90565b612091915060803d8111612097575b6120898183610153565b810190611a9f565b5f611ec4565b503d61207f565b611a1d565b6120c4915060a03d81116120ca575b6120bc8183610153565b8101906119ff565b5f611e50565b503d6120b2565b611a1d565b906120df6118f7565b5060806040510191602083016040525f83528290600a5f198092955b019481810660300186530493841561211a5790600a91908092916120fb565b93505082602091039203918252565b5f7f4552432d31313535000000000000000000000000000000000000000000000000910152565b61215a6008610bc8565b9061216760208301612129565b565b612171612150565b90565b5f7f4552432d37323100000000000000000000000000000000000000000000000000910152565b6121a56007610bc8565b906121b260208301612174565b565b6121bc61219b565b90565b5f7f4552432d32300000000000000000000000000000000000000000000000000000910152565b6121f06006610bc8565b906121fd602083016121bf565b565b6122076121e6565b90565b6122126118f7565b50806122266122205f610ac3565b91610ac3565b145f1461223957506122366121ff565b90565b8061224d6122476001610ac3565b91610ac3565b145f14612260575061225d6121b4565b90565b61227361226d6002610ac3565b91610ac3565b14612294575f63a1e9dd9d60e01b815280612290600482016110b0565b0390fd5b61229c612169565b90565b6122b1906122ab6118f7565b50612e29565b9060ff5f190460061b60228301816022026028822016608860f01b60015f5b83811a8302818001520191601483146122ec57916001906122d0565b505050602090828151165f511660011c815118815201908151166020511660011c8151189052565b634e487b7160e01b5f52601160045260245ffd5b61233761233d91939293610487565b92610487565b820180921161234857565b612314565b5f7f556e6c6f636b6564000000000000000000000000000000000000000000000000910152565b61237e6008610bc8565b9061238b6020830161234d565b565b612395612374565b90565b6123a76123ad91939293610487565b92610487565b82039182116123b857565b612314565b90565b6123d46123cf6123d9926123bd565b610ae5565b610487565b90565b5f7f4e65766572000000000000000000000000000000000000000000000000000000910152565b61240d6005610bc8565b9061241a602083016123dc565b565b612424612403565b90565b9061243a916124346118f7565b50612328565b4261244d61244783610487565b91610487565b10156124945761245e904290612398565b8061247661247064141dd60e806123c0565b91610487565b10156124885761248590612768565b90565b5061249161241c565b90565b5061249d61238d565b90565b90565b6124b76124b26124bc926124a0565b610ae5565b610487565b90565b634e487b7160e01b5f52601260045260245ffd5b6124df6124e591610487565b91610487565b9081156124f0570490565b6124bf565b61250161250791610487565b91610487565b908115612512570690565b6124bf565b90565b61252e61252961253392612517565b610ae5565b610487565b90565b90565b61254d61254861255292612536565b610ae5565b610487565b90565b905090565b61257f6125769260209261256d81610303565b94858093612555565b93849101610310565b0190565b5f7f2064617973000000000000000000000000000000000000000000000000000000910152565b6125b660058092612555565b6125bf81612583565b0190565b6125d0906125d59261255a565b6125aa565b90565b90565b5f7f20686f7572730000000000000000000000000000000000000000000000000000910152565b61260e60068092612555565b612617816125db565b0190565b6126289061262d9261255a565b612602565b90565b61263c60028092612555565b61264581611c93565b0190565b9161266261265d61266d946126689461255a565b612630565b9061255a565b612602565b90565b5f7f206d696e75746573000000000000000000000000000000000000000000000000910152565b6126a360088092612555565b6126ac81612670565b0190565b6126bd906126c29261255a565b612697565b90565b916126de6126d96126e9946126e49461255a565b612630565b9061255a565b612697565b90565b5f7f207365636f6e6473000000000000000000000000000000000000000000000000910152565b61271f60088092612555565b612728816126ec565b0190565b6127399061273e9261255a565b612713565b90565b9161275a612755612765946127609461255a565b612630565b9061255a565b612713565b90565b6127706118f7565b5061278781612781620151806124a3565b906124d3565b906127b26127a18261279b620151806124a3565b906124f5565b6127ac610e1061251a565b906124d3565b906127ef6127de6127ce836127c8610e1061251a565b906124f5565b6127d8603c612539565b906124d3565b916127e9603c612539565b906124f5565b916127f86118f7565b938061280c6128065f610c61565b91610487565b11612a75575b50806128266128205f610c61565b91610487565b116129c4575b508061284061283a5f610c61565b91610487565b11612913575b508061285a6128545f610c61565b91610487565b11612864575b5090565b9061287661287182611de4565b610962565b6128886128825f610c61565b91610487565b115f146128d357906128c76128a06128cc93926120d6565b916128b86128ac610072565b93849260208401612741565b60208201810382520382610153565b6125d8565b5b5f612860565b506128fa6129096128e661290e936120d6565b6128ee610072565b9283916020830161272c565b60208201810382520382610153565b6125d8565b6128cd565b909161292661292182611de4565b610962565b6129386129325f610c61565b91610487565b115f14612984579061297761295061297c93926120d6565b9161296861295c610072565b938492602084016126c5565b60208201810382520382610153565b6125d8565b5b905f612846565b506129ab6129ba6129976129bf936120d6565b61299f610072565b928391602083016126b0565b60208201810382520382610153565b6125d8565b61297d565b90926129d76129d282611de4565b610962565b6129e96129e35f610c61565b91610487565b115f14612a355790612a28612a01612a2d93926120d6565b91612a19612a0d610072565b93849260208401612649565b60208201810382520382610153565b6125d8565b5b915f61282c565b50612a5c612a6b612a48612a70936120d6565b612a50610072565b9283916020830161261b565b60208201810382520382610153565b6125d8565b612a2e565b612ab2919450612aad612a8a612a9e926120d6565b612a92610072565b928391602083016125c3565b60208201810382520382610153565b6125d8565b925f612812565b5f7f66616c7365000000000000000000000000000000000000000000000000000000910152565b612aea6005610bc8565b90612af760208301612ab9565b565b612b01612ae0565b90565b5f7f7472756500000000000000000000000000000000000000000000000000000000910152565b612b356004610bc8565b90612b4260208301612b04565b565b612b4c612b2b565b90565b612b576118f7565b505f14612b6a57612b66612b44565b5b90565b612b72612af9565b612b67565b612b8090611930565b90565b919091604081840312612bed57612b9a604061017c565b925f82015167ffffffffffffffff8111612be85781612bba91840161090a565b5f850152602082015167ffffffffffffffff8111612be357612bdc920161090a565b6020830152565b61040b565b61040b565b610407565b90602082820312612c22575f82015167ffffffffffffffff8111612c1d57612c1a9201612b83565b90565b610080565b61007c565b612c3090610223565b9052565b60209181520190565b612c5c612c65602093612c6a93612c5381610962565b93848093612c34565b95869101610310565b610135565b0190565b612c95612c8a612ca2959360608401908482035f860152610718565b936020830190612c27565b6040818403910152612c3d565b90565b92915f91612cb1610a9b565b50612cde612cbe30612b77565b91612ce96316689bce919496612cd2610072565b97889687958695611948565b855260048501612c6e565b03915afa80915f92612d1f575b50155f14612d0f57506001612d0a575b5b90565b612d06565b90612d1a9190612e4e565b612d07565b612d3c9192503d805f833e612d348183610153565b810190612bf2565b905f612cf6565b92915f91612d4f610a9b565b50612d7c612d5c30612b77565b91612d87636edc3d70919496612d70610072565b97889687958695611948565b855260048501612c6e565b03915afa80915f92612dbd575b50155f14612dad57506001612da8575b5b90565b612da4565b90612db89190612e4e565b612da5565b612dda9192503d805f833e612dd28183610153565b810190612bf2565b905f612d94565b612e0e91612e03612dfd612e0993612df76118f7565b50611de4565b91611de4565b90612f03565b6125d8565b90565b612e2690612e1d6118f7565b505f5f91612f84565b90565b612e3b90612e356118f7565b50613095565b9060028083510192613078815203918252565b612e56610a9b565b50612e7b612e76612e66836105d6565b612e706001610cd8565b90612328565b610ba1565b90612e85816105d6565b92612e8f5f610c61565b5b80612ea3612e9d87610487565b91610487565b1015612edb57612ed690612ecf612ebb858390610c3e565b51868391612ec98383610c3e565b52610c3e565b5150611d3f565b612e90565b50612efe92935090612eed84916105d6565b91612ef88383610c3e565b52610c3e565b515090565b919091612f0e6108a6565b5060405192601f1980835193818060208701165b80830151818a015201908115612f3d57819091508290612f22565b505050815191838601828060208601165b808401518184015201918215612f6b578280919350508390612f4e565b50505050602091018082850101905f8252845201604052565b929192612f8f6118f7565b93815180612f9e575b50505050565b90919294506003600282010460021b91610670604051967f4142434445464748494a4b4c4d4e4f505152535455565758595a616263646566601f5215027f6768696a6b6c6d6e6f707172737475767778797a303132333435363738392d5f18603f5260208601938385019280826020010195600460038851945f8a525b0191603f8351818160121c16515f538181600c1c1651600153818160061c165160025316516003535f5181520190858210156130645790603f600360049390915092919261301b565b50955f9460039360209252016040520660020490613d3d60f01b82860352151502809303520382525f808080612f98565b9061309e6118f7565b506002604051608081016040526f30313233343536373839616263646566600f5201916028835260208301905f602883015260601b9060015f5b808001830184821a600f8116518483015360041c5190530160148114613106576014926001919093506130d8565b50505056fea2646970667358221220af7a12b1b953ce0d04de1419af9ef57773cd898b9227a5a2ffb9e1136402e33d64736f6c634300081b0033',
      signer
    )
  }
}

export const CLAWBACKMETADATA_VERIFICATION: Omit<VerificationRequest, 'waitForSuccess'> = {
  contractToVerify: 'src/tokens/wrappers/clawback/ClawbackMetadata.sol:ClawbackMetadata',
  version: 'v0.8.27+commit.40a35a09',
  licenceType: 'Apache-2.0',
  compilerInput: {
    language: 'Solidity',
    sources: {
      'src/tokens/wrappers/clawback/ClawbackMetadata.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport { Duration } from "../../../utils/Duration.sol";\nimport { IMetadataProvider } from "../../common/IMetadataProvider.sol";\nimport { IClawbackFunctions } from "./IClawback.sol";\n\nimport { IERC1155MetadataURI } from "openzeppelin-contracts/contracts/interfaces/IERC1155MetadataURI.sol";\nimport { IERC20Metadata } from "openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol";\nimport { IERC721Metadata } from "openzeppelin-contracts/contracts/interfaces/IERC721Metadata.sol";\nimport { IERC165 } from "openzeppelin-contracts/contracts/utils/introspection/IERC165.sol";\n\nimport { Base64 } from "solady/utils/Base64.sol";\nimport { LibString } from "solady/utils/LibString.sol";\n\nerror InvalidTokenType();\n\ncontract ClawbackMetadata is IMetadataProvider, IERC165 {\n\n    using LibString for *;\n\n    struct MetadataProperty {\n        string key;\n        string value;\n    }\n\n    function metadata(address clawbackAddr, uint256 wrappedTokenId) external view returns (string memory) {\n        IClawbackFunctions clawback = IClawbackFunctions(clawbackAddr);\n\n        IClawbackFunctions.TokenDetails memory details = clawback.getTokenDetails(wrappedTokenId);\n        IClawbackFunctions.Template memory template = clawback.getTemplate(details.templateId);\n\n        string memory tokenTypeStr = _toTokenTypeStr(details.tokenType);\n\n        //solhint-disable quotes\n\n        string memory json = \'{"name": "Clawback Asset #\'.concat(wrappedTokenId.toString()).concat(\n            \'", "description": "A wrapped asset of \'\n        ).concat(tokenTypeStr).concat(" ").concat(details.tokenAddr.toHexStringChecksummed()).concat(" #").concat(\n            details.tokenId.toString()\n        ).concat(\'", "image": "", "decimals": 0, "properties": {\');\n\n        MetadataProperty[] memory properties = metadataProperties(details, template);\n        uint256 len = properties.length;\n        for (uint256 i = 0; i < len;) {\n            if (i > 0) {\n                json = json.concat(", ");\n            }\n            json = json.concat(\'"\').concat(properties[i].key).concat(\'": "\').concat(properties[i].value).concat(\'"\');\n            unchecked {\n                ++i;\n            }\n        }\n        json = json.concat("}}");\n\n        //solhint-enable quotes\n\n        return "data:application/json;base64,".concat(Base64.encode(bytes(json)));\n    }\n\n    function _toTokenTypeStr(\n        IClawbackFunctions.TokenType tokenType\n    ) internal pure returns (string memory) {\n        if (tokenType == IClawbackFunctions.TokenType.ERC20) {\n            return "ERC-20";\n        } else if (tokenType == IClawbackFunctions.TokenType.ERC721) {\n            return "ERC-721";\n        } else if (tokenType == IClawbackFunctions.TokenType.ERC1155) {\n            return "ERC-1155";\n        }\n        revert InvalidTokenType();\n    }\n\n    function metadataProperties(\n        IClawbackFunctions.TokenDetails memory details,\n        IClawbackFunctions.Template memory template\n    ) public view returns (MetadataProperty[] memory properties) {\n        // From clawback\n        bool hasTokenId = details.tokenType == IClawbackFunctions.TokenType.ERC721\n            || details.tokenType == IClawbackFunctions.TokenType.ERC1155;\n        properties = new MetadataProperty[](hasTokenId ? 9 : 8);\n        properties[0] = MetadataProperty("token_type", _toTokenTypeStr(details.tokenType));\n        properties[1] = MetadataProperty("token_address", details.tokenAddr.toHexStringChecksummed());\n        properties[2] = MetadataProperty("template_id", details.templateId.toString());\n        properties[3] = MetadataProperty("locked_at", details.lockedAt.toString());\n        properties[4] = MetadataProperty("unlocks_in", _formatUnlocksIn(details.lockedAt, template.duration));\n        properties[5] = MetadataProperty("duration", Duration.format(template.duration));\n        properties[6] = MetadataProperty("destruction_only", _boolToString(template.destructionOnly));\n        properties[7] = MetadataProperty("transfer_open", _boolToString(template.transferOpen));\n        if (hasTokenId) {\n            properties[8] = MetadataProperty("token_id", details.tokenId.toString());\n        }\n\n        // From contract\n        if (details.tokenType == IClawbackFunctions.TokenType.ERC20) {\n            properties = _safeAddStringProperty(\n                properties, "original_name", details.tokenAddr, abi.encodeWithSelector(IERC20Metadata.name.selector)\n            );\n            properties = _safeAddStringProperty(\n                properties, "original_symbol", details.tokenAddr, abi.encodeWithSelector(IERC20Metadata.symbol.selector)\n            );\n            properties = _safeAddUint256Property(\n                properties,\n                "original_decimals",\n                details.tokenAddr,\n                abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n            );\n        } else if (details.tokenType == IClawbackFunctions.TokenType.ERC721) {\n            properties = _safeAddStringProperty(\n                properties, "original_name", details.tokenAddr, abi.encodeWithSelector(IERC721Metadata.name.selector)\n            );\n            properties = _safeAddStringProperty(\n                properties,\n                "original_symbol",\n                details.tokenAddr,\n                abi.encodeWithSelector(IERC721Metadata.symbol.selector)\n            );\n            properties = _safeAddStringProperty(\n                properties,\n                "original_URI",\n                details.tokenAddr,\n                abi.encodeWithSelector(IERC721Metadata.tokenURI.selector, details.tokenId)\n            );\n        } else if (details.tokenType == IClawbackFunctions.TokenType.ERC1155) {\n            properties = _safeAddStringProperty(\n                properties,\n                "original_URI",\n                details.tokenAddr,\n                abi.encodeWithSelector(IERC1155MetadataURI.uri.selector, details.tokenId)\n            );\n        }\n    }\n\n    function _boolToString(\n        bool value\n    ) internal pure returns (string memory) {\n        return value ? "true" : "false";\n    }\n\n    function _safeAddStringProperty(\n        MetadataProperty[] memory properties,\n        string memory key,\n        address tokenAddr,\n        bytes memory callData\n    ) internal view returns (MetadataProperty[] memory) {\n        try this.getStringProperty(key, tokenAddr, callData) returns (MetadataProperty memory prop) {\n            properties = _appendProperty(properties, prop);\n        } catch { }\n        return properties;\n    }\n\n    function _safeAddUint256Property(\n        MetadataProperty[] memory properties,\n        string memory key,\n        address tokenAddr,\n        bytes memory callData\n    ) internal view returns (MetadataProperty[] memory) {\n        try this.getUint256Property(key, tokenAddr, callData) returns (MetadataProperty memory prop) {\n            properties = _appendProperty(properties, prop);\n        } catch { }\n        return properties;\n    }\n\n    function getStringProperty(\n        string memory key,\n        address tokenAddr,\n        bytes calldata callData\n    ) external view returns (MetadataProperty memory) {\n        (bool success, bytes memory prop) = tokenAddr.staticcall(callData);\n        if (success) {\n            return MetadataProperty(key, abi.decode(prop, (string)));\n        }\n        // Unable to get property\n        revert();\n    }\n\n    function getUint256Property(\n        string memory key,\n        address tokenAddr,\n        bytes calldata callData\n    ) external view returns (MetadataProperty memory) {\n        (bool success, bytes memory prop) = tokenAddr.staticcall(callData);\n        if (success) {\n            return MetadataProperty(key, abi.decode(prop, (uint256)).toString());\n        }\n        // Unable to get property\n        revert();\n    }\n\n    function _appendProperty(\n        MetadataProperty[] memory properties,\n        MetadataProperty memory prop\n    ) internal pure returns (MetadataProperty[] memory) {\n        MetadataProperty[] memory newProperties = new MetadataProperty[](properties.length + 1);\n        uint256 len = properties.length;\n        for (uint256 i = 0; i < len;) {\n            newProperties[i] = properties[i];\n            unchecked {\n                ++i;\n            }\n        }\n        newProperties[properties.length] = prop;\n        return newProperties;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual returns (bool) {\n        if (interfaceID == type(IERC165).interfaceId || interfaceID == type(IMetadataProvider).interfaceId) {\n            return true;\n        }\n        return false;\n    }\n\n    function _formatUnlocksIn(uint256 lockedAt, uint256 duration) internal view returns (string memory) {\n        uint256 unlocksAt = lockedAt + duration;\n        if (block.timestamp >= unlocksAt) {\n            return "Unlocked";\n        }\n\n        uint256 remaining = unlocksAt - block.timestamp;\n        if (remaining >= 999999 days) {\n            return "Never";\n        }\n\n        return Duration.format(remaining);\n    }\n\n}\n'
      },
      'src/utils/Duration.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport { LibString } from "solady/utils/LibString.sol";\n\nlibrary Duration {\n\n    using LibString for *;\n\n    function format(\n        uint256 totalSeconds\n    ) internal pure returns (string memory) {\n        uint256 d = totalSeconds / (24 * 60 * 60);\n        uint256 h = (totalSeconds % (24 * 60 * 60)) / (60 * 60);\n        uint256 m = (totalSeconds % (60 * 60)) / 60;\n        uint256 s = totalSeconds % 60;\n\n        string memory result;\n\n        if (d > 0) {\n            result = string(abi.encodePacked(d.toString(), " days"));\n        }\n        if (h > 0) {\n            result = bytes(result).length > 0\n                ? string(abi.encodePacked(result, ", ", h.toString(), " hours"))\n                : string(abi.encodePacked(h.toString(), " hours"));\n        }\n        if (m > 0) {\n            result = bytes(result).length > 0\n                ? string(abi.encodePacked(result, ", ", m.toString(), " minutes"))\n                : string(abi.encodePacked(m.toString(), " minutes"));\n        }\n        if (s > 0) {\n            result = bytes(result).length > 0\n                ? string(abi.encodePacked(result, ", ", s.toString(), " seconds"))\n                : string(abi.encodePacked(s.toString(), " seconds"));\n        }\n\n        return result;\n    }\n\n}\n'
      },
      'src/tokens/common/IMetadataProvider.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ninterface IMetadataProvider {\n\n    /**\n     * Provides the metadata for the given token.\n     * @param tokenAddress The address of the token.\n     * @param tokenId The ID of the token.\n     */\n    function metadata(address tokenAddress, uint256 tokenId) external view returns (string memory);\n\n}\n'
      },
      'src/tokens/wrappers/clawback/IClawback.sol': {
        content:
          "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ninterface IClawbackFunctions {\n\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n\n    struct Template {\n        bool destructionOnly;\n        bool transferOpen;\n        uint56 duration;\n        address admin;\n    }\n\n    struct TokenDetails {\n        TokenType tokenType;\n        uint32 templateId;\n        uint56 lockedAt;\n        address tokenAddr;\n        uint256 tokenId; // 0 for ERC20\n    }\n\n    // Wrap functions\n\n    /**\n     * Wraps a token.\n     * @param templateId The template ID.\n     * @param tokenType The token type.\n     * @param tokenAddr The token address.\n     * @param tokenId The token ID.\n     * @param amount The amount to wrap.\n     * @param receiver The receiver of the wrapped token.\n     * @return wrappedTokenId The wrapped token ID.\n     */\n    function wrap(\n        uint32 templateId,\n        TokenType tokenType,\n        address tokenAddr,\n        uint256 tokenId,\n        uint256 amount,\n        address receiver\n    ) external returns (uint256 wrappedTokenId);\n\n    /**\n     * Add more tokens to a wrapping.\n     * @param wrappedTokenId The wrapped token ID.\n     * @param amount The amount to wrap.\n     * @param receiver The receiver of the wrapped token.\n     */\n    function addToWrap(uint256 wrappedTokenId, uint256 amount, address receiver) external;\n\n    /**\n     * Unwraps a token.\n     * @param wrappedTokenId The wrapped token ID.\n     * @param holder The holder of the token.\n     * @param amount The amount to unwrap.\n     * @dev Unwrapped tokens are sent to the wrapped token holder.\n     */\n    function unwrap(uint256 wrappedTokenId, address holder, uint256 amount) external;\n\n    /**\n     * Clawback a token.\n     * @param wrappedTokenId The wrapped token ID.\n     * @param holder The holder of the token.\n     * @param receiver The receiver of the token.\n     * @param amount The amount to clawback.\n     * @notice Only an operator of the template can clawback.\n     * @notice Clawback is only allowed when the token is locked.\n     */\n    function clawback(uint256 wrappedTokenId, address holder, address receiver, uint256 amount) external;\n\n    /**\n     * Clawback unwrapped tokens without burning wrapped tokens.\n     * @param wrappedTokenId The wrapped token ID.\n     * @param receiver The receiver of the token.\n     * @param amount The amount to clawback.\n     * @notice Clawback rules apply.\n     * @notice This function doesn't affect the wrapped token and should only be used when wrapped tokens are logically inaccessible.\n     * @dev Clawing back an incomplete amount will lead to a race when unwrapping remaining tokens.\n     */\n    function emergencyClawback(uint256 wrappedTokenId, address receiver, uint256 amount) external;\n\n    /**\n     * Returns the details of a wrapped token.\n     * @param wrappedTokenId The wrapped token ID.\n     * @return The token details.\n     */\n    function getTokenDetails(\n        uint256 wrappedTokenId\n    ) external view returns (TokenDetails memory);\n\n    // Template functions\n\n    /**\n     * Gets the details of a template.\n     * @param templateId The template ID.\n     * @return The template details.\n     */\n    function getTemplate(\n        uint32 templateId\n    ) external view returns (Template memory);\n\n    /**\n     * Add a new template.\n     * @param duration The duration of the template.\n     * @param destructionOnly Whether the template is for destruction only.\n     * @param transferOpen Whether the template allows transfers.\n     * @return templateId The template ID.\n     * @notice The msg.sender will be set as the admin of this template.\n     */\n    function addTemplate(\n        uint56 duration,\n        bool destructionOnly,\n        bool transferOpen\n    ) external returns (uint32 templateId);\n\n    /**\n     * Update a template.\n     * @param templateId The template ID.\n     * @param duration The duration of the template. Can only be reduced.\n     * @param destructionOnly Whether the template is for destruction only. Can only be updated from false to true.\n     * @param transferOpen Whether the template allows transfers. Can only be updated from false to true.\n     * @notice Only the admin of the template can update it.\n     */\n    function updateTemplate(uint32 templateId, uint56 duration, bool destructionOnly, bool transferOpen) external;\n\n    /**\n     * Add a transferer to a template.\n     * @param templateId The template ID.\n     * @param transferer The address of the transferer.\n     * @notice Only the admin of the template can add a transferer.\n     * @notice Transferers cannot be removed.\n     * @notice Transfers are allowed when the to, from or operator is a template operator, even when the template is not in transferOpen mode.\n     */\n    function addTemplateTransferer(uint32 templateId, address transferer) external;\n\n    /**\n     * Update an operator to a template.\n     * @param templateId The template ID.\n     * @param operator The address of the operator.\n     * @param allowed Whether the operator is allowed.\n     * @notice Only the admin of the template can update an operator.\n     */\n    function updateTemplateOperator(uint32 templateId, address operator, bool allowed) external;\n\n    /**\n     * Transfer a template admin to another address.\n     * @param templateId The template ID.\n     * @param admin The address to transfer the template to.\n     * @notice Only the admin of the template can transfer it.\n     * @dev Transferring to address(0) is not allowed.\n     */\n    function updateTemplateAdmin(uint32 templateId, address admin) external;\n\n}\n\ninterface IClawbackSignals {\n\n    /// @notice Thrown when the template ID is invalid\n    error InvalidTemplate();\n\n    /// @notice Thrown when token has not been approved\n    error InvalidTokenApproval();\n\n    /// @notice Thrown when token transfer is invalid\n    error InvalidTokenTransfer();\n\n    /// @notice Thrown when token is locked\n    error TokenLocked();\n\n    /// @notice Thrown when token is unlocked\n    error TokenUnlocked();\n\n    /// @notice Thrown when the caller is not authorized\n    error Unauthorized();\n\n    /// @notice Thrown when the receiver is invalid\n    error InvalidReceiver();\n\n    /// @notice Thrown when the template change is invalid\n    error InvalidTemplateChange(string);\n\n    /// @notice Emits when a token is wrapped\n    event Wrapped(\n        uint256 indexed wrappedTokenId,\n        uint32 indexed templateId,\n        address indexed tokenAddr,\n        uint256 tokenId,\n        uint256 amount,\n        address sender,\n        address receiver\n    );\n\n    /// @notice Emits when a token is unwrapped\n    event Unwrapped(\n        uint256 indexed wrappedTokenId,\n        uint32 indexed templateId,\n        address indexed tokenAddr,\n        uint256 tokenId,\n        uint256 amount,\n        address sender\n    );\n\n    /// @notice Emits when a token is clawed back\n    event ClawedBack(\n        uint256 indexed wrappedTokenId,\n        uint32 indexed templateId,\n        address indexed tokenAddr,\n        uint256 tokenId,\n        uint256 amount,\n        address operator,\n        address holder,\n        address receiver\n    );\n\n    /// @notice Emits when a token is clawed back via emergency\n    event EmergencyClawedBack(\n        uint256 indexed wrappedTokenId,\n        uint32 indexed templateId,\n        address indexed tokenAddr,\n        uint256 tokenId,\n        uint256 amount,\n        address operator,\n        address receiver\n    );\n\n    /// @notice Emits when a template is added\n    event TemplateAdded(\n        uint32 indexed templateId, address admin, uint56 duration, bool destructionOnly, bool transferOpen\n    );\n\n    /// @notice Emits when a template is updated\n    event TemplateUpdated(uint32 indexed templateId, uint56 duration, bool destructionOnly, bool transferOpen);\n\n    /// @notice Emits when a template admin is updated\n    event TemplateAdminUpdated(uint32 indexed templateId, address admin);\n\n    /// @notice Emits when a transferer is added\n    event TemplateTransfererAdded(uint32 indexed templateId, address transferer);\n\n    /// @notice Emits when an operator is updated\n    event TemplateOperatorUpdated(uint32 indexed templateId, address operator, bool allowed);\n\n}\n\n// solhint-disable-next-line no-empty-blocks\ninterface IClawback is IClawbackFunctions, IClawbackSignals { }\n"
      },
      'lib/openzeppelin-contracts/contracts/interfaces/IERC1155MetadataURI.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport "../token/ERC1155/extensions/IERC1155MetadataURI.sol";\n'
      },
      'lib/openzeppelin-contracts/contracts/interfaces/IERC20Metadata.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport "../token/ERC20/extensions/IERC20Metadata.sol";\n'
      },
      'lib/openzeppelin-contracts/contracts/interfaces/IERC721Metadata.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport "../token/ERC721/extensions/IERC721Metadata.sol";\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n'
      },
      'lib/solady/src/utils/Base64.sol': {
        content:
          "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"
      },
      'lib/solady/src/utils/LibString.sol': {
        content:
          '// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {LibBytes} from "./LibBytes.sol";\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STRUCTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Goated string storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity\'s native string storage. It\'s meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so its mad tight.\n    struct StringStorage {\n        bytes32 _spacer;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /// @dev The input string must be a 7-bit ASCII.\n    error StringNot7BitASCII();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev Lookup for \'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\'.\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\n\n    /// @dev Lookup for \'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\'.\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\n\n    /// @dev Lookup for \'abcdefghijklmnopqrstuvwxyz\'.\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\n\n    /// @dev Lookup for \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'.\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\n\n    /// @dev Lookup for \'0123456789\'.\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\n\n    /// @dev Lookup for \'0123456789abcdefABCDEF\'.\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\n\n    /// @dev Lookup for \'01234567\'.\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\n\n    /// @dev Lookup for \'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\\\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c\'.\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\n\n    /// @dev Lookup for \'!"#$%&\\\'()*+,-./:;<=>?@[\\\\]^_`{|}~\'.\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\n\n    /// @dev Lookup for \' \\t\\n\\r\\x0b\\x0c\'.\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                 STRING STORAGE OPERATIONS                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sets the value of the string storage `$` to `s`.\n    function set(StringStorage storage $, string memory s) internal {\n        LibBytes.set(bytesStorage($), bytes(s));\n    }\n\n    /// @dev Sets the value of the string storage `$` to `s`.\n    function setCalldata(StringStorage storage $, string calldata s) internal {\n        LibBytes.setCalldata(bytesStorage($), bytes(s));\n    }\n\n    /// @dev Sets the value of the string storage `$` to the empty string.\n    function clear(StringStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty string "".\n    function isEmpty(StringStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(StringStorage storage $) internal view returns (uint256) {\n        return LibBytes.length(bytesStorage($));\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(StringStorage storage $) internal view returns (string memory) {\n        return string(LibBytes.get(bytesStorage($)));\n    }\n\n    /// @dev Returns the uint8 at index `i`. If out-of-bounds, returns 0.\n    function uint8At(StringStorage storage $, uint256 i) internal view returns (uint8) {\n        return LibBytes.uint8At(bytesStorage($), i);\n    }\n\n    /// @dev Helper to cast `$` to a `BytesStorage`.\n    function bytesStorage(StringStorage storage $)\n        internal\n        pure\n        returns (LibBytes.BytesStorage storage casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.slot := $.slot\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the \'0\' character is 48.\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory result) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            result = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let n := mload(result) // Load the string length.\n            mstore(result, 0x2d) // Store the \'-\' character.\n            result := sub(result, 1) // Move back the string pointer by a byte.\n            mstore(result, add(n, 1)) // Update the string length.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `byteCount` bytes.\n    /// The output is prefixed with "0x" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `byteCount * 2 + 2` bytes.\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value, byteCount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the "0x" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `byteCount` bytes.\n    /// The output is not prefixed with "0x" and is encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `byteCount * 2` bytes.\n    /// Reverts if `byteCount` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            // Store "0123456789abcdef" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(result, add(byteCount, byteCount))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(result, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the "0x" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with "0x".\n    /// The output excludes leading "0" from the `toHexString` output.\n    /// `0x00: "0x0", 0x01: "0x1", 0x12: "0x12", 0x123: "0x123"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(add(result, o), 0x3078) // Store the "0x" prefix, accounting for leading zero.\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading "0" from the `toHexStringNoPrefix` output.\n    /// `0x00: "0", 0x01: "1", 0x12: "12", 0x123: "123"`.\n    function toMinimalHexStringNoPrefix(uint256 value)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := mload(result) // Get the length.\n            result := add(result, o) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the "0123456789abcdef" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with "0x", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory result) {\n        result = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(result, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the "0x" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Allocate memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(result, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the "0123456789abcdef" lookup.\n\n            result := add(result, 2)\n            mstore(result, 40) // Store the length.\n            let o := add(result, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the "0x" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(raw)\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(result, add(n, n)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the "0123456789abcdef" lookup.\n            let o := add(result, 0x20)\n            let end := add(raw, n)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let mask := shl(7, div(not(0), 255))\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string,\n    /// AND all characters are in the `allowed` lookup.\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\n    /// To save runtime gas, you can cache the result in an immutable variable.\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(string memory subject, string memory needle, string memory replacement)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), from);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.contains(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.startsWith(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.endsWith(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times) internal pure returns (string memory) {\n        return string(LibBytes.repeat(bytes(subject), times));\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.slice(bytes(subject), start, end));\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start) internal pure returns (string memory) {\n        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        return LibBytes.indicesOf(bytes(subject), bytes(needle));\n    }\n\n    /// @dev Returns an arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(LibBytes.concat(bytes(a), bytes(b)));\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(subject)\n            if n {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let d := sub(subject, result)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                for { let end := add(o, n) } 1 {} {\n                    let b := byte(0, mload(add(d, o)))\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\n                    o := add(o, 1)\n                    if eq(o, end) { break }\n                }\n                mstore(result, n) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for \'\\0\'.\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for \'\\0\'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(s, mload(s))\n            let o := add(result, 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `["\\"","\'","&","<",">"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(o, c)\n                    o := add(o, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(o, mload(and(t, 0x1f)))\n                o := add(o, shr(5, t))\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            // Store "\\\\u0000" in scratch space.\n            // Store "0123456789abcdef" in scratch space.\n            // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `["\\"","\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `["\\"","\\\\"]`.\n                        mstore8(o, c)\n                        o := add(o, 1)\n                        continue\n                    }\n                    mstore8(o, 0x5c) // "\\\\".\n                    mstore8(add(o, 1), c)\n                    o := add(o, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `["\\b","\\t","\\n","\\f","\\d"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(o, mload(0x19)) // "\\\\u00XX".\n                    o := add(o, 6)\n                    continue\n                }\n                mstore8(o, 0x5c) // "\\\\".\n                mstore8(add(o, 1), mload(add(c, 8)))\n                o := add(o, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Encodes `s` so that it can be safely used in a URI,\n    /// just like `encodeURIComponent` in JavaScript.\n    /// See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n    /// See: https://datatracker.ietf.org/doc/html/rfc2396\n    /// See: https://datatracker.ietf.org/doc/html/rfc3986\n    function encodeURIComponent(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Store "0123456789ABCDEF" in scratch space.\n            // Uppercased to be consistent with JavaScript\'s implementation.\n            mstore(0x0f, 0x30313233343536373839414243444546)\n            let o := add(result, 0x20)\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // If not in `[0-9A-Z-a-z-_.!~*\'()]`.\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\n                    mstore8(o, 0x25) // \'%\'.\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\n                    mstore8(add(o, 2), mload(and(c, 15)))\n                    o := add(o, 3)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(string memory a, string memory b) internal pure returns (int256) {\n        return LibBytes.cmp(bytes(a), bytes(b));\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don\'t need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            // We don\'t need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    or( // Load the length and the bytes of `a` and `b`.\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))), mload(sub(add(b, 0x1e), aLen))),\n                    // `totalLen != 0 && totalLen < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLen, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn\'t zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport "../IERC1155.sol";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport "../IERC20.sol";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport "../IERC721.sol";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n'
      },
      'lib/solady/src/utils/LibBytes.sol': {
        content:
          "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for byte related operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBytes.sol)\nlibrary LibBytes {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STRUCTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Goated bytes storage struct that totally MOGs, no cap, fr.\n    /// Uses less gas and bytecode than Solidity's native bytes storage. It's meta af.\n    /// Packs length with the first 31 bytes if <255 bytes, so its mad tight.\n    struct BytesStorage {\n        bytes32 _spacer;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The constant returned when the `search` is not found in the bytes.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  BYTE STORAGE OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to `s`.\n    function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }\n\n    /// @dev Sets the value of the bytes storage `$` to the empty bytes.\n    function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }\n\n    /// @dev Returns whether the value stored is `$` is the empty bytes \"\".\n    function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }\n\n    /// @dev Returns the length of the value stored in `$`.\n    function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }\n\n    /// @dev Returns the value stored in `$`.\n    function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the uint8 at index `i`. If out-of-bounds, returns 0.\n    function uint8At(BytesStorage storage $, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload($.slot) } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    if iszero(gt(i, 0x1e)) {\n                        result := byte(i, packed)\n                        break\n                    }\n                    if iszero(gt(i, and(0xff, packed))) {\n                        mstore(0x00, $.slot)\n                        let j := sub(i, 0x1f)\n                        result := byte(and(j, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, j))))\n                    }\n                    break\n                }\n                if iszero(gt(i, shr(8, packed))) {\n                    mstore(0x00, $.slot)\n                    result := byte(and(i, 0x1f), sload(add(keccak256(0x00, 0x20), shr(5, i))))\n                }\n                break\n            }\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      BYTES OPERATIONS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `subject` all occurrences of `needle` replaced with `replacement`.\n    function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `needle` in `subject`,\n    /// needleing from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `needle` is not found.\n    function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }\n\n    /// @dev Returns true if `needle` is found in `subject`, false otherwise.\n    function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `needle`.\n    function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `needle`.\n    function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset.\n    function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the bytes.\n    /// `start` is a byte offset. Faster than Solidity's native slicing.\n    function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }\n\n    /// @dev Reduces the size of `subject` to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncate(bytes memory subject, uint256 n)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }\n\n    /// @dev Returns a copy of `subject`, with the length reduced to `n`.\n    /// If `n` is greater than the size of `subject`, this will be a no-op.\n    function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }\n\n    /// @dev Returns all the indices of `needle` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns an arrays of bytess based on the `delimiter` inside of the `subject` bytes.\n    function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated bytes of `a` and `b`.\n    /// Cheaper than `bytes.concat()` and does not de-align the free memory pointer.\n    function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small bytes.\n    function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Returns 0 if `a == b`, -1 if `a < b`, +1 if `a > b`.\n    /// If `a` == b[:a.length]`, and `a.length < b.length`, returns -1.\n    function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if iszero(or(xor(x, y), eq(i, n))) {\n                        i := add(i, 0x20)\n                        continue\n                    }\n                    result := sub(gt(x, y), lt(x, y))\n                    break\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let l := 0x201f1e1d1c1b1a191817161514131211100f0e0d0c0b0a090807060504030201\n                let x := and(mload(add(add(a, 0x20), n)), shl(shl(3, byte(sub(aLen, n), l)), not(0)))\n                let y := and(mload(add(add(b, 0x20), n)), shl(shl(3, byte(sub(bLen, n), l)), not(0)))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n\n    /// @dev Directly returns `a` with minimal copying.\n    function directReturn(bytes[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }\n\n    /// @dev Returns the word at `offset`, without any bounds checks.\n    function loadCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }\n\n    /// @dev Returns a slice representing a static struct in the calldata. Performs bounds checks.\n    function staticStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            result.offset := add(a.offset, offset)\n            result.length := sub(a.length, offset)\n            if or(shr(64, or(l, a.offset)), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns a slice representing a dynamic struct in the calldata. Performs bounds checks.\n    function dynamicStructInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(a.offset, s)\n            result.length := sub(a.length, s)\n            if or(shr(64, or(s, or(l, a.offset))), gt(offset, l)) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns bytes in calldata. Performs bounds checks.\n    function bytesInCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := sub(a.length, 0x20)\n            let s := calldataload(add(a.offset, offset)) // Relative offset of `result` from `a.offset`.\n            result.offset := add(add(a.offset, s), 0x20)\n            result.length := calldataload(add(a.offset, s))\n            // forgefmt: disable-next-item\n            if or(shr(64, or(result.length, or(s, or(l, a.offset)))),\n                or(gt(add(s, result.length), l), gt(offset, l))) { revert(l, 0x00) }\n        }\n    }\n\n    /// @dev Returns empty calldata bytes. For silencing the compiler.\n    function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }\n}\n"
      },
      'lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
      },
      'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
      },
      'lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport "../../utils/introspection/IERC165.sol";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``\'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n'
      }
    },
    settings: {
      remappings: [
        '@openzeppelin/contracts/=lib/murky/lib/openzeppelin-contracts/contracts/',
        'ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/',
        'erc2470-libs/=lib/erc2470-libs/',
        'erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/',
        'erc721a/=lib/erc721a/contracts/',
        'forge-std/=lib/forge-std/src/',
        'halmos-cheatcodes/=lib/signals-implicit-mode/lib/sequence-v3/lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/',
        'murky/=lib/murky/',
        'openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/',
        'openzeppelin-contracts/=lib/openzeppelin-contracts/',
        'openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/',
        'sequence-v3/=lib/signals-implicit-mode/lib/sequence-v3/',
        'signals-implicit-mode/=lib/signals-implicit-mode/',
        'solady/=lib/solady/src/'
      ],
      optimizer: {
        enabled: false,
        runs: 200
      },
      metadata: {
        useLiteralContent: true,
        bytecodeHash: 'ipfs',
        appendCBOR: true
      },
      outputSelection: {
        '*': {
          '*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']
        }
      },
      evmVersion: 'cancun',
      viaIR: true,
      libraries: {}
    }
  }
}
