import { ContractFactory, type ethers } from 'ethers'
import type { VerificationRequest } from 'scripts/types'

// https://github.com/0xsequence/niftyswap/blob/b20a97da06504cf4ee2c309290a80447b14e3464/src/contracts/wrapper/NiftyswapExchange20Wrapper.sol

const abi = [
  {
    type: 'function',
    name: 'buyTokens',
    inputs: [
      { name: '_exchange20Address', type: 'address', internalType: 'address' },
      { name: '_tokenIds', type: 'uint256[]', internalType: 'uint256[]' },
      { name: '_tokensBoughtAmounts', type: 'uint256[]', internalType: 'uint256[]' },
      { name: '_maxCurrency', type: 'uint256', internalType: 'uint256' },
      { name: '_deadline', type: 'uint256', internalType: 'uint256' },
      { name: '_tokenRecipient', type: 'address', internalType: 'address' },
      { name: '_currencyRecipient', type: 'address', internalType: 'address' },
      { name: '_extraFeeRecipients', type: 'address[]', internalType: 'address[]' },
      { name: '_extraFeeAmounts', type: 'uint256[]', internalType: 'uint256[]' }
    ],
    outputs: [{ name: 'currencySold', type: 'uint256[]', internalType: 'uint256[]' }],
    stateMutability: 'nonpayable'
  },
  {
    type: 'function',
    name: 'onERC1155BatchReceived',
    inputs: [
      { name: '', type: 'address', internalType: 'address' },
      { name: '', type: 'address', internalType: 'address' },
      { name: '_ids', type: 'uint256[]', internalType: 'uint256[]' },
      { name: '_amounts', type: 'uint256[]', internalType: 'uint256[]' },
      { name: '_data', type: 'bytes', internalType: 'bytes' }
    ],
    outputs: [{ name: '', type: 'bytes4', internalType: 'bytes4' }],
    stateMutability: 'nonpayable'
  },
  {
    type: 'function',
    name: 'onERC1155Received',
    inputs: [
      { name: '', type: 'address', internalType: 'address' },
      { name: '', type: 'address', internalType: 'address' },
      { name: '_id', type: 'uint256', internalType: 'uint256' },
      { name: '_amount', type: 'uint256', internalType: 'uint256' },
      { name: '_data', type: 'bytes', internalType: 'bytes' }
    ],
    outputs: [{ name: '', type: 'bytes4', internalType: 'bytes4' }],
    stateMutability: 'nonpayable'
  },
  {
    type: 'function',
    name: 'supportsInterface',
    inputs: [{ name: 'interfaceID', type: 'bytes4', internalType: 'bytes4' }],
    outputs: [{ name: '', type: 'bool', internalType: 'bool' }],
    stateMutability: 'pure'
  },
  { type: 'error', name: 'InvalidRecipient', inputs: [] }
]

export class NiftyswapExchange20Wrapper extends ContractFactory {
  constructor(signer: ethers.Signer) {
    super(
      abi,
      '0x608060405234801561001057600080fd5b50610f29806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806301ffc9a714610051578063b44d2a1214610079578063bc197c8114610099578063f23a6e61146100c5575b600080fd5b61006461005f3660046107fc565b6100d8565b60405190151581526020015b60405180910390f35b61008c610087366004610997565b61012a565b6040516100709190610ac6565b6100ac6100a7366004610b49565b610314565b6040516001600160e01b03199091168152602001610070565b6100ac6100d3366004610bf7565b6103ba565b60006001600160e01b03198216635a26950960e11b148061010957506001600160e01b03198216630271189760e51b145b8061012457506001600160e01b031982166301ffc9a760e01b145b92915050565b60606001600160a01b038416158061014957506001600160a01b038516155b1561016757604051634e46966960e11b815260040160405180910390fd5b60008a6001600160a01b03166346adf5ca6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101cb9190610c60565b90506101d98133308b610460565b6101e4818c8a6105a3565b600080546001600160a01b0319166001600160a01b0388811691909117909155604051636c9f455560e11b8152908c169063d93e8aaa90610235908d908d908d908d9030908c908c90600401610c7d565b6000604051808303816000875af1158015610254573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261027c9190810190610d23565b600080546001600160a01b03191681556040516370a0823160e01b8152306004820152919350906001600160a01b038316906370a0823190602401602060405180830381865afa1580156102d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102f89190610db4565b90506103058287836106d2565b50509998505050505050505050565b600080546001600160a01b031661033e57604051634e46966960e11b815260040160405180910390fd5b600054604051631759616b60e11b81523391632eb2c2d6916103769130916001600160a01b0390911690899089908990600401610e1d565b600060405180830381600087803b15801561039057600080fd5b505af11580156103a4573d6000803e3d6000fd5b5063bc197c8160e01b9998505050505050505050565b600080546001600160a01b03166103e457604051634e46966960e11b815260040160405180910390fd5b600054604051637921219560e11b8152339163f242432a9161041c9130916001600160a01b0390911690899089908990600401610e7b565b600060405180830381600087803b15801561043657600080fd5b505af115801561044a573d6000803e3d6000fd5b5063f23a6e6160e01b9998505050505050505050565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180516001600160e01b03166323b872dd60e01b17905291516000928392908816916104c49190610eb5565b6000604051808303816000865af19150503d8060008114610501576040519150601f19603f3d011682016040523d82523d6000602084013e610506565b606091505b50915091508180156105305750805115806105305750808060200190518101906105309190610ed1565b61059b5760405162461bcd60e51b815260206004820152603160248201527f5472616e7366657248656c7065723a3a7472616e7366657246726f6d3a207472604482015270185b9cd9995c919c9bdb4819985a5b1959607a1b60648201526084015b60405180910390fd5b505050505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663095ea7b360e01b17905291516000928392908716916105ff9190610eb5565b6000604051808303816000865af19150503d806000811461063c576040519150601f19603f3d011682016040523d82523d6000602084013e610641565b606091505b509150915081801561066b57508051158061066b57508080602001905181019061066b9190610ed1565b6106cb5760405162461bcd60e51b815260206004820152602b60248201527f5472616e7366657248656c7065723a3a73616665417070726f76653a2061707060448201526a1c9bdd994819985a5b195960aa1b6064820152608401610592565b5050505050565b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180516001600160e01b031663a9059cbb60e01b179052915160009283929087169161072e9190610eb5565b6000604051808303816000865af19150503d806000811461076b576040519150601f19603f3d011682016040523d82523d6000602084013e610770565b606091505b509150915081801561079a57508051158061079a57508080602001905181019061079a9190610ed1565b6106cb5760405162461bcd60e51b815260206004820152602d60248201527f5472616e7366657248656c7065723a3a736166655472616e736665723a20747260448201526c185b9cd9995c8819985a5b1959609a1b6064820152608401610592565b60006020828403121561080e57600080fd5b81356001600160e01b03198116811461082657600080fd5b9392505050565b6001600160a01b038116811461084257600080fd5b50565b80356108508161082d565b919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff8111828210171561089457610894610855565b604052919050565b600067ffffffffffffffff8211156108b6576108b6610855565b5060051b60200190565b600082601f8301126108d157600080fd5b813560206108e66108e18361089c565b61086b565b8083825260208201915060208460051b87010193508684111561090857600080fd5b602086015b84811015610924578035835291830191830161090d565b509695505050505050565b600082601f83011261094057600080fd5b813560206109506108e18361089c565b8083825260208201915060208460051b87010193508684111561097257600080fd5b602086015b8481101561092457803561098a8161082d565b8352918301918301610977565b60008060008060008060008060006101208a8c0312156109b657600080fd5b6109bf8a610845565b985060208a013567ffffffffffffffff808211156109dc57600080fd5b6109e88d838e016108c0565b995060408c01359150808211156109fe57600080fd5b610a0a8d838e016108c0565b985060608c0135975060808c01359650610a2660a08d01610845565b9550610a3460c08d01610845565b945060e08c0135915080821115610a4a57600080fd5b610a568d838e0161092f565b93506101008c0135915080821115610a6d57600080fd5b50610a7a8c828d016108c0565b9150509295985092959850929598565b60008151808452602080850194506020840160005b83811015610abb57815187529582019590820190600101610a9f565b509495945050505050565b6020815260006108266020830184610a8a565b600082601f830112610aea57600080fd5b813567ffffffffffffffff811115610b0457610b04610855565b610b17601f8201601f191660200161086b565b818152846020838601011115610b2c57600080fd5b816020850160208301376000918101602001919091529392505050565b600080600080600060a08688031215610b6157600080fd5b8535610b6c8161082d565b94506020860135610b7c8161082d565b9350604086013567ffffffffffffffff80821115610b9957600080fd5b610ba589838a016108c0565b94506060880135915080821115610bbb57600080fd5b610bc789838a016108c0565b93506080880135915080821115610bdd57600080fd5b50610bea88828901610ad9565b9150509295509295909350565b600080600080600060a08688031215610c0f57600080fd5b8535610c1a8161082d565b94506020860135610c2a8161082d565b93506040860135925060608601359150608086013567ffffffffffffffff811115610c5457600080fd5b610bea88828901610ad9565b600060208284031215610c7257600080fd5b81516108268161082d565b60e081526000610c9060e083018a610a8a565b60208382036020850152610ca4828b610a8a565b604085018a9052606085018990526001600160a01b03888116608087015285820360a087015287518083526020808a0195509192919091019060005b81811015610cfe578551841683529484019491840191600101610ce0565b505085810360c0870152610d128188610a8a565b9d9c50505050505050505050505050565b60006020808385031215610d3657600080fd5b825167ffffffffffffffff811115610d4d57600080fd5b8301601f81018513610d5e57600080fd5b8051610d6c6108e18261089c565b81815260059190911b82018301908381019087831115610d8b57600080fd5b928401925b82841015610da957835182529284019290840190610d90565b979650505050505050565b600060208284031215610dc657600080fd5b5051919050565b60005b83811015610de8578181015183820152602001610dd0565b50506000910152565b60008151808452610e09816020860160208601610dcd565b601f01601f19169290920160200192915050565b6001600160a01b0386811682528516602082015260a060408201819052600090610e4990830186610a8a565b8281036060840152610e5b8186610a8a565b90508281036080840152610e6f8185610df1565b98975050505050505050565b6001600160a01b03868116825285166020820152604081018490526060810183905260a060808201819052600090610da990830184610df1565b60008251610ec7818460208701610dcd565b9190910192915050565b600060208284031215610ee357600080fd5b8151801515811461082657600080fdfea2646970667358221220b101cadd481a84a3dbacfceca1c09f5a28a7c4e8c0ddcb7f53fb2068b10c066d64736f6c63430008160033',
      signer
    )
  }
}

export const NIFTYSWAP_EXCHANGE_20_WRAPPER_VERIFICATION: Omit<VerificationRequest, 'waitForSuccess'> = {
  contractToVerify: 'src/contracts/wrapper/NiftyswapExchange20Wrapper.sol:NiftyswapExchange20Wrapper',
  version: 'v0.8.22+commit.4fc1097e',
  licenceType: 'Apache-2.0',
  compilerInput: {
    language: 'Solidity',
    sources: {
      'src/contracts/wrapper/NiftyswapExchange20Wrapper.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.4;\r\n\r\nimport {INiftyswapExchange20Wrapper} from "../interfaces/INiftyswapExchange20Wrapper.sol";\r\nimport {INiftyswapExchange20} from "../interfaces/INiftyswapExchange20.sol";\r\nimport {IERC20} from "@0xsequence/erc-1155/contracts/interfaces/IERC20.sol";\r\nimport {IERC165} from "@0xsequence/erc-1155/contracts/interfaces/IERC165.sol";\r\nimport {IERC1155} from "@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol";\r\nimport {IERC1155TokenReceiver} from "@0xsequence/erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol";\r\nimport {TransferHelper} from "@uniswap/lib/contracts/libraries/TransferHelper.sol";\r\n\r\nerror InvalidRecipient();\r\n\r\n/**\r\n * A wrapper for the Niftyswap exchange contract that when swapping for ERC-1155\r\n * allows the ERC-20 refund to be sent to a recipient other than the token recipient.\r\n */\r\ncontract NiftyswapExchange20Wrapper is INiftyswapExchange20Wrapper, IERC1155TokenReceiver, IERC165 {\r\n    // onReceive function signatures\r\n    bytes4 internal constant ERC1155_RECEIVED_VALUE = 0xf23a6e61;\r\n    bytes4 internal constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\r\n\r\n    address private tokenRecipient;\r\n\r\n    /**\r\n     * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\r\n     * @dev User specifies MAXIMUM inputs (_maxCurrency) and EXACT outputs.\r\n     * @dev Assumes that all trades will be successful, or revert the whole tx.\r\n     * @dev Exceeding currency tokens sent will be refunded to the currency recipient.\r\n     * @dev Sorting IDs is mandatory for efficient way of preventing duplicated IDs (which would lead to exploit)\r\n     * @param _exchange20Address   Address of the NiftyswapExchange20 contract\r\n     * @param _tokenIds            Array of Tokens ID that are bought\r\n     * @param _tokensBoughtAmounts Amount of Tokens id bought for each corresponding Token id in _tokenIds\r\n     * @param _maxCurrency         Total maximum amount of currency tokens to spend for all Token ids\r\n     * @param _deadline            Timestamp after which this transaction will be reverted\r\n     * @param _tokenRecipient      The address that receives output Tokens\r\n     * @param _currencyRecipient   The address that receives the refund of currency tokens\r\n     * @param _extraFeeRecipients  Array of addresses that will receive extra fee\r\n     * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\r\n     * @return currencySold How much currency was actually sold.\r\n     */\r\n    function buyTokens(\r\n        address _exchange20Address,\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _tokensBoughtAmounts,\r\n        uint256 _maxCurrency,\r\n        uint256 _deadline,\r\n        address _tokenRecipient,\r\n        address _currencyRecipient,\r\n        address[] memory _extraFeeRecipients,\r\n        uint256[] memory _extraFeeAmounts\r\n    ) external override returns (uint256[] memory currencySold) {\r\n        if (_currencyRecipient == address(0) || _tokenRecipient == address(0)) {\r\n            revert InvalidRecipient();\r\n        }\r\n\r\n        // Obtain currency for Niftyswap\r\n        address currencyAddress = INiftyswapExchange20(_exchange20Address).getCurrencyInfo();\r\n        TransferHelper.safeTransferFrom(currencyAddress, msg.sender, address(this), _maxCurrency);\r\n        TransferHelper.safeApprove(currencyAddress, _exchange20Address, _maxCurrency);\r\n\r\n        // Store recipient for forwarding\r\n        tokenRecipient = _tokenRecipient;\r\n\r\n        // Call NiftyswapExchange20 contract\r\n        currencySold = INiftyswapExchange20(_exchange20Address).buyTokens(\r\n            _tokenIds,\r\n            _tokensBoughtAmounts,\r\n            _maxCurrency,\r\n            _deadline,\r\n            address(this), // _tokenRecipient\r\n            _extraFeeRecipients,\r\n            _extraFeeAmounts\r\n        );\r\n\r\n        // Clear recipient\r\n        delete tokenRecipient;\r\n\r\n        // Send currency refund to currency recipient\r\n        uint256 balance = IERC20(currencyAddress).balanceOf(address(this));\r\n        TransferHelper.safeTransfer(currencyAddress, _currencyRecipient, balance);\r\n    }\r\n\r\n    /**\r\n     * Receive ERC-1155 tokens and forward to token recipient.\r\n     * @param _ids      An array containing ids of each Token being transferred\r\n     * @param _amounts  An array containing amounts of each Token being transferred\r\n     * @param _data     Additional data to forward to recipient\r\n     * @return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address, // _operator,\r\n        address, // from\r\n        uint256[] memory _ids,\r\n        uint256[] memory _amounts,\r\n        bytes memory _data\r\n    ) public override returns (bytes4) {\r\n        if (tokenRecipient == address(0)) {\r\n            revert InvalidRecipient();\r\n        }\r\n        // Forward to token recipient\r\n        IERC1155(msg.sender).safeBatchTransferFrom(address(this), tokenRecipient, _ids, _amounts, _data);\r\n        return ERC1155_BATCH_RECEIVED_VALUE;\r\n    }\r\n\r\n    /**\r\n     * Receive ERC-1155 tokens and forward to token recipient.\r\n     * @param _id      Id of Token being transferred\r\n     * @param _amount  Amounts of Token being transferred\r\n     * @param _data     Additional data to forward to recipient\r\n     * @return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")\r\n     */\r\n    function onERC1155Received(address, address, uint256 _id, uint256 _amount, bytes memory _data)\r\n        public\r\n        override\r\n        returns (bytes4)\r\n    {\r\n        if (tokenRecipient == address(0)) {\r\n            revert InvalidRecipient();\r\n        }\r\n        // Forward to token recipient\r\n        IERC1155(msg.sender).safeTransferFrom(address(this), tokenRecipient, _id, _amount, _data);\r\n        return ERC1155_RECEIVED_VALUE;\r\n    }\r\n\r\n    /**\r\n     * @notice Indicates which interfaces the contract implements.\r\n     * @param  interfaceID The ERC-165 interface ID that is queried for support.\r\n     * @return Whether a given interface is supported\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure override returns (bool) {\r\n        return interfaceID == type(INiftyswapExchange20Wrapper).interfaceId\r\n            || interfaceID == type(IERC1155TokenReceiver).interfaceId || interfaceID == type(IERC165).interfaceId;\r\n    }\r\n}\r\n'
      },
      'src/contracts/interfaces/INiftyswapExchange20Wrapper.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.4;\r\n\r\ninterface INiftyswapExchange20Wrapper {\r\n    /**\r\n     * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\r\n     * @dev User specifies MAXIMUM inputs (_maxCurrency) and EXACT outputs.\r\n     * @dev Assumes that all trades will be successful, or revert the whole tx.\r\n     * @dev Exceeding currency tokens sent will be refunded to the currency recipient.\r\n     * @dev Sorting IDs is mandatory for efficient way of preventing duplicated IDs (which would lead to exploit)\r\n     * @param _exchange20Address   Address of the NiftyswapExchange20 contract\r\n     * @param _tokenIds            Array of Tokens ID that are bought\r\n     * @param _tokensBoughtAmounts Amount of Tokens id bought for each corresponding Token id in _tokenIds\r\n     * @param _maxCurrency         Total maximum amount of currency tokens to spend for all Token ids\r\n     * @param _deadline            Timestamp after which this transaction will be reverted\r\n     * @param _tokenRecipient      The address that receives output Tokens\r\n     * @param _currencyRecipient   The address that receives the refund of currency tokens\r\n     * @param _extraFeeRecipients  Array of addresses that will receive extra fee\r\n     * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\r\n     * @return currencySold How much currency was actually sold.\r\n     */\r\n    function buyTokens(\r\n        address _exchange20Address,\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _tokensBoughtAmounts,\r\n        uint256 _maxCurrency,\r\n        uint256 _deadline,\r\n        address _tokenRecipient,\r\n        address _currencyRecipient,\r\n        address[] memory _extraFeeRecipients,\r\n        uint256[] memory _extraFeeAmounts\r\n    ) external returns (uint256[] memory);\r\n}\r\n'
      },
      'src/contracts/interfaces/INiftyswapExchange20.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.4;\r\n\r\ninterface INiftyswapExchange20 {\r\n    event TokensPurchase(\r\n        address indexed buyer,\r\n        address indexed recipient,\r\n        uint256[] tokensBoughtIds,\r\n        uint256[] tokensBoughtAmounts,\r\n        uint256[] currencySoldAmounts,\r\n        address[] extraFeeRecipients,\r\n        uint256[] extraFeeAmounts\r\n    );\r\n\r\n    event CurrencyPurchase(\r\n        address indexed buyer,\r\n        address indexed recipient,\r\n        uint256[] tokensSoldIds,\r\n        uint256[] tokensSoldAmounts,\r\n        uint256[] currencyBoughtAmounts,\r\n        address[] extraFeeRecipients,\r\n        uint256[] extraFeeAmounts\r\n    );\r\n\r\n    event LiquidityAdded(\r\n        address indexed provider, uint256[] tokenIds, uint256[] tokenAmounts, uint256[] currencyAmounts\r\n    );\r\n\r\n    struct LiquidityRemovedEventObj {\r\n        uint256 currencyAmount;\r\n        uint256 soldTokenNumerator;\r\n        uint256 boughtCurrencyNumerator;\r\n        uint256 totalSupply;\r\n    }\r\n\r\n    event LiquidityRemoved(\r\n        address indexed provider, uint256[] tokenIds, uint256[] tokenAmounts, LiquidityRemovedEventObj[] details\r\n    );\r\n\r\n    event RoyaltyChanged(address indexed royaltyRecipient, uint256 royaltyFee);\r\n\r\n    struct SellTokensObj {\r\n        address recipient; // Who receives the currency\r\n        uint256 minCurrency; // Total minimum number of currency  expected for all tokens sold\r\n        address[] extraFeeRecipients; // Array of addresses that will receive extra fee\r\n        uint256[] extraFeeAmounts; // Array of amounts of currency that will be sent as extra fee\r\n        uint256 deadline; // Timestamp after which the tx isn\'t valid anymore\r\n    }\r\n\r\n    struct AddLiquidityObj {\r\n        uint256[] maxCurrency; // Maximum number of currency to deposit with tokens\r\n        uint256 deadline; // Timestamp after which the tx isn\'t valid anymore\r\n    }\r\n\r\n    struct RemoveLiquidityObj {\r\n        uint256[] minCurrency; // Minimum number of currency to withdraw\r\n        uint256[] minTokens; // Minimum number of tokens to withdraw\r\n        uint256 deadline; // Timestamp after which the tx isn\'t valid anymore\r\n    }\r\n\r\n    //\r\n    // Purchasing Functions\r\n    //\r\n\r\n    /**\r\n     * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\r\n     * @dev User specifies MAXIMUM inputs (_maxCurrency) and EXACT outputs.\r\n     * @dev Assumes that all trades will be successful, or revert the whole tx\r\n     * @dev Exceeding currency tokens sent will be refunded to recipient\r\n     * @dev Sorting IDs is mandatory for efficient way of preventing duplicated IDs (which would lead to exploit)\r\n     * @param _tokenIds            Array of Tokens ID that are bought\r\n     * @param _tokensBoughtAmounts Amount of Tokens id bought for each corresponding Token id in _tokenIds\r\n     * @param _maxCurrency         Total maximum amount of currency tokens to spend for all Token ids\r\n     * @param _deadline            Timestamp after which this transaction will be reverted\r\n     * @param _recipient           The address that receives output Tokens and refund\r\n     * @param _extraFeeRecipients  Array of addresses that will receive extra fee\r\n     * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\r\n     * @return currencySold How much currency was actually sold.\r\n     */\r\n    function buyTokens(\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _tokensBoughtAmounts,\r\n        uint256 _maxCurrency,\r\n        uint256 _deadline,\r\n        address _recipient,\r\n        address[] memory _extraFeeRecipients,\r\n        uint256[] memory _extraFeeAmounts\r\n    ) external returns (uint256[] memory);\r\n\r\n    //\r\n    // Royalties Functions\r\n    //\r\n\r\n    /**\r\n     * @notice Will send the royalties that _royaltyRecipient can claim, if any\r\n     * @dev Anyone can call this function such that payout could be distributed\r\n     * regularly instead of being claimed.\r\n     * @param _royaltyRecipient Address that is able to claim royalties\r\n     */\r\n    function sendRoyalties(address _royaltyRecipient) external;\r\n\r\n    //\r\n    // OnReceive Functions\r\n    //\r\n\r\n    /**\r\n     * @notice Handle which method is being called on Token transfer\r\n     * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\r\n     * where bytes4 argument is the MethodObj object signature passed as defined\r\n     * in the `Signatures for onReceive control logic` section above\r\n     * @param _operator The address which called the `safeTransferFrom` function\r\n     * @param _from     The address which previously owned the token\r\n     * @param _id       The id of the token being transferred\r\n     * @param _amount   The amount of tokens being transferred\r\n     * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\r\n     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\r\n     */\r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data)\r\n        external\r\n        returns (bytes4);\r\n\r\n    /**\r\n     * @notice Handle which method is being called on transfer\r\n     * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\r\n     * where bytes4 argument is the MethodObj object signature passed as defined\r\n     * in the `Signatures for onReceive control logic` section above\r\n     * @param _from     The address which previously owned the Token\r\n     * @param _ids      An array containing ids of each Token being transferred\r\n     * @param _amounts  An array containing amounts of each Token being transferred\r\n     * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\r\n     * @return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address _from,\r\n        uint256[] calldata _ids,\r\n        uint256[] calldata _amounts,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n\r\n    //\r\n    // Getter Functions\r\n    //\r\n\r\n    /**\r\n     * @dev Pricing function used for converting between currency token to Tokens.\r\n     * @param _assetBoughtAmount  Amount of Tokens being bought.\r\n     * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\r\n     * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\r\n     * @return Amount of currency tokens to send to Niftyswap.\r\n     */\r\n    function getBuyPrice(uint256 _assetBoughtAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\r\n     * @param _tokenId            Id ot token being sold\r\n     * @param _assetBoughtAmount  Amount of Tokens being bought.\r\n     * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\r\n     * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\r\n     * @return price Amount of currency tokens to send to Niftyswap.\r\n     */\r\n    function getBuyPriceWithRoyalty(\r\n        uint256 _tokenId,\r\n        uint256 _assetBoughtAmount,\r\n        uint256 _assetSoldReserve,\r\n        uint256 _assetBoughtReserve\r\n    ) external view returns (uint256 price);\r\n\r\n    /**\r\n     * @dev Pricing function used for converting Tokens to currency token.\r\n     * @param _assetSoldAmount    Amount of Tokens being sold.\r\n     * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\r\n     * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\r\n     * @return Amount of currency tokens to receive from Niftyswap.\r\n     */\r\n    function getSellPrice(uint256 _assetSoldAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\r\n     * @param _tokenId            Id ot token being sold\r\n     * @param _assetSoldAmount    Amount of Tokens being sold.\r\n     * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\r\n     * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\r\n     * @return price Amount of currency tokens to receive from Niftyswap.\r\n     */\r\n    function getSellPriceWithRoyalty(\r\n        uint256 _tokenId,\r\n        uint256 _assetSoldAmount,\r\n        uint256 _assetSoldReserve,\r\n        uint256 _assetBoughtReserve\r\n    ) external view returns (uint256 price);\r\n\r\n    /**\r\n     * @notice Get amount of currency in reserve for each Token _id in _ids\r\n     * @param _ids Array of ID sto query currency reserve of\r\n     * @return amount of currency in reserve for each Token _id\r\n     */\r\n    function getCurrencyReserves(uint256[] calldata _ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @notice Return price for `currency => Token _id` trades with an exact token amount.\r\n     * @param _ids          Array of ID of tokens bought.\r\n     * @param _tokensBought Amount of Tokens bought.\r\n     * @return Amount of currency needed to buy Tokens in _ids for amounts in _tokensBought\r\n     */\r\n    function getPrice_currencyToToken(uint256[] calldata _ids, uint256[] calldata _tokensBought)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @notice Return price for `Token _id => currency` trades with an exact token amount.\r\n     * @param _ids        Array of IDs  token sold.\r\n     * @param _tokensSold Array of amount of each Token sold.\r\n     * @return Amount of currency that can be bought for Tokens in _ids for amounts in _tokensSold\r\n     */\r\n    function getPrice_tokenToCurrency(uint256[] calldata _ids, uint256[] calldata _tokensSold)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @notice Get total supply of liquidity tokens\r\n     * @param _ids ID of the Tokens\r\n     * @return The total supply of each liquidity token id provided in _ids\r\n     */\r\n    function getTotalSupply(uint256[] calldata _ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @return Address of Token that is sold on this exchange.\r\n     */\r\n    function getTokenAddress() external view returns (address);\r\n\r\n    /**\r\n     * @return LP fee per 1000 units\r\n     */\r\n    function getLPFee() external view returns (uint256);\r\n\r\n    /**\r\n     * @return Address of the currency contract that is used as currency\r\n     */\r\n    function getCurrencyInfo() external view returns (address);\r\n\r\n    /**\r\n     * @return Address of factory that created this exchange.\r\n     */\r\n    function getFactoryAddress() external view returns (address);\r\n\r\n    /**\r\n     * @return Global royalty fee % if not supporting ERC-2981\r\n     */\r\n    function getGlobalRoyaltyFee() external view returns (uint256);\r\n\r\n    /**\r\n     * @return Global royalty recipient if token not supporting ERC-2981\r\n     */\r\n    function getGlobalRoyaltyRecipient() external view returns (address);\r\n\r\n    /**\r\n     * @return Get amount of currency in royalty an address can claim\r\n     * @param _royaltyRecipient Address to check the claimable royalties\r\n     */\r\n    function getRoyalties(address _royaltyRecipient) external view returns (uint256);\r\n\r\n    function getRoyaltiesNumerator(address _royaltyRecipient) external view returns (uint256);\r\n}\r\n'
      },
      'node_modules/@0xsequence/erc-1155/contracts/interfaces/IERC20.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n'
      },
      'node_modules/@0xsequence/erc-1155/contracts/interfaces/IERC165.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas\n     * @param _interfaceId The interface identifier, as specified in ERC-165\n     */\n    function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool);\n}\n'
      },
      'node_modules/@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\nimport \'./IERC165.sol\';\n\n\ninterface IERC1155 is IERC165 {\n\n  /****************************************|\n  |                 Events                 |\n  |_______________________________________*/\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n\n  /**\n   * @dev MUST emit when an approval is updated\n   */\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\n  /****************************************|\n  |                Functions               |\n  |_______________________________________*/\n\n  /**\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\n    * @dev MUST emit TransferSingle event on success\n    * Caller must be approved to manage the _from account\'s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n    * @param _from    Source address\n    * @param _to      Target address\n    * @param _id      ID of the token type\n    * @param _amount  Transfered amount\n    * @param _data    Additional data with no specified format, sent in call to `_to`\n    */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n  /**\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    * @dev MUST emit TransferBatch event on success\n    * Caller must be approved to manage the _from account\'s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n    * @param _from     Source addresses\n    * @param _to       Target addresses\n    * @param _ids      IDs of each token type\n    * @param _amounts  Transfer amounts per token type\n    * @param _data     Additional data with no specified format, sent in call to `_to`\n  */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n\n  /**\n   * @notice Get the balance of an account\'s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return        The _owner\'s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders\n   * @param _ids    ID of the Tokens\n   * @return        The _owner\'s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n   */\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n   * @dev MUST emit the ApprovalForAll event on success\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /**\n   * @notice Queries the approval status of an operator for a given owner\n   * @param _owner     The owner of the Tokens\n   * @param _operator  Address of authorized operator\n   * @return isOperator True if the operator is approved, false if not\n   */\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n}\n'
      },
      'node_modules/@0xsequence/erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1155 interface for accepting safe transfers.\n */\ninterface IERC1155TokenReceiver {\n\n  /**\n   * @notice Handle the receipt of a single ERC1155 token type\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value MUST result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _id        The id of the token being transferred\n   * @param _amount    The amount of tokens being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Handle the receipt of multiple ERC1155 token types\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value WILL result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _ids       An array containing ids of each token being transferred\n   * @param _amounts   An array containing amounts of each token being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n   */\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n}\n'
      },
      'node_modules/@uniswap/lib/contracts/libraries/TransferHelper.sol': {
        content:
          "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
      }
    },
    settings: {
      remappings: [
        'ds-test/=lib/forge-std/lib/ds-test/src/',
        'forge-std/=lib/forge-std/src/',
        '@0xsequence/erc20-meta-token/=node_modules/@0xsequence/erc20-meta-token/',
        '@0xsequence/erc-1155/=node_modules/@0xsequence/erc-1155/',
        '@uniswap/lib/=node_modules/@uniswap/lib/',
        'eth-gas-reporter/=node_modules/eth-gas-reporter/',
        'hardhat-deploy/=node_modules/hardhat-deploy/',
        'hardhat/=node_modules/hardhat/'
      ],
      optimizer: {
        enabled: true,
        runs: 200
      },
      metadata: {
        useLiteralContent: false,
        bytecodeHash: 'ipfs',
        appendCBOR: true
      },
      outputSelection: {
        '*': {
          '*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']
        }
      },
      evmVersion: 'paris',
      libraries: {}
    }
  }
}
