import { ContractFactory, type ethers } from 'ethers'
import type { VerificationRequest } from 'scripts/types'

const abi = [
  {
    inputs: [
      {
        internalType: 'address',
        name: 'target',
        type: 'address'
      }
    ],
    name: 'BlacklistedAddress',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidAttestation',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidBlacklist',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidCallsLength',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: 'invalidChainId',
        type: 'uint256'
      }
    ],
    name: 'InvalidChainId',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidDelegateCall',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidIdentitySigner',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidImplicitResult',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidLimitUsageIncrement',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: 'flag',
        type: 'uint256'
      }
    ],
    name: 'InvalidNodeType',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidPayloadKind',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidPermission',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidSelfCall',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'invalidSigner',
        type: 'address'
      }
    ],
    name: 'InvalidSessionSigner',
    type: 'error'
  },
  {
    inputs: [],
    name: 'InvalidValue',
    type: 'error'
  },
  {
    inputs: [],
    name: 'MissingPermission',
    type: 'error'
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: 'deadline',
        type: 'uint256'
      }
    ],
    name: 'SessionExpired',
    type: 'error'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: 'address',
        name: 'wallet',
        type: 'address'
      },
      {
        indexed: false,
        internalType: 'bytes32',
        name: 'usageHash',
        type: 'bytes32'
      },
      {
        indexed: false,
        internalType: 'uint256',
        name: 'usageAmount',
        type: 'uint256'
      }
    ],
    name: 'LimitUsageUpdated',
    type: 'event'
  },
  {
    inputs: [],
    name: 'VALUE_TRACKING_ADDRESS',
    outputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'wallet',
        type: 'address'
      },
      {
        internalType: 'bytes32',
        name: 'usageHash',
        type: 'bytes32'
      }
    ],
    name: 'getLimitUsage',
    outputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: 'bytes32',
            name: 'usageHash',
            type: 'bytes32'
          },
          {
            internalType: 'uint256',
            name: 'usageAmount',
            type: 'uint256'
          }
        ],
        internalType: 'struct UsageLimit[]',
        name: 'limits',
        type: 'tuple[]'
      }
    ],
    name: 'incrementUsageLimit',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: 'uint8',
            name: 'kind',
            type: 'uint8'
          },
          {
            internalType: 'bool',
            name: 'noChainId',
            type: 'bool'
          },
          {
            components: [
              {
                internalType: 'address',
                name: 'to',
                type: 'address'
              },
              {
                internalType: 'uint256',
                name: 'value',
                type: 'uint256'
              },
              {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes'
              },
              {
                internalType: 'uint256',
                name: 'gasLimit',
                type: 'uint256'
              },
              {
                internalType: 'bool',
                name: 'delegateCall',
                type: 'bool'
              },
              {
                internalType: 'bool',
                name: 'onlyFallback',
                type: 'bool'
              },
              {
                internalType: 'uint256',
                name: 'behaviorOnError',
                type: 'uint256'
              }
            ],
            internalType: 'struct Payload.Call[]',
            name: 'calls',
            type: 'tuple[]'
          },
          {
            internalType: 'uint256',
            name: 'space',
            type: 'uint256'
          },
          {
            internalType: 'uint256',
            name: 'nonce',
            type: 'uint256'
          },
          {
            internalType: 'bytes',
            name: 'message',
            type: 'bytes'
          },
          {
            internalType: 'bytes32',
            name: 'imageHash',
            type: 'bytes32'
          },
          {
            internalType: 'bytes32',
            name: 'digest',
            type: 'bytes32'
          },
          {
            internalType: 'address[]',
            name: 'parentWallets',
            type: 'address[]'
          }
        ],
        internalType: 'struct Payload.Decoded',
        name: 'payload',
        type: 'tuple'
      },
      {
        internalType: 'bytes',
        name: 'encodedSignature',
        type: 'bytes'
      }
    ],
    name: 'recoverSapientSignature',
    outputs: [
      {
        internalType: 'bytes32',
        name: '',
        type: 'bytes32'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: 'address',
            name: 'target',
            type: 'address'
          },
          {
            components: [
              {
                internalType: 'bool',
                name: 'cumulative',
                type: 'bool'
              },
              {
                internalType: 'enum ParameterOperation',
                name: 'operation',
                type: 'uint8'
              },
              {
                internalType: 'bytes32',
                name: 'value',
                type: 'bytes32'
              },
              {
                internalType: 'uint256',
                name: 'offset',
                type: 'uint256'
              },
              {
                internalType: 'bytes32',
                name: 'mask',
                type: 'bytes32'
              }
            ],
            internalType: 'struct ParameterRule[]',
            name: 'rules',
            type: 'tuple[]'
          }
        ],
        internalType: 'struct Permission',
        name: 'permission',
        type: 'tuple'
      },
      {
        components: [
          {
            internalType: 'address',
            name: 'to',
            type: 'address'
          },
          {
            internalType: 'uint256',
            name: 'value',
            type: 'uint256'
          },
          {
            internalType: 'bytes',
            name: 'data',
            type: 'bytes'
          },
          {
            internalType: 'uint256',
            name: 'gasLimit',
            type: 'uint256'
          },
          {
            internalType: 'bool',
            name: 'delegateCall',
            type: 'bool'
          },
          {
            internalType: 'bool',
            name: 'onlyFallback',
            type: 'bool'
          },
          {
            internalType: 'uint256',
            name: 'behaviorOnError',
            type: 'uint256'
          }
        ],
        internalType: 'struct Payload.Call',
        name: 'call',
        type: 'tuple'
      },
      {
        internalType: 'address',
        name: 'wallet',
        type: 'address'
      },
      {
        internalType: 'address',
        name: 'signer',
        type: 'address'
      },
      {
        components: [
          {
            internalType: 'bytes32',
            name: 'usageHash',
            type: 'bytes32'
          },
          {
            internalType: 'uint256',
            name: 'usageAmount',
            type: 'uint256'
          }
        ],
        internalType: 'struct UsageLimit[]',
        name: 'usageLimits',
        type: 'tuple[]'
      }
    ],
    name: 'validatePermission',
    outputs: [
      {
        internalType: 'bool',
        name: '',
        type: 'bool'
      },
      {
        components: [
          {
            internalType: 'bytes32',
            name: 'usageHash',
            type: 'bytes32'
          },
          {
            internalType: 'uint256',
            name: 'usageAmount',
            type: 'uint256'
          }
        ],
        internalType: 'struct UsageLimit[]',
        name: 'newUsageLimits',
        type: 'tuple[]'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  }
]

export class SessionManager extends ContractFactory {
  constructor(signer: ethers.Signer) {
    super(
      abi,
      '6080604052348015600e575f5ffd5b50614e068061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610055575f3560e01c806313792a4a1461005957806323b3713e14610089578063313dade7146100b957806342de1418146100ea578063f916f3b214610106575b5f5ffd5b610073600480360381019061006e9190613382565b610124565b6040516100809190613413565b60405180910390f35b6100a3600480360381019061009e91906134b0565b6106cb565b6040516100b09190613506565b60405180910390f35b6100d360048036038101906100ce919061390e565b610720565b6040516100e1929190613adb565b60405180910390f35b61010460048036038101906100ff9190613b5e565b610b59565b005b61010e610c3b565b60405161011b9190613bb8565b60405180910390f35b5f5f60ff16845f01602081019061013b9190613c07565b60ff1614610175576040517f7205212000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f8480604001906101869190613c3e565b9050036101bf576040517f542f0af500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f6101cb858585610c53565b90505f3390505f8680604001906101e29190613c3e565b905067ffffffffffffffff8111156101fd576101fc613533565b5b60405190808252806020026020018201604052801561023657816020015b6102236130cf565b81526020019060019003908161021b5790505b5090505f5f90505b87806040019061024e9190613c3e565b905081101561054b57368880604001906102689190613c3e565b8381811061027957610278613ca0565b5b905060200281019061028b9190613ccd565b90508060800160208101906102a09190613cf4565b156102d7576040517faa25f2ad00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f856080015183815181106102ef576102ee613ca0565b5b60200260200101519050805f0151156103205761031b8286836020015184606001518a6040015161121e565b61053c565b6103286130cf565b5f5f90505b85518110156104fd575f73ffffffffffffffffffffffffffffffffffffffff168682815181106103605761035f613ca0565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff160361047a578260200151825f019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505f67ffffffffffffffff8111156103db576103da613533565b5b60405190808252806020026020018201604052801561041457816020015b610401613104565b8152602001906001900390816103f95790505b5082602001819052505f836020015173eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee604051602001610449929190613d1f565b60405160208183030381529060405280519060200120905061046b88826106cb565b836040018181525050506104fd565b826020015173ffffffffffffffffffffffffffffffffffffffff168682815181106104a8576104a7613ca0565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff16036104f0578581815181106104e1576104e0613ca0565b5b602002602001015191506104fd565b808060010191505061032d565b6105188c868986602001518c606001518860400151886114bb565b91508186828151811061052e5761052d613ca0565b5b602002602001018190525050505b5050808060010191505061023e565b505f815167ffffffffffffffff81111561056857610567613533565b5b6040519080825280602002602001820160405280156105a157816020015b61058e6130cf565b8152602001906001900390816105865790505b5090505f5f5f90505b8351811015610657575f8482815181106105c7576105c6613ca0565b5b6020026020010151602001515111806105fd57505f8482815181106105ef576105ee613ca0565b5b602002602001015160400151115b1561064a5783818151811061061557610614613ca0565b5b60200260200101518383815181106106305761062f613ca0565b5b6020026020010181905250818061064690613d73565b9250505b80806001019150506105aa565b508082523689806040019061066c9190613c3e565b60018c806040019061067e9190613c3e565b905061068a9190613dba565b81811061069a57610699613ca0565b5b90506020028101906106ac9190613ccd565b90506106b88184611964565b505050825f015193505050509392505050565b5f5f5f8473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8381526020019081526020015f2054905092915050565b5f6060855f0160208101906107359190613ded565b73ffffffffffffffffffffffffffffffffffffffff16875f015173ffffffffffffffffffffffffffffffffffffffff1614610775575f8391509150610b4f565b86602001515183516107879190613e18565b67ffffffffffffffff8111156107a05761079f613533565b5b6040519080825280602002602001820160405280156107d957816020015b6107c6613104565b8152602001906001900390816107be5790505b5090505f5f90505b8351811015610830578381815181106107fd576107fc613ca0565b5b602002602001015182828151811061081857610817613ca0565b5b602002602001018190525080806001019150506107e1565b505f835190505f5f90505b886020015151811015610b45575f896020015182815181106108605761085f613ca0565b5b602002602001015190505f61089282606001518b80604001906108839190613e4b565b611d5a9290919263ffffffff16565b509050816080015181169050815f0151156109f3575f815f1c90505f898d866040516020016108c393929190614086565b6040516020818303038152906040528051906020012090505f6108e4613104565b5f5f90505b89518110156109bc575f5f1b8a828151811061090857610907613ca0565b5b60200260200101515f0151036109625760405180604001604052808581526020015f8152509150818a828151811061094357610942613ca0565b5b602002602001018190525060018161095b9190613e18565b98506109bc565b838a828151811061097657610975613ca0565b5b60200260200101515f0151036109af5789818151811061099957610998613ca0565b5b60200260200101519150816020015192506109bc565b80806001019150506108e9565b505f82036109d1576109ce8d846106cb565b91505b81846109dd9190613e18565b935083816020018181525050835f1b9450505050505b5f6003811115610a0657610a05613ef4565b5b82602001516003811115610a1d57610a1c613ef4565b5b03610a415781604001518114610a3c575f879550955050505050610b4f565b610b36565b600380811115610a5457610a53613ef4565b5b82602001516003811115610a6b57610a6a613ef4565b5b03610a945781604001515f1c815f1c1115610a8f575f879550955050505050610b4f565b610b35565b60016003811115610aa857610aa7613ef4565b5b82602001516003811115610abf57610abe613ef4565b5b03610ae35781604001518103610ade575f879550955050505050610b4f565b610b34565b60026003811115610af757610af6613ef4565b5b82602001516003811115610b0e57610b0d613ef4565b5b03610b335781604001515f1c815f1c1015610b32575f879550955050505050610b4f565b5b5b5b5b5050808060010191505061083b565b5080825260019250505b9550959350505050565b5f3390505f5f90505b83839050811015610c3557610b9282858584818110610b8457610b83613ca0565b5b9050604002015f01356106cb565b848483818110610ba557610ba4613ca0565b5b905060400201602001351015610be6576040517e2a700a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610c2882858584818110610bfd57610bfc613ca0565b5b9050604002015f0135868685818110610c1957610c18613ca0565b5b90506040020160200135611d70565b8080600101915050610b62565b50505050565b73eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee81565b610c5b61311c565b5f5f90505f5f610c76838787611e009290919263ffffffff16565b8162ffffff1691508094508192505050610cab868685908487610c999190613e18565b92610ca6939291906140ca565b611e1b565b80935081955050508083610cbf9190613e18565b92505f73ffffffffffffffffffffffffffffffffffffffff16846020015173ffffffffffffffffffffffffffffffffffffffff1603610d2a576040517f9e5c658b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5060605f610d438488886125c39290919263ffffffff16565b80955081925050508060ff1667ffffffffffffffff811115610d6857610d67613533565b5b604051908082528060200260200182016040528015610da157816020015b610d8e61315f565b815260200190600190039081610d865790505b5091505f5f90505b8160ff16811015610eed57610dbc61315f565b610dc78989886125de565b80975081925050505f5f5f610de7898d8d6127969290919263ffffffff16565b809c50819450829550839650505050505f610e01856127f9565b90505f6001828487876040515f8152602001604052604051610e269493929190614113565b6020604051602081039080840390855afa158015610e46573d5f5f3e3d5ffd5b5050506020604051035190508b6020015173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610ebb576040517f9e5c658b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050505080848381518110610ed457610ed3613ca0565b5b6020026020010181905250508080600101915050610da9565b505f8160ff16118015610efe575082155b15610f35576040517feb62520400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505f878060400190610f479190613c3e565b905090508067ffffffffffffffff811115610f6557610f64613533565b5b604051908082528060200260200182016040528015610f9e57816020015b610f8b6131cc565b815260200190600190039081610f835790505b5085608001819052505f5f90505b8181101561121257610fbc6131cc565b5f610fd2878b8b6125c39290919263ffffffff16565b80985081925050505f6080821660ff161415825f019015159081151581525050815f01511561106b575f607f8216905085518160ff161061103f576040517fbd8ba84d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b858160ff168151811061105557611054613ca0565b5b602002602001015183606001819052505061107e565b80826040019060ff16908160ff16815250505b505f5f5f611097898d8d6127969290919263ffffffff16565b809c50819450829550839650505050505f6110e48e80604001906110bb9190613c3e565b888181106110cc576110cb613ca0565b5b90506020028101906110de9190613ccd565b8f612811565b90506001818386866040515f81526020016040526040516111089493929190614113565b6020604051602081039080840390855afa158015611128573d5f5f3e3d5ffd5b50505060206040510351856020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505f73ffffffffffffffffffffffffffffffffffffffff16856020015173ffffffffffffffffffffffffffffffffffffffff16036111dd575f6040517fc1e84ed60000000000000000000000000000000000000000000000000000000081526004016111d49190613bb8565b60405180910390fd5b5050505080876080015183815181106111f9576111f8613ca0565b5b6020026020010181905250508080600101915050610fac565b50505050509392505050565b815f015173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161461129157826040517fc1e84ed60000000000000000000000000000000000000000000000000000000081526004016112889190613bb8565b60405180910390fd5b8460800160208101906112a49190613cf4565b156112db576040517faa25f2ad00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6112e5838261287e565b1561132757826040517fd33f19e700000000000000000000000000000000000000000000000000000000815260040161131e9190613bb8565b60405180910390fd5b611342855f01602081019061133c9190613ded565b8261287e565b1561139557845f0160208101906113599190613ded565b6040517fd33f19e700000000000000000000000000000000000000000000000000000000815260040161138c9190613bb8565b60405180910390fd5b5f856020013511156113d3576040517faa7feadc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f855f0160208101906113e69190613ded565b73ffffffffffffffffffffffffffffffffffffffff16639d043a668685896040518463ffffffff1660e01b8152600401611422939291906144e8565b602060405180830381865afa15801561143d573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611461919061453f565b90505f611477868561298b90919063ffffffff16565b90508082146114b2576040517f0881ad5d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50505050505050565b6114c36130cf565b6114cb613212565b5f5f90505b8551811015611558578673ffffffffffffffffffffffffffffffffffffffff1686828151811061150357611502613ca0565b5b60200260200101515f015173ffffffffffffffffffffffffffffffffffffffff160361154b5785818151811061153c5761153b613ca0565b5b60200260200101519150611558565b80806001019150506114d0565b505f73ffffffffffffffffffffffffffffffffffffffff16815f015173ffffffffffffffffffffffffffffffffffffffff16036115cc57856040517fc1e84ed60000000000000000000000000000000000000000000000000000000081526004016115c39190613bb8565b60405180910390fd5b5f8160200151141580156115e4575046816020015114155b1561162a5780602001516040517f331003b30000000000000000000000000000000000000000000000000000000081526004016116219190613506565b60405180910390fd5b5f816060015167ffffffffffffffff16141580156116555750806060015167ffffffffffffffff1642115b1561169b5780606001516040517fb1bbfdd500000000000000000000000000000000000000000000000000000000815260040161169291906145a3565b60405180910390fd5b368980604001906116ac9190613c3e565b8a8181106116bd576116bc613ca0565b5b90506020028101906116cf9190613ccd565b90508060800160208101906116e49190613cf4565b1561171b576040517faa25f2ad00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3073ffffffffffffffffffffffffffffffffffffffff16815f0160208101906117449190613ded565b73ffffffffffffffffffffffffffffffffffffffff1603611827575f8180604001906117709190613e4b565b5f90600492611781939291906140ca565b9061178c91906145d2565b90505f826020013511806117e557506342de141860e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614155b1561181c576040517f540733ea00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b849350505050611959565b8160800151518560ff1610611868576040517f3f904dc000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f82608001518660ff168151811061188357611882613ca0565b5b602002602001015190505f5f6118a083858d8d8b60200151610720565b91509150816118db576040517f868a64de00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8087602001819052505f8460200135111561190e578360200135876040018181516119069190613e18565b915081815250505b846040015187604001511115611950576040517faa7feadc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b86955050505050505b979650505050505050565b5f81511115611d56573073ffffffffffffffffffffffffffffffffffffffff16825f0160208101906119969190613ded565b73ffffffffffffffffffffffffffffffffffffffff161415806119c15750600160ff168260c0013514155b156119f7576040517e2a700a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5f5f90505f5f90505b8251811015611a7857828181518110611a1c57611a1b613ca0565b5b6020026020010151602001515182611a349190613e18565b91505f838281518110611a4a57611a49613ca0565b5b6020026020010151604001511115611a6b578180611a6790613d73565b9250505b8080600101915050611a00565b505f8167ffffffffffffffff811115611a9457611a93613533565b5b604051908082528060200260200182016040528015611acd57816020015b611aba613104565b815260200190600190039081611ab25790505b5090505f5f90505f5f90505b8451811015611c69575f5f90505b858281518110611afa57611af9613ca0565b5b60200260200101516020015151811015611b7e57858281518110611b2157611b20613ca0565b5b6020026020010151602001518181518110611b3f57611b3e613ca0565b5b6020026020010151848480611b5390613d73565b955081518110611b6657611b65613ca0565b5b60200260200101819052508080600101915050611ae7565b505f858281518110611b9357611b92613ca0565b5b6020026020010151604001511115611c5c576040518060400160405280868381518110611bc357611bc2613ca0565b5b60200260200101515f015173eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee604051602001611bf4929190613d1f565b604051602081830303815290604052805190602001208152602001868381518110611c2257611c21613ca0565b5b602002602001015160400151815250838380611c3d90613d73565b945081518110611c5057611c4f613ca0565b5b60200260200101819052505b8080600101915050611ad9565b505f6342de141860e01b83604051602401611c849190614630565b604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff838183161783525050505090505f818051906020012090505f878060400190611cff9190613e4b565b604051611d0d92919061467e565b60405180910390209050818114611d4f576040517e2a700a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050505b5050565b5f5f848301359150602083019050935093915050565b805f5f8573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020015f205f8481526020019081526020015f20819055507f42063b8d32ac0a88f94053143bb30a789b3d5dfabb27d6c8a54e23d4fef30851838383604051611df393929190614696565b60405180910390a1505050565b5f5f848301358060e81c925060038401915050935093915050565b611e2361311c565b5f5f5f5f603e87879050611e3791906146f8565b90508067ffffffffffffffff811115611e5357611e52613533565b5b604051908082528060200260200182016040528015611e8c57816020015b611e79613212565b815260200190600190039081611e715790505b508560600181905250505b858590508210156125ae575f611eb88388886125c39290919263ffffffff16565b8160ff16915080945081925050505f600460f08316901c90505f810361204057611ee0613212565b5f859050611ef9868b8b6129ed9290919263ffffffff16565b835f018198508273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152505050611f46868b8b612a1e9290919263ffffffff16565b83602001819850828152505050611f68868b8b612a1e9290919263ffffffff16565b83604001819850828152505050611f8a868b8b612a349290919263ffffffff16565b836060018198508267ffffffffffffffff1667ffffffffffffffff168152505050611fb68a8a88612a4f565b8360800181985082905250505f611fdd8b8b84908a92611fd8939291906140ca565b612b23565b90505f5f1b895f015103611ff15780611fff565b611ffe895f015182612b57565b5b895f01818152505050818860600151868061201990613d73565b97508151811061202c5761202b613ca0565b5b602002602001018190525050505050611e97565b60018103612096575f61205e858a8a611d5a9290919263ffffffff16565b80965081925050505f5f1b875f0151036120785780612086565b612085875f015182612b57565b5b875f018181525050505050611e97565b600281036122d3575f5f600f841660ff1690506120c586828c8c612b6b9190939291909392919063ffffffff16565b8097508193505050505f81866120db9190613e18565b90505f5f6120f98c8c8a9086926120f4939291906140ca565b611e1b565b91509150829750801561215057881561213e576040517feb62520400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001985081604001518a604001819052505b5f73ffffffffffffffffffffffffffffffffffffffff16826020015173ffffffffffffffffffffffffffffffffffffffff161461222d575f73ffffffffffffffffffffffffffffffffffffffff168a6020015173ffffffffffffffffffffffffffffffffffffffff16146121f0576040517f9e5c658b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81602001518a6020019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250505b5f5f90505b826060015151811015612299578260600151818151811061225657612255613ca0565b5b60200260200101518b60600151898061226e90613d73565b9a508151811061228157612280613ca0565b5b60200260200101819052508080600101915050612232565b505f5f1b8a5f0151036122af57815f01516122c0565b6122bf8a5f0151835f0151612b57565b5b8a5f018181525050505050505050611e97565b60038103612472578415612313576040517feb62520400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600194505f600f83169050600f810361234b5761233b858a8a612b989290919263ffffffff16565b8161ffff16915080965081925050505b5f8590508167ffffffffffffffff81111561236957612368613533565b5b6040519080825280602002602001820160405280156123975781602001602082028036833780820191505090505b5088604001819052505f5f90505b82811015612422576123c2878c8c6129ed9290919263ffffffff16565b8a6040015183815181106123d9576123d8613ca0565b5b602002602001018199508273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815250505080806001019150506123a5565b505f61243e8b8b84908a92612439939291906140ca565b612bb3565b90505f5f1b895f0151036124525780612460565b61245f895f015182612b57565b5b895f0181815250505050505050611e97565b60048103612571575f73ffffffffffffffffffffffffffffffffffffffff16866020015173ffffffffffffffffffffffffffffffffffffffff16146124e3576040517f9e5c658b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6124f88489896129ed9290919263ffffffff16565b876020018196508273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681525050505f61253f8760200151612be8565b90505f5f1b875f0151036125535780612561565b612560875f015182612b57565b5b875f018181525050505050611e97565b806040517f0ad997900000000000000000000000000000000000000000000000000000000081526004016125a59190613506565b60405180910390fd5b5f846060015190508181525050509250929050565b5f5f848301358060f81c925060018401915050935093915050565b6125e661315f565b5f8290506125ff8186866129ed9290919263ffffffff16565b835f018193508273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815250505061264c818686612c1a9290919263ffffffff16565b83602001819350827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681525050506126ac818686611d5a9290919263ffffffff16565b836040018193508281525050506126ce818686611d5a9290919263ffffffff16565b836060018193508281525050505f6126f1828787611e009290919263ffffffff16565b8162ffffff16915080935081925050508585839083856127119190613e18565b9261271e939291906140ca565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f82011690508083019250505050505050836080018190525080826127749190613e18565b9150612781868684612c54565b8460a001819450829052505050935093915050565b5f5f5f5f5f8786013594506020880186013590506040860191505f60ff82901c90507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82165f1b9450601b816127ec9190614728565b9350505093509350935093565b5f61280382612d3e565b805190602001209050919050565b5f8160200160208101906128259190613cf4565b61282f5746612831565b5f5b8260600135836080013561284d86612848906148cb565b612d97565b604051602001612860949392919061491d565b60405160208183030381529060405280519060200120905092915050565b5f5f5f90505f600184516128929190614973565b90505b80821361297f575f600283836128ab9190614973565b6128b591906149b3565b836128c09190614a1b565b90505f8582815181106128d6576128d5613ca0565b5b602002602001015190508673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612920576001945050505050612985565b8673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161015612968576001826129619190614a1b565b9350612978565b6001826129759190614973565b92505b5050612895565b5f925050505b92915050565b5f60405160200161299b90614ab0565b6040516020818303038152906040528051906020012082846060015185604001516040516020016129cf9493929190614b09565b60405160208183030381529060405280519060200120905092915050565b5f5f8483013573ffffffffffffffffffffffffffffffffffffffff8160601c16925060148401915050935093915050565b5f5f848301359150602083019050935093915050565b5f5f848301358060c01c925060088401915050935093915050565b60605f5f612a688487876125c39290919263ffffffff16565b8160ff16915080955081925050508067ffffffffffffffff811115612a9057612a8f613533565b5b604051908082528060200260200182016040528015612ac957816020015b612ab661325d565b815260200190600190039081612aae5790505b5092505f5f90505b81811015612b1357612ae4878787612e18565b858381518110612af757612af6613ca0565b5b6020026020010181975082905250508080600101915050612ad1565b5082849250925050935093915050565b5f5f8383604051602001612b3993929190614b8a565b60405160208183030381529060405280519060200120905092915050565b5f825f528160205260405f20905092915050565b5f5f858401356008840261010003600180866008021b0382821c1693508486019250505094509492505050565b5f5f848301358060f01c925060028401915050935093915050565b5f60038383604051602001612bca93929190614b8a565b60405160208183030381529060405280519060200120905092915050565b5f600482604051602001612bfd929190614bb3565b604051602081830303815290604052805190602001209050919050565b5f5f848301357fffffffff000000000000000000000000000000000000000000000000000000008116925060048401915050935093915050565b612c5c61328c565b5f5f612c73848787611e009290919263ffffffff16565b8095508192505050858585908362ffffff1687612c909190613e18565b92612c9d939291906140ca565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f81840152601f19601f82011690508083019250505050505050835f01819052508062ffffff1684612cf79190613e18565b9350612d0e848787612a349290919263ffffffff16565b846020018196508267ffffffffffffffff1667ffffffffffffffff16815250505082849250925050935093915050565b6060815f01518260200151836040015184606001518560800151518660800151612d6b8860a00151613097565b604051602001612d819796959493929190614c70565b6040516020818303038152906040529050919050565b5f7f0603985259a953da1f65a522f589c17bd1d0117ec1d3abb7c0788aef251ef4375f1b825f01518360200151846040015180519060200120856060015186608001518760a001518860c00151604051602001612dfb989796959493929190614ce8565b604051602081830303815290604052805190602001209050919050565b612e2061325d565b5f612e368386866129ed9290919263ffffffff16565b835f018195508273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681525050505f612e848487876125c39290919263ffffffff16565b8160ff16915080955081925050508067ffffffffffffffff811115612eac57612eab613533565b5b604051908082528060200260200182016040528015612ee557816020015b612ed26132af565b815260200190600190039081612eca5790505b5083602001819052505f5f90505b81811015613087575f612f118689896125c39290919263ffffffff16565b80975081925050505f6001821660ff16141585602001518381518110612f3a57612f39613ca0565b5b60200260200101515f01901515908115158152505060018160ff16901c60ff166003811115612f6c57612f6b613ef4565b5b85602001518381518110612f8357612f82613ca0565b5b6020026020010151602001906003811115612fa157612fa0613ef4565b5b90816003811115612fb557612fb4613ef4565b5b81525050612fce868989611d5a9290919263ffffffff16565b86602001518481518110612fe557612fe4613ca0565b5b602002602001015160400181985082815250505061300e868989612a1e9290919263ffffffff16565b8660200151848151811061302557613024613ca0565b5b602002602001015160600181985082815250505061304e868989611d5a9290919263ffffffff16565b8660200151848151811061306557613064613ca0565b5b6020026020010151608001819850828152505050508080600101915050612ef3565b5082849250925050935093915050565b6060815f015151825f015183602001516040516020016130b993929190614d98565b6040516020818303038152906040529050919050565b60405180606001604052805f73ffffffffffffffffffffffffffffffffffffffff168152602001606081526020015f81525090565b60405180604001604052805f81526020015f81525090565b6040518060a001604052805f81526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020016060815260200160608152602001606081525090565b6040518060c001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191681526020015f81526020015f8152602001606081526020016131c661328c565b81525090565b60405180608001604052805f151581526020015f73ffffffffffffffffffffffffffffffffffffffff1681526020015f60ff16815260200161320c61315f565b81525090565b6040518060a001604052805f73ffffffffffffffffffffffffffffffffffffffff1681526020015f81526020015f81526020015f67ffffffffffffffff168152602001606081525090565b60405180604001604052805f73ffffffffffffffffffffffffffffffffffffffff168152602001606081525090565b6040518060400160405280606081526020015f67ffffffffffffffff1681525090565b6040518060a001604052805f151581526020015f60038111156132d5576132d4613ef4565b5b81526020015f81526020015f81526020015f81525090565b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f6101208284031215613318576133176132fe565b5b81905092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f84011261334257613341613321565b5b8235905067ffffffffffffffff81111561335f5761335e613325565b5b60208301915083600182028301111561337b5761337a613329565b5b9250929050565b5f5f5f60408486031215613399576133986132f6565b5b5f84013567ffffffffffffffff8111156133b6576133b56132fa565b5b6133c286828701613302565b935050602084013567ffffffffffffffff8111156133e3576133e26132fa565b5b6133ef8682870161332d565b92509250509250925092565b5f819050919050565b61340d816133fb565b82525050565b5f6020820190506134265f830184613404565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6134558261342c565b9050919050565b6134658161344b565b811461346f575f5ffd5b50565b5f813590506134808161345c565b92915050565b61348f816133fb565b8114613499575f5ffd5b50565b5f813590506134aa81613486565b92915050565b5f5f604083850312156134c6576134c56132f6565b5b5f6134d385828601613472565b92505060206134e48582860161349c565b9150509250929050565b5f819050919050565b613500816134ee565b82525050565b5f6020820190506135195f8301846134f7565b92915050565b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b61356982613523565b810181811067ffffffffffffffff8211171561358857613587613533565b5b80604052505050565b5f61359a6132ed565b90506135a68282613560565b919050565b5f5ffd5b5f67ffffffffffffffff8211156135c9576135c8613533565b5b602082029050602081019050919050565b5f8115159050919050565b6135ee816135da565b81146135f8575f5ffd5b50565b5f81359050613609816135e5565b92915050565b6004811061361b575f5ffd5b50565b5f8135905061362c8161360f565b92915050565b61363b816134ee565b8114613645575f5ffd5b50565b5f8135905061365681613632565b92915050565b5f60a082840312156136715761367061351f565b5b61367b60a0613591565b90505f61368a848285016135fb565b5f83015250602061369d8482850161361e565b60208301525060406136b18482850161349c565b60408301525060606136c584828501613648565b60608301525060806136d98482850161349c565b60808301525092915050565b5f6136f76136f2846135af565b613591565b90508083825260208201905060a0840283018581111561371a57613719613329565b5b835b81811015613743578061372f888261365c565b84526020840193505060a08101905061371c565b5050509392505050565b5f82601f83011261376157613760613321565b5b81356137718482602086016136e5565b91505092915050565b5f6040828403121561378f5761378e61351f565b5b6137996040613591565b90505f6137a884828501613472565b5f83015250602082013567ffffffffffffffff8111156137cb576137ca6135ab565b5b6137d78482850161374d565b60208301525092915050565b5f60e082840312156137f8576137f76132fe565b5b81905092915050565b5f67ffffffffffffffff82111561381b5761381a613533565b5b602082029050602081019050919050565b5f604082840312156138415761384061351f565b5b61384b6040613591565b90505f61385a8482850161349c565b5f83015250602061386d84828501613648565b60208301525092915050565b5f61388b61388684613801565b613591565b905080838252602082019050604084028301858111156138ae576138ad613329565b5b835b818110156138d757806138c3888261382c565b8452602084019350506040810190506138b0565b5050509392505050565b5f82601f8301126138f5576138f4613321565b5b8135613905848260208601613879565b91505092915050565b5f5f5f5f5f60a08688031215613927576139266132f6565b5b5f86013567ffffffffffffffff811115613944576139436132fa565b5b6139508882890161377a565b955050602086013567ffffffffffffffff811115613971576139706132fa565b5b61397d888289016137e3565b945050604061398e88828901613472565b935050606061399f88828901613472565b925050608086013567ffffffffffffffff8111156139c0576139bf6132fa565b5b6139cc888289016138e1565b9150509295509295909350565b6139e2816135da565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b613a1a816133fb565b82525050565b613a29816134ee565b82525050565b604082015f820151613a435f850182613a11565b506020820151613a566020850182613a20565b50505050565b5f613a678383613a2f565b60408301905092915050565b5f602082019050919050565b5f613a89826139e8565b613a9381856139f2565b9350613a9e83613a02565b805f5b83811015613ace578151613ab58882613a5c565b9750613ac083613a73565b925050600181019050613aa1565b5085935050505092915050565b5f604082019050613aee5f8301856139d9565b8181036020830152613b008184613a7f565b90509392505050565b5f5f83601f840112613b1e57613b1d613321565b5b8235905067ffffffffffffffff811115613b3b57613b3a613325565b5b602083019150836040820283011115613b5757613b56613329565b5b9250929050565b5f5f60208385031215613b7457613b736132f6565b5b5f83013567ffffffffffffffff811115613b9157613b906132fa565b5b613b9d85828601613b09565b92509250509250929050565b613bb28161344b565b82525050565b5f602082019050613bcb5f830184613ba9565b92915050565b5f60ff82169050919050565b613be681613bd1565b8114613bf0575f5ffd5b50565b5f81359050613c0181613bdd565b92915050565b5f60208284031215613c1c57613c1b6132f6565b5b5f613c2984828501613bf3565b91505092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83356001602003843603038112613c5a57613c59613c32565b5b80840192508235915067ffffffffffffffff821115613c7c57613c7b613c36565b5b602083019250602082023603831315613c9857613c97613c3a565b5b509250929050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f8235600160e003833603038112613ce857613ce7613c32565b5b80830191505092915050565b5f60208284031215613d0957613d086132f6565b5b5f613d16848285016135fb565b91505092915050565b5f604082019050613d325f830185613ba9565b613d3f6020830184613ba9565b9392505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f613d7d826134ee565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203613daf57613dae613d46565b5b600182019050919050565b5f613dc4826134ee565b9150613dcf836134ee565b9250828203905081811115613de757613de6613d46565b5b92915050565b5f60208284031215613e0257613e016132f6565b5b5f613e0f84828501613472565b91505092915050565b5f613e22826134ee565b9150613e2d836134ee565b9250828201905080821115613e4557613e44613d46565b5b92915050565b5f5f83356001602003843603038112613e6757613e66613c32565b5b80840192508235915067ffffffffffffffff821115613e8957613e88613c36565b5b602083019250600182023603831315613ea557613ea4613c3a565b5b509250929050565b613eb68161344b565b82525050565b5f81519050919050565b5f82825260208201905092915050565b5f819050602082019050919050565b613eee816135da565b82525050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b60048110613f3257613f31613ef4565b5b50565b5f819050613f4282613f21565b919050565b5f613f5182613f35565b9050919050565b613f6181613f47565b82525050565b60a082015f820151613f7b5f850182613ee5565b506020820151613f8e6020850182613f58565b506040820151613fa16040850182613a11565b506060820151613fb46060850182613a20565b506080820151613fc76080850182613a11565b50505050565b5f613fd88383613f67565b60a08301905092915050565b5f602082019050919050565b5f613ffa82613ebc565b6140048185613ec6565b935061400f83613ed6565b805f5b8381101561403f5781516140268882613fcd565b975061403183613fe4565b925050600181019050614012565b5085935050505092915050565b5f604083015f8301516140615f860182613ead565b50602083015184820360208601526140798282613ff0565b9150508091505092915050565b5f6060820190506140995f830186613ba9565b81810360208301526140ab818561404c565b90506140ba60408301846134f7565b949350505050565b5f5ffd5b5f5ffd5b5f5f858511156140dd576140dc6140c2565b5b838611156140ee576140ed6140c6565b5b6001850283019150848603905094509492505050565b61410d81613bd1565b82525050565b5f6080820190506141265f830187613404565b6141336020830186614104565b6141406040830185613404565b61414d6060830184613404565b95945050505050565b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b61418a81614156565b82525050565b5f81519050919050565b5f82825260208201905092915050565b8281835e5f83830152505050565b5f6141c282614190565b6141cc818561419a565b93506141dc8185602086016141aa565b6141e581613523565b840191505092915050565b5f81519050919050565b5f82825260208201905092915050565b5f614214826141f0565b61421e81856141fa565b935061422e8185602086016141aa565b61423781613523565b840191505092915050565b5f67ffffffffffffffff82169050919050565b61425e81614242565b82525050565b5f604083015f8301518482035f86015261427e828261420a565b91505060208301516142936020860182614255565b508091505092915050565b5f60c083015f8301516142b35f860182613ead565b5060208301516142c66020860182614181565b5060408301516142d96040860182613a11565b5060608301516142ec6060860182613a11565b506080830151848203608086015261430482826141b8565b91505060a083015184820360a086015261431e8282614264565b9150508091505092915050565b5f6143396020840184613472565b905092915050565b5f61434f6020840184613648565b905092915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f8335600160200384360303811261437f5761437e61435f565b5b83810192508235915060208301925067ffffffffffffffff8211156143a7576143a6614357565b5b6001820236038313156143bd576143bc61435b565b5b509250929050565b828183375f83830152505050565b5f6143de838561419a565b93506143eb8385846143c5565b6143f483613523565b840190509392505050565b5f61440d60208401846135fb565b905092915050565b5f60e083016144265f84018461432b565b6144325f860182613ead565b506144406020840184614341565b61444d6020860182613a20565b5061445b6040840184614363565b858303604087015261446e8382846143d3565b9250505061447f6060840184614341565b61448c6060860182613a20565b5061449a60808401846143ff565b6144a76080860182613ee5565b506144b560a08401846143ff565b6144c260a0860182613ee5565b506144d060c0840184614341565b6144dd60c0860182613a20565b508091505092915050565b5f6060820190506144fb5f830186613ba9565b818103602083015261450d818561429e565b905081810360408301526145218184614415565b9050949350505050565b5f8151905061453981613486565b92915050565b5f60208284031215614554576145536132f6565b5b5f6145618482850161452b565b91505092915050565b5f819050919050565b5f61458d61458861458384614242565b61456a565b6134ee565b9050919050565b61459d81614573565b82525050565b5f6020820190506145b65f830184614594565b92915050565b5f82905092915050565b5f82821b905092915050565b5f6145dd83836145bc565b826145e88135614156565b92506004821015614628576146237fffffffff00000000000000000000000000000000000000000000000000000000836004036008026145c6565b831692505b505092915050565b5f6020820190508181035f8301526146488184613a7f565b905092915050565b5f81905092915050565b5f6146658385614650565b93506146728385846143c5565b82840190509392505050565b5f61468a82848661465a565b91508190509392505050565b5f6060820190506146a95f830186613ba9565b6146b66020830185613404565b6146c360408301846134f7565b949350505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b5f614702826134ee565b915061470d836134ee565b92508261471d5761471c6146cb565b5b828204905092915050565b5f61473282613bd1565b915061473d83613bd1565b9250828201905060ff81111561475657614755613d46565b5b92915050565b5f5ffd5b5f67ffffffffffffffff82111561477a57614779613533565b5b61478382613523565b9050602081019050919050565b5f6147a261479d84614760565b613591565b9050828152602081018484840111156147be576147bd61475c565b5b6147c98482856143c5565b509392505050565b5f82601f8301126147e5576147e4613321565b5b81356147f5848260208601614790565b91505092915050565b5f60e082840312156148135761481261351f565b5b61481d60e0613591565b90505f61482c84828501613472565b5f83015250602061483f84828501613648565b602083015250604082013567ffffffffffffffff811115614863576148626135ab565b5b61486f848285016147d1565b604083015250606061488384828501613648565b6060830152506080614897848285016135fb565b60808301525060a06148ab848285016135fb565b60a08301525060c06148bf84828501613648565b60c08301525092915050565b5f6148d636836147fe565b9050919050565b5f819050919050565b6148f76148f2826134ee565b6148dd565b82525050565b5f819050919050565b614917614912826133fb565b6148fd565b82525050565b5f61492882876148e6565b60208201915061493882866148e6565b60208201915061494882856148e6565b6020820191506149588284614906565b60208201915081905095945050505050565b5f819050919050565b5f61497d8261496a565b91506149888361496a565b925082820390508181125f8412168282135f8512151617156149ad576149ac613d46565b5b92915050565b5f6149bd8261496a565b91506149c88361496a565b9250826149d8576149d76146cb565b5b60015f0383147f800000000000000000000000000000000000000000000000000000000000000083141615614a1057614a0f613d46565b5b828205905092915050565b5f614a258261496a565b9150614a308361496a565b92508282019050828112155f8312168382125f841215161715614a5657614a55613d46565b5b92915050565b5f81905092915050565b7f616363657074496d706c696369745265717565737400000000000000000000005f82015250565b5f614a9a601583614a5c565b9150614aa582614a66565b601582019050919050565b5f614aba82614a8e565b9150819050919050565b5f8160601b9050919050565b5f614ada82614ac4565b9050919050565b5f614aeb82614ad0565b9050919050565b614b03614afe8261344b565b614ae1565b82525050565b5f614b148287614906565b602082019150614b248286614af2565b601482019150614b348285614906565b602082019150614b448284614906565b60208201915081905095945050505050565b5f8160f81b9050919050565b5f614b6c82614b56565b9050919050565b614b84614b7f82613bd1565b614b62565b82525050565b5f614b958286614b73565b600182019150614ba682848661465a565b9150819050949350505050565b5f614bbe8285614b73565b600182019150614bce8284614af2565b6014820191508190509392505050565b5f819050919050565b614bf8614bf382614156565b614bde565b82525050565b5f62ffffff82169050919050565b5f8160e81b9050919050565b5f614c2282614c0c565b9050919050565b614c3a614c3582614bfe565b614c18565b82525050565b5f614c4a82614190565b614c548185614650565b9350614c648185602086016141aa565b80840191505092915050565b5f614c7b828a614af2565b601482019150614c8b8289614be7565b600482019150614c9b8288614906565b602082019150614cab8287614906565b602082019150614cbb8286614c29565b600382019150614ccb8285614c40565b9150614cd78284614c40565b915081905098975050505050505050565b5f61010082019050614cfc5f83018b613404565b614d09602083018a613ba9565b614d1660408301896134f7565b614d236060830188613404565b614d3060808301876134f7565b614d3d60a08301866139d9565b614d4a60c08301856139d9565b614d5760e08301846134f7565b9998505050505050505050565b5f8160c01b9050919050565b5f614d7a82614d64565b9050919050565b614d92614d8d82614242565b614d70565b82525050565b5f614da38286614c29565b600382019150614db38285614c40565b9150614dbf8284614d81565b60088201915081905094935050505056fea2646970667358221220f96b0bb846a39f6d615bc3301dc79b1702e6e13e53de4cf930ab8d53f11ac7d464736f6c634300081c0033',
      signer
    )
  }
}

export const SESSION_MANAGER_VERIFICATION: Omit<VerificationRequest, 'waitForSuccess'> = {
  contractToVerify: 'src/extensions/sessions/SessionManager.sol:SessionManager',
  version: 'v0.8.28+commit.7893614a',
  licenceType: 'Apache-2.0',
  compilerInput: {
    language: 'Solidity',
    sources: {
      'src/extensions/sessions/SessionManager.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from "../../modules/Payload.sol";\nimport { ISapient } from "../../modules/interfaces/ISapient.sol";\nimport { LibBytes } from "../../utils/LibBytes.sol";\n\nimport { SessionErrors } from "./SessionErrors.sol";\nimport { SessionSig } from "./SessionSig.sol";\nimport {\n  ExplicitSessionManager,\n  IExplicitSessionManager,\n  SessionPermissions,\n  SessionUsageLimits\n} from "./explicit/ExplicitSessionManager.sol";\nimport { Permission, UsageLimit } from "./explicit/Permission.sol";\nimport { ImplicitSessionManager } from "./implicit/ImplicitSessionManager.sol";\n\nusing LibBytes for bytes;\n\n/// @title SessionManager\n/// @author Michael Standen, Agustin Aguilar\n/// @notice Manager for smart sessions\ncontract SessionManager is ISapient, ImplicitSessionManager, ExplicitSessionManager {\n\n  /// @notice Error thrown when the payload kind is invalid\n  error InvalidPayloadKind();\n  /// @notice Error thrown when the calls length is invalid\n  error InvalidCallsLength();\n\n  /// @inheritdoc ISapient\n  function recoverSapientSignature(\n    Payload.Decoded calldata payload,\n    bytes calldata encodedSignature\n  ) external view returns (bytes32) {\n    // Validate outer Payload\n    if (payload.kind != Payload.KIND_TRANSACTIONS) {\n      revert InvalidPayloadKind();\n    }\n    if (payload.calls.length == 0) {\n      revert InvalidCallsLength();\n    }\n\n    // Decode signature\n    SessionSig.DecodedSignature memory sig = SessionSig.recoverSignature(payload, encodedSignature);\n\n    address wallet = msg.sender;\n\n    // Initialize session usage limits for explicit session\n    SessionUsageLimits[] memory sessionUsageLimits = new SessionUsageLimits[](payload.calls.length);\n\n    for (uint256 i = 0; i < payload.calls.length; i++) {\n      // General validation\n      Payload.Call calldata call = payload.calls[i];\n      if (call.delegateCall) {\n        revert SessionErrors.InvalidDelegateCall();\n      }\n\n      // Validate call signature\n      SessionSig.CallSignature memory callSignature = sig.callSignatures[i];\n      if (callSignature.isImplicit) {\n        // Validate implicit calls\n        _validateImplicitCall(\n          call, wallet, callSignature.sessionSigner, callSignature.attestation, sig.implicitBlacklist\n        );\n      } else {\n        // Find the session usage limits for the current call\n        SessionUsageLimits memory limits;\n        uint256 limitsIdx;\n        for (limitsIdx = 0; limitsIdx < sessionUsageLimits.length; limitsIdx++) {\n          if (sessionUsageLimits[limitsIdx].signer == address(0)) {\n            // Initialize new session usage limits\n            limits.signer = callSignature.sessionSigner;\n            limits.limits = new UsageLimit[](0);\n            bytes32 usageHash = keccak256(abi.encode(callSignature.sessionSigner, VALUE_TRACKING_ADDRESS));\n            limits.totalValueUsed = getLimitUsage(wallet, usageHash);\n            break;\n          }\n          if (sessionUsageLimits[limitsIdx].signer == callSignature.sessionSigner) {\n            limits = sessionUsageLimits[limitsIdx];\n            break;\n          }\n        }\n        // Validate explicit calls. Obtain usage limits for increment validation.\n        (limits) = _validateExplicitCall(\n          payload,\n          i,\n          wallet,\n          callSignature.sessionSigner,\n          sig.sessionPermissions,\n          callSignature.sessionPermission,\n          limits\n        );\n        sessionUsageLimits[limitsIdx] = limits;\n      }\n    }\n\n    {\n      // Reduce the size of the sessionUsageLimits array\n      SessionUsageLimits[] memory actualSessionUsageLimits = new SessionUsageLimits[](sessionUsageLimits.length);\n      uint256 actualSize;\n      for (uint256 i = 0; i < sessionUsageLimits.length; i++) {\n        if (sessionUsageLimits[i].limits.length > 0 || sessionUsageLimits[i].totalValueUsed > 0) {\n          actualSessionUsageLimits[actualSize] = sessionUsageLimits[i];\n          actualSize++;\n        }\n      }\n      assembly {\n        mstore(actualSessionUsageLimits, actualSize)\n      }\n\n      // Bulk validate the updated usage limits\n      Payload.Call calldata lastCall = payload.calls[payload.calls.length - 1];\n      _validateLimitUsageIncrement(lastCall, actualSessionUsageLimits);\n    }\n\n    // Return the image hash\n    return sig.imageHash;\n  }\n\n}\n'
      },
      'src/modules/Payload.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibBytes } from "../utils/LibBytes.sol";\n\nusing LibBytes for bytes;\n\n/// @title Payload\n/// @author Agustin Aguilar, Michael Standen, William Hua\n/// @notice Library for encoding and decoding payloads\nlibrary Payload {\n\n  /// @notice Error thrown when the kind is invalid\n  error InvalidKind(uint8 kind);\n\n  /// @dev keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")\n  bytes32 private constant EIP712_DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n  /// @dev keccak256("Sequence Wallet")\n  bytes32 private constant EIP712_DOMAIN_NAME_SEQUENCE =\n    0x4aa45ca7ad825ceb1bf35643f0a58c295239df563b1b565c2485f96477c56318;\n\n  /// @dev keccak256("3")\n  bytes32 private constant EIP712_DOMAIN_VERSION_SEQUENCE =\n    0x2a80e1ef1d7842f27f2e6be0972bb708b9a135c38860dbe73c27c3486c34f4de;\n\n  function domainSeparator(bool _noChainId, address _wallet) internal view returns (bytes32 _domainSeparator) {\n    return keccak256(\n      abi.encode(\n        EIP712_DOMAIN_TYPEHASH,\n        EIP712_DOMAIN_NAME_SEQUENCE,\n        EIP712_DOMAIN_VERSION_SEQUENCE,\n        _noChainId ? uint256(0) : uint256(block.chainid),\n        _wallet\n      )\n    );\n  }\n\n  /// @dev keccak256("Call(address to,uint256 value,bytes data,uint256 gasLimit,bool delegateCall,bool onlyFallback,uint256 behaviorOnError)")\n  bytes32 private constant CALL_TYPEHASH = 0x0603985259a953da1f65a522f589c17bd1d0117ec1d3abb7c0788aef251ef437;\n\n  /// @dev keccak256("Calls(Call[] calls,uint256 space,uint256 nonce,address[] wallets)Call(address to,uint256 value,bytes data,uint256 gasLimit,bool delegateCall,bool onlyFallback,uint256 behaviorOnError)")\n  bytes32 private constant CALLS_TYPEHASH = 0x11e1e4079a79a66e4ade50033cfe2678cdd5341d2dfe5ef9513edb1a0be147a2;\n\n  /// @dev keccak256("Message(bytes message,address[] wallets)")\n  bytes32 private constant MESSAGE_TYPEHASH = 0xe19a3b94fc3c7ece3f890d98a99bc422615537a08dea0603fa8425867d87d466;\n\n  /// @dev keccak256("ConfigUpdate(bytes32 imageHash,address[] wallets)")\n  bytes32 private constant CONFIG_UPDATE_TYPEHASH = 0x11fdeb7e8373a1aa96bfac8d0ea91526b2c5d15e5cee20e0543e780258f3e8e4;\n\n  /// @notice Kind of transaction\n  uint8 public constant KIND_TRANSACTIONS = 0x00;\n  /// @notice Kind of digest\n  uint8 public constant KIND_MESSAGE = 0x01;\n  /// @notice Kind of config update\n  uint8 public constant KIND_CONFIG_UPDATE = 0x02;\n  /// @notice Kind of message\n  uint8 public constant KIND_DIGEST = 0x03;\n\n  /// @notice Behavior on error: ignore error\n  uint8 public constant BEHAVIOR_IGNORE_ERROR = 0x00;\n  /// @notice Behavior on error: revert on error\n  uint8 public constant BEHAVIOR_REVERT_ON_ERROR = 0x01;\n  /// @notice Behavior on error: abort on error\n  uint8 public constant BEHAVIOR_ABORT_ON_ERROR = 0x02;\n\n  /// @notice Payload call information\n  /// @param to Address of the target contract\n  /// @param value Value to send with the call\n  /// @param data Data to send with the call\n  /// @param gasLimit Gas limit for the call\n  /// @param delegateCall If the call is a delegate call\n  /// @param onlyFallback If the call should only be executed in an error scenario\n  /// @param behaviorOnError Behavior on error\n  struct Call {\n    address to;\n    uint256 value;\n    bytes data;\n    uint256 gasLimit;\n    bool delegateCall;\n    bool onlyFallback;\n    uint256 behaviorOnError;\n  }\n\n  /// @notice Decoded payload\n  /// @param kind Kind of payload\n  /// @param noChainId If the chain ID should be omitted\n  /// @param calls Array of calls (transaction kind)\n  /// @param space Nonce space for the calls (transaction kind)\n  /// @param nonce Nonce value for the calls (transaction kind)\n  /// @param message Message to validate (message kind)\n  /// @param imageHash Image hash to update to (config update kind)\n  /// @param digest Digest to validate (digest kind)\n  /// @param parentWallets Parent wallets\n  struct Decoded {\n    uint8 kind;\n    bool noChainId;\n    // Transaction kind\n    Call[] calls;\n    uint256 space;\n    uint256 nonce;\n    // Message kind\n    // TODO: Maybe native 721 ?\n    bytes message;\n    // Config update kind\n    bytes32 imageHash;\n    // Digest kind for 1271\n    bytes32 digest;\n    // Parent wallets\n    address[] parentWallets;\n  }\n\n  function fromMessage(\n    bytes memory message\n  ) internal pure returns (Decoded memory _decoded) {\n    _decoded.kind = KIND_MESSAGE;\n    _decoded.message = message;\n  }\n\n  function fromConfigUpdate(\n    bytes32 imageHash\n  ) internal pure returns (Decoded memory _decoded) {\n    _decoded.kind = KIND_CONFIG_UPDATE;\n    _decoded.imageHash = imageHash;\n  }\n\n  function fromDigest(\n    bytes32 digest\n  ) internal pure returns (Decoded memory _decoded) {\n    _decoded.kind = KIND_DIGEST;\n    _decoded.digest = digest;\n  }\n\n  function fromPackedCalls(\n    bytes calldata packed\n  ) internal view returns (Decoded memory _decoded) {\n    _decoded.kind = KIND_TRANSACTIONS;\n\n    // Read the global flag\n    (uint256 globalFlag, uint256 pointer) = packed.readFirstUint8();\n\n    // First bit determines if space is zero or not\n    if (globalFlag & 0x01 == 0x01) {\n      _decoded.space = 0;\n    } else {\n      (_decoded.space, pointer) = packed.readUint160(pointer);\n    }\n\n    // Next 3 bits determine the size of the nonce\n    uint256 nonceSize = (globalFlag >> 1) & 0x07;\n\n    if (nonceSize > 0) {\n      // Read the nonce\n      (_decoded.nonce, pointer) = packed.readUintX(pointer, nonceSize);\n    }\n\n    uint256 numCalls;\n\n    // Bit 5 determines if the batch contains a single call\n    if (globalFlag & 0x10 == 0x10) {\n      numCalls = 1;\n    } else {\n      // Bit 6 determines if the number of calls uses 1 byte or 2 bytes\n      if (globalFlag & 0x20 == 0x20) {\n        (numCalls, pointer) = packed.readUint16(pointer);\n      } else {\n        (numCalls, pointer) = packed.readUint8(pointer);\n      }\n    }\n\n    // Read the calls\n    _decoded.calls = new Call[](numCalls);\n\n    for (uint256 i = 0; i < numCalls; i++) {\n      uint8 flags;\n      (flags, pointer) = packed.readUint8(pointer);\n\n      // First bit determines if this is a call to self\n      // or a call to another address\n      if (flags & 0x01 == 0x01) {\n        // Call to self\n        _decoded.calls[i].to = address(this);\n      } else {\n        // Call to another address\n        (_decoded.calls[i].to, pointer) = packed.readAddress(pointer);\n      }\n\n      // Second bit determines if the call has value or not\n      if (flags & 0x02 == 0x02) {\n        (_decoded.calls[i].value, pointer) = packed.readUint256(pointer);\n      }\n\n      // Third bit determines if the call has data or not\n      if (flags & 0x04 == 0x04) {\n        // 3 bytes determine the size of the calldata\n        uint256 calldataSize;\n        (calldataSize, pointer) = packed.readUint24(pointer);\n        _decoded.calls[i].data = packed[pointer:pointer + calldataSize];\n        pointer += calldataSize;\n      }\n\n      // Fourth bit determines if the call has a gas limit or not\n      if (flags & 0x08 == 0x08) {\n        (_decoded.calls[i].gasLimit, pointer) = packed.readUint256(pointer);\n      }\n\n      // Fifth bit determines if the call is a delegate call or not\n      _decoded.calls[i].delegateCall = (flags & 0x10 == 0x10);\n\n      // Sixth bit determines if the call is fallback only\n      _decoded.calls[i].onlyFallback = (flags & 0x20 == 0x20);\n\n      // Last 2 bits are directly mapped to the behavior on error\n      _decoded.calls[i].behaviorOnError = (flags & 0xC0) >> 6;\n    }\n  }\n\n  function hashCall(\n    Call memory c\n  ) internal pure returns (bytes32) {\n    return keccak256(\n      abi.encode(\n        CALL_TYPEHASH, c.to, c.value, keccak256(c.data), c.gasLimit, c.delegateCall, c.onlyFallback, c.behaviorOnError\n      )\n    );\n  }\n\n  function hashCalls(\n    Call[] memory calls\n  ) internal pure returns (bytes32) {\n    // In EIP712, an array is often hashed as the keccak256 of the concatenated\n    // hashes of each item. So we hash each Call, pack them, and hash again.\n    bytes32[] memory callHashes = new bytes32[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      callHashes[i] = hashCall(calls[i]);\n    }\n    return keccak256(abi.encodePacked(callHashes));\n  }\n\n  function toEIP712(\n    Decoded memory _decoded\n  ) internal pure returns (bytes32) {\n    bytes32 walletsHash = keccak256(abi.encodePacked(_decoded.parentWallets));\n\n    if (_decoded.kind == KIND_TRANSACTIONS) {\n      bytes32 callsHash = hashCalls(_decoded.calls);\n      // The top-level struct for Calls might be something like:\n      // Calls(bytes32 callsHash,uint256 space,uint256 nonce,bytes32 walletsHash)\n      return keccak256(abi.encode(CALLS_TYPEHASH, callsHash, _decoded.space, _decoded.nonce, walletsHash));\n    } else if (_decoded.kind == KIND_MESSAGE) {\n      // If you define your top-level as: Message(bytes32 messageHash,bytes32 walletsHash)\n      return keccak256(abi.encode(MESSAGE_TYPEHASH, keccak256(_decoded.message), walletsHash));\n    } else if (_decoded.kind == KIND_CONFIG_UPDATE) {\n      // Top-level: ConfigUpdate(bytes32 imageHash,bytes32 walletsHash)\n      return keccak256(abi.encode(CONFIG_UPDATE_TYPEHASH, _decoded.imageHash, walletsHash));\n    } else if (_decoded.kind == KIND_DIGEST) {\n      // Top-level: Use MESSAGE_TYPEHASH but assume the digest is already the hashed message\n      return keccak256(abi.encode(MESSAGE_TYPEHASH, _decoded.digest, walletsHash));\n    } else {\n      // Unknown kind\n      revert InvalidKind(_decoded.kind);\n    }\n  }\n\n  function hash(\n    Decoded memory _decoded\n  ) internal view returns (bytes32) {\n    bytes32 domain = domainSeparator(_decoded.noChainId, address(this));\n    bytes32 structHash = toEIP712(_decoded);\n    return keccak256(abi.encodePacked("\\x19\\x01", domain, structHash));\n  }\n\n  function hashFor(Decoded memory _decoded, address _wallet) internal view returns (bytes32) {\n    bytes32 domain = domainSeparator(_decoded.noChainId, _wallet);\n    bytes32 structHash = toEIP712(_decoded);\n    return keccak256(abi.encodePacked("\\x19\\x01", domain, structHash));\n  }\n\n}\n'
      },
      'src/modules/interfaces/ISapient.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from "../Payload.sol";\n\n/// @title ISapient\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Sapient signers take an explicit payload and return their own "imageHash" as result\n/// @dev The consumer of this signer must validate if the imageHash is valid or not, for the desired configuration\ninterface ISapient {\n\n  /// @notice Recovers the image hash of a given signature\n  /// @param payload The payload to recover the signature from\n  /// @param signature The signature to recover the image hash from\n  /// @return imageHash The recovered image hash\n  function recoverSapientSignature(\n    Payload.Decoded calldata payload,\n    bytes calldata signature\n  ) external view returns (bytes32 imageHash);\n\n}\n\n/// @title ISapientCompact\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Sapient signers take a compacted payload and return their own "imageHash" as result\n/// @dev The consumer of this signer must validate if the imageHash is valid or not, for the desired configuration\ninterface ISapientCompact {\n\n  /// @notice Recovers the image hash of a given signature, using a hashed payload\n  /// @param digest The digest of the payload\n  /// @param signature The signature to recover the image hash from\n  /// @return imageHash The recovered image hash\n  function recoverSapientSignatureCompact(\n    bytes32 digest,\n    bytes calldata signature\n  ) external view returns (bytes32 imageHash);\n\n}\n'
      },
      'src/utils/LibBytes.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\n/// @title Library for reading data from bytes arrays\n/// @author Agustin Aguilar (aa@horizon.io), Michael Standen (mstan@horizon.io)\n/// @notice This library contains functions for reading data from bytes arrays.\n/// @dev These functions do not check if the input index is within the bounds of the data array.\n/// @dev Reading out of bounds may return dirty values.\nlibrary LibBytes {\n\n  function readFirstUint8(\n    bytes calldata _data\n  ) internal pure returns (uint8 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(_data.offset)\n      a := shr(248, word)\n      newPointer := 1\n    }\n  }\n\n  function readUint8(bytes calldata _data, uint256 _index) internal pure returns (uint8 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(248, word)\n      newPointer := add(_index, 1)\n    }\n  }\n\n  function readUint16(bytes calldata _data, uint256 _index) internal pure returns (uint16 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(240, word)\n      newPointer := add(_index, 2)\n    }\n  }\n\n  function readUint24(bytes calldata _data, uint256 _index) internal pure returns (uint24 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(232, word)\n      newPointer := add(_index, 3)\n    }\n  }\n\n  function readUint64(bytes calldata _data, uint256 _index) internal pure returns (uint64 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(192, word)\n      newPointer := add(_index, 8)\n    }\n  }\n\n  function readUint160(bytes calldata _data, uint256 _index) internal pure returns (uint160 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(96, word)\n      newPointer := add(_index, 20)\n    }\n  }\n\n  function readUint256(bytes calldata _data, uint256 _index) internal pure returns (uint256 a, uint256 newPointer) {\n    assembly {\n      a := calldataload(add(_index, _data.offset))\n      newPointer := add(_index, 32)\n    }\n  }\n\n  function readUintX(\n    bytes calldata _data,\n    uint256 _index,\n    uint256 _length\n  ) internal pure returns (uint256 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      let shift := sub(256, mul(_length, 8))\n      a := and(shr(shift, word), sub(shl(mul(8, _length), 1), 1))\n      newPointer := add(_index, _length)\n    }\n  }\n\n  function readBytes4(bytes calldata _data, uint256 _pointer) internal pure returns (bytes4 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_pointer, _data.offset))\n      a := and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n      newPointer := add(_pointer, 4)\n    }\n  }\n\n  function readBytes32(bytes calldata _data, uint256 _pointer) internal pure returns (bytes32 a, uint256 newPointer) {\n    assembly {\n      a := calldataload(add(_pointer, _data.offset))\n      newPointer := add(_pointer, 32)\n    }\n  }\n\n  function readAddress(bytes calldata _data, uint256 _index) internal pure returns (address a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := and(shr(96, word), 0xffffffffffffffffffffffffffffffffffffffff)\n      newPointer := add(_index, 20)\n    }\n  }\n\n  /// @dev ERC-2098 Compact Signature\n  function readRSVCompact(\n    bytes calldata _data,\n    uint256 _index\n  ) internal pure returns (bytes32 r, bytes32 s, uint8 v, uint256 newPointer) {\n    uint256 yParityAndS;\n    assembly {\n      r := calldataload(add(_index, _data.offset))\n      yParityAndS := calldataload(add(_index, add(_data.offset, 32)))\n      newPointer := add(_index, 64)\n    }\n    uint256 yParity = uint256(yParityAndS >> 255);\n    s = bytes32(uint256(yParityAndS) & ((1 << 255) - 1));\n    v = uint8(yParity) + 27;\n  }\n\n}\n'
      },
      'src/extensions/sessions/SessionErrors.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\n/// @title SessionErrors\n/// @author Michael Standen\n/// @notice Errors for the session manager\nlibrary SessionErrors {\n\n  /// @notice Invalid session signer\n  error InvalidSessionSigner(address invalidSigner);\n  /// @notice Invalid chainId\n  error InvalidChainId(uint256 invalidChainId);\n  /// @notice Invalid self call\n  error InvalidSelfCall();\n  /// @notice Invalid delegate call\n  error InvalidDelegateCall();\n  /// @notice Invalid value\n  error InvalidValue();\n  /// @notice Invalid node type in session configuration\n  error InvalidNodeType(uint256 flag);\n\n  // ---- Explicit session errors ----\n\n  /// @notice Missing permission for explicit session\n  error MissingPermission();\n  /// @notice Invalid permission for explicit session\n  error InvalidPermission();\n  /// @notice Session expired\n  error SessionExpired(uint256 deadline);\n  /// @notice Invalid limit usage increment\n  error InvalidLimitUsageIncrement();\n\n  // ---- Implicit session errors ----\n\n  /// @notice Blacklisted address\n  error BlacklistedAddress(address target);\n  /// @notice Invalid implicit result\n  error InvalidImplicitResult();\n  /// @notice Invalid identity signer\n  error InvalidIdentitySigner();\n  /// @notice Invalid blacklist\n  error InvalidBlacklist();\n  /// @notice Invalid attestation\n  error InvalidAttestation();\n\n}\n'
      },
      'src/extensions/sessions/SessionSig.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from "../../modules/Payload.sol";\nimport { LibBytes } from "../../utils/LibBytes.sol";\nimport { LibOptim } from "../../utils/LibOptim.sol";\nimport { SessionErrors } from "./SessionErrors.sol";\nimport { SessionPermissions } from "./explicit/IExplicitSessionManager.sol";\nimport { LibPermission, Permission } from "./explicit/Permission.sol";\nimport { Attestation, LibAttestation } from "./implicit/Attestation.sol";\n\nusing LibBytes for bytes;\nusing LibAttestation for Attestation;\n\n/// @title SessionSig\n/// @author Michael Standen, Agustin Aguilar\n/// @notice Library for session signatures\nlibrary SessionSig {\n\n  uint256 internal constant FLAG_PERMISSIONS = 0;\n  uint256 internal constant FLAG_NODE = 1;\n  uint256 internal constant FLAG_BRANCH = 2;\n  uint256 internal constant FLAG_BLACKLIST = 3;\n  uint256 internal constant FLAG_IDENTITY_SIGNER = 4;\n\n  uint256 internal constant MIN_ENCODED_PERMISSION_SIZE = 62;\n\n  /// @notice Call signature for a specific session\n  /// @param isImplicit If the call is implicit\n  /// @param sessionSigner Address of the session signer\n  /// @param sessionPermission Session permission for explicit calls\n  /// @param attestation Attestation for implicit calls\n  struct CallSignature {\n    bool isImplicit;\n    address sessionSigner;\n    uint8 sessionPermission;\n    Attestation attestation;\n  }\n\n  /// @notice Decoded signature for a specific session\n  /// @param imageHash Derived configuration image hash\n  /// @param identitySigner Identity signer address\n  /// @param implicitBlacklist Implicit blacklist addresses\n  /// @param sessionPermissions Session permissions for each explicit signer\n  /// @param callSignatures Call signatures for each call in the payload\n  struct DecodedSignature {\n    bytes32 imageHash;\n    address identitySigner;\n    address[] implicitBlacklist;\n    SessionPermissions[] sessionPermissions;\n    CallSignature[] callSignatures;\n  }\n\n  /// @notice Recovers the decoded signature from the encodedSignature bytes.\n  /// @dev The encoded layout is conceptually separated into three parts:\n  ///  1) Session Configuration\n  ///  2) A reusable list of Attestations + their identity signatures (if any implicit calls exist)\n  ///  3) Call Signatures (one per call in the payload)\n  ///\n  /// High-level layout:\n  ///  - session_configuration: [uint24 size, <Session Configuration encoded>]\n  ///  - attestation_list: [uint8 attestationCount, (Attestation + identitySig) * attestationCount]\n  ///    (new section to allow reusing the same Attestation across multiple calls)\n  ///  - call_signatures: [<CallSignature encoded>] - Size is payload.calls.length\n  ///    - call_signature: [uint8 call_flags, <session_signature>]\n  ///      - call_flags: [bool is_implicit (MSB), 7 bits encoded]\n  ///      - if call_flags.is_implicit.MSB == 1:\n  ///         - attestation_index: [uint8 index into the attestation list (7 bits of the call_flags)]\n  ///         - session_signature: [r, s, v (compact)]\n  ///      - if call_flags.is_implicit.MSB == 0:\n  ///         - session_permission: [uint8 (7 bits of the call_flags)]\n  ///         - session_signature: [r, s, v (compact)]\n  function recoverSignature(\n    Payload.Decoded calldata payload,\n    bytes calldata encodedSignature\n  ) internal view returns (DecodedSignature memory sig) {\n    uint256 pointer = 0;\n    bool hasBlacklistInConfig;\n\n    // ----- Session Configuration -----\n    {\n      // First read the length of the session configuration bytes (uint24)\n      uint256 dataSize;\n      (dataSize, pointer) = encodedSignature.readUint24(pointer);\n\n      // Recover the session configuration\n      (sig, hasBlacklistInConfig) = recoverConfiguration(encodedSignature[pointer:pointer + dataSize]);\n      pointer += dataSize;\n\n      // Identity signer must be set\n      if (sig.identitySigner == address(0)) {\n        revert SessionErrors.InvalidIdentitySigner();\n      }\n    }\n\n    // ----- Attestations for implicit calls -----\n    Attestation[] memory attestationList;\n    {\n      uint8 attestationCount;\n      (attestationCount, pointer) = encodedSignature.readUint8(pointer);\n      attestationList = new Attestation[](attestationCount);\n      // Parse each attestation and its identity signature, store in memory\n      for (uint256 i = 0; i < attestationCount; i++) {\n        Attestation memory att;\n        (att, pointer) = LibAttestation.fromPacked(encodedSignature, pointer);\n\n        // Read the identity signature that approves this attestation\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, pointer) = encodedSignature.readRSVCompact(pointer);\n\n          // Recover the identity signer from the attestation identity signature\n          bytes32 attestationHash = att.toHash();\n          address recoveredIdentitySigner = ecrecover(attestationHash, v, r, s);\n          if (recoveredIdentitySigner != sig.identitySigner) {\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n        }\n\n        attestationList[i] = att;\n      }\n\n      // If we have any implicit calls, we must have a blacklist in the configuration\n      if (attestationCount > 0 && !hasBlacklistInConfig) {\n        revert SessionErrors.InvalidBlacklist();\n      }\n    }\n\n    // ----- Call Signatures -----\n    {\n      uint256 callsCount = payload.calls.length;\n      sig.callSignatures = new CallSignature[](callsCount);\n\n      for (uint256 i = 0; i < callsCount; i++) {\n        CallSignature memory callSignature;\n\n        // Determine signature type\n        {\n          uint8 flag;\n          (flag, pointer) = encodedSignature.readUint8(pointer);\n          callSignature.isImplicit = (flag & 0x80) != 0;\n\n          if (callSignature.isImplicit) {\n            // Read attestation index from the call_flags\n            uint8 attestationIndex = uint8(flag & 0x7f);\n\n            // Check if the attestation index is out of range\n            if (attestationIndex >= attestationList.length) {\n              revert SessionErrors.InvalidAttestation();\n            }\n\n            // Set the attestation\n            callSignature.attestation = attestationList[attestationIndex];\n          } else {\n            // Session permission index is the entire byte, top bit is 0 => no conflict\n            callSignature.sessionPermission = flag;\n          }\n        }\n\n        // Read session signature and recover the signer\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, pointer) = encodedSignature.readRSVCompact(pointer);\n\n          bytes32 callHash = hashCallWithReplayProtection(payload.calls[i], payload);\n          callSignature.sessionSigner = ecrecover(callHash, v, r, s);\n          if (callSignature.sessionSigner == address(0)) {\n            revert SessionErrors.InvalidSessionSigner(address(0));\n          }\n        }\n\n        sig.callSignatures[i] = callSignature;\n      }\n    }\n\n    return sig;\n  }\n\n  /// @notice Recovers the session configuration from the encoded data.\n  /// The encoded layout is:\n  /// - permissions_count: [uint8]\n  /// - permissions_tree_element: [flag, <data>]\n  ///   - flag: [uint8]\n  ///   - data: [data]\n  ///     - if flag == FLAG_PERMISSIONS: [SessionPermissions encoded]\n  ///     - if flag == FLAG_NODE: [bytes32 node]\n  ///     - if flag == FLAG_BRANCH: [uint256 size, nested encoding...]\n  ///     - if flag == FLAG_BLACKLIST: [uint24 blacklist_count, blacklist_addresses...]\n  ///     - if flag == FLAG_IDENTITY_SIGNER: [address identity_signer]\n  /// @dev A valid configuration must have exactly one identity signer and at most one blacklist.\n  function recoverConfiguration(\n    bytes calldata encoded\n  ) internal pure returns (DecodedSignature memory sig, bool hasBlacklist) {\n    uint256 pointer;\n    uint256 permissionsCount;\n\n    // Guess maximum permissions size by bytes length\n    {\n      uint256 maxPermissionsSize = encoded.length / MIN_ENCODED_PERMISSION_SIZE;\n      sig.sessionPermissions = new SessionPermissions[](maxPermissionsSize);\n    }\n\n    while (pointer < encoded.length) {\n      // First byte is the flag (top 4 bits) and additional data (bottom 4 bits)\n      uint256 firstByte;\n      (firstByte, pointer) = encoded.readUint8(pointer);\n      // The top 4 bits are the flag\n      uint256 flag = (firstByte & 0xf0) >> 4;\n\n      // Permissions configuration (0x00)\n      if (flag == FLAG_PERMISSIONS) {\n        SessionPermissions memory nodePermissions;\n        uint256 pointerStart = pointer;\n\n        // Read signer\n        (nodePermissions.signer, pointer) = encoded.readAddress(pointer);\n\n        // Read chainId\n        (nodePermissions.chainId, pointer) = encoded.readUint256(pointer);\n\n        // Read value limit\n        (nodePermissions.valueLimit, pointer) = encoded.readUint256(pointer);\n\n        // Read deadline\n        (nodePermissions.deadline, pointer) = encoded.readUint64(pointer);\n\n        // Read permissions array\n        (nodePermissions.permissions, pointer) = _decodePermissions(encoded, pointer);\n\n        // Update root\n        {\n          bytes32 permissionHash = _leafHashForPermissions(encoded[pointerStart:pointer]);\n          sig.imageHash =\n            sig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, permissionHash) : permissionHash;\n        }\n\n        // Push node permissions to the permissions array\n        sig.sessionPermissions[permissionsCount++] = nodePermissions;\n        continue;\n      }\n\n      // Node (0x01)\n      if (flag == FLAG_NODE) {\n        // Read pre-hashed node\n        bytes32 node;\n        (node, pointer) = encoded.readBytes32(pointer);\n\n        // Update root\n        sig.imageHash = sig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, node) : node;\n\n        continue;\n      }\n\n      // Branch (0x02)\n      if (flag == FLAG_BRANCH) {\n        // Read branch size\n        uint256 size;\n        {\n          uint256 sizeSize = uint8(firstByte & 0x0f);\n          (size, pointer) = encoded.readUintX(pointer, sizeSize);\n        }\n        // Process branch\n        uint256 nrindex = pointer + size;\n        (DecodedSignature memory branchSig, bool branchHasBlacklist) = recoverConfiguration(encoded[pointer:nrindex]);\n        pointer = nrindex;\n\n        // Store the branch blacklist\n        if (branchHasBlacklist) {\n          if (hasBlacklist) {\n            // Blacklist already set\n            revert SessionErrors.InvalidBlacklist();\n          }\n          hasBlacklist = true;\n          sig.implicitBlacklist = branchSig.implicitBlacklist;\n        }\n\n        // Store the branch identity signer\n        if (branchSig.identitySigner != address(0)) {\n          if (sig.identitySigner != address(0)) {\n            // Identity signer already set\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n          sig.identitySigner = branchSig.identitySigner;\n        }\n\n        // Push all branch permissions to the permissions array\n        for (uint256 i = 0; i < branchSig.sessionPermissions.length; i++) {\n          sig.sessionPermissions[permissionsCount++] = branchSig.sessionPermissions[i];\n        }\n\n        // Update root\n        sig.imageHash =\n          sig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, branchSig.imageHash) : branchSig.imageHash;\n\n        continue;\n      }\n\n      // Blacklist (0x03)\n      if (flag == FLAG_BLACKLIST) {\n        if (hasBlacklist) {\n          // Blacklist already set\n          revert SessionErrors.InvalidBlacklist();\n        }\n        hasBlacklist = true;\n\n        // Read the blacklist count from the first byte\'s lower 4 bits\n        uint256 blacklistCount = uint256(firstByte & 0x0f);\n        if (blacklistCount == 0x0f) {\n          // If it\'s max nibble, read the next 2 bytes for the actual size\n          (blacklistCount, pointer) = encoded.readUint16(pointer);\n        }\n        uint256 pointerStart = pointer;\n\n        // Read the blacklist addresses\n        sig.implicitBlacklist = new address[](blacklistCount);\n        for (uint256 i = 0; i < blacklistCount; i++) {\n          (sig.implicitBlacklist[i], pointer) = encoded.readAddress(pointer);\n        }\n\n        // Update the root\n        bytes32 blacklistHash = _leafHashForBlacklist(encoded[pointerStart:pointer]);\n        sig.imageHash = sig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, blacklistHash) : blacklistHash;\n\n        continue;\n      }\n\n      // Identity signer (0x04)\n      if (flag == FLAG_IDENTITY_SIGNER) {\n        if (sig.identitySigner != address(0)) {\n          // Identity signer already set\n          revert SessionErrors.InvalidIdentitySigner();\n        }\n        (sig.identitySigner, pointer) = encoded.readAddress(pointer);\n\n        // Update the root\n        bytes32 identitySignerHash = _leafHashForIdentitySigner(sig.identitySigner);\n        sig.imageHash =\n          sig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, identitySignerHash) : identitySignerHash;\n\n        continue;\n      }\n\n      revert SessionErrors.InvalidNodeType(flag);\n    }\n\n    {\n      // Update the permissions array length to the actual count\n      SessionPermissions[] memory permissions = sig.sessionPermissions;\n      assembly {\n        mstore(permissions, permissionsCount)\n      }\n    }\n\n    return (sig, hasBlacklist);\n  }\n\n  /// @notice Decodes an array of Permission objects from the encoded data.\n  function _decodePermissions(\n    bytes calldata encoded,\n    uint256 pointer\n  ) internal pure returns (Permission[] memory permissions, uint256 newPointer) {\n    uint256 length;\n    (length, pointer) = encoded.readUint8(pointer);\n    permissions = new Permission[](length);\n    for (uint256 i = 0; i < length; i++) {\n      (permissions[i], pointer) = LibPermission.readPermission(encoded, pointer);\n    }\n    return (permissions, pointer);\n  }\n\n  /// @notice Hashes the encoded session permissions into a leaf node.\n  function _leafHashForPermissions(\n    bytes calldata encodedPermissions\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(uint8(FLAG_PERMISSIONS), encodedPermissions));\n  }\n\n  /// @notice Hashes the encoded blacklist into a leaf node.\n  function _leafHashForBlacklist(\n    bytes calldata encodedBlacklist\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(uint8(FLAG_BLACKLIST), encodedBlacklist));\n  }\n\n  /// @notice Hashes the identity signer into a leaf node.\n  function _leafHashForIdentitySigner(\n    address identitySigner\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(uint8(FLAG_IDENTITY_SIGNER), identitySigner));\n  }\n\n  /// @notice Hashes a call with replay protection.\n  /// @dev The replay protection is based on the chainId, space, and nonce in the payload.\n  /// @param call The call to hash\n  /// @param payload The payload to hash\n  /// @return callHash The hash of the call with replay protection\n  function hashCallWithReplayProtection(\n    Payload.Call calldata call,\n    Payload.Decoded calldata payload\n  ) public view returns (bytes32 callHash) {\n    return keccak256(\n      abi.encodePacked(payload.noChainId ? 0 : block.chainid, payload.space, payload.nonce, Payload.hashCall(call))\n    );\n  }\n\n}\n'
      },
      'src/extensions/sessions/explicit/ExplicitSessionManager.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from "../../../modules/Payload.sol";\nimport { LibBytes } from "../../../utils/LibBytes.sol";\n\nimport { SessionErrors } from "../SessionErrors.sol";\nimport { IExplicitSessionManager, SessionPermissions, SessionUsageLimits } from "./IExplicitSessionManager.sol";\nimport { Permission, UsageLimit } from "./Permission.sol";\nimport { PermissionValidator } from "./PermissionValidator.sol";\n\nabstract contract ExplicitSessionManager is IExplicitSessionManager, PermissionValidator {\n\n  using LibBytes for bytes;\n\n  /// @notice Special address used for tracking native token value limits\n  address public constant VALUE_TRACKING_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n  /// @inheritdoc IExplicitSessionManager\n  function incrementUsageLimit(\n    UsageLimit[] calldata limits\n  ) external {\n    address wallet = msg.sender;\n    for (uint256 i = 0; i < limits.length; i++) {\n      if (limits[i].usageAmount < getLimitUsage(wallet, limits[i].usageHash)) {\n        // Cannot decrement usage limit\n        revert SessionErrors.InvalidLimitUsageIncrement();\n      }\n      setLimitUsage(wallet, limits[i].usageHash, limits[i].usageAmount);\n    }\n  }\n\n  /// @notice Validates an explicit call\n  /// @param payload The decoded payload containing calls\n  /// @param callIdx The index of the call to validate\n  /// @param wallet The wallet\'s address\n  /// @param sessionSigner The session signer\'s address\n  /// @param allSessionPermissions All sessions\' permissions\n  /// @param permissionIdx The index of the permission to validate\n  /// @param sessionUsageLimits The session usage limits\n  /// @return newSessionUsageLimits The updated session usage limits\n  function _validateExplicitCall(\n    Payload.Decoded calldata payload,\n    uint256 callIdx,\n    address wallet,\n    address sessionSigner,\n    SessionPermissions[] memory allSessionPermissions,\n    uint8 permissionIdx,\n    SessionUsageLimits memory sessionUsageLimits\n  ) internal view returns (SessionUsageLimits memory newSessionUsageLimits) {\n    // Find the permissions for the given session signer\n    SessionPermissions memory sessionPermissions;\n    for (uint256 i = 0; i < allSessionPermissions.length; i++) {\n      if (allSessionPermissions[i].signer == sessionSigner) {\n        sessionPermissions = allSessionPermissions[i];\n        break;\n      }\n    }\n    if (sessionPermissions.signer == address(0)) {\n      revert SessionErrors.InvalidSessionSigner(sessionSigner);\n    }\n\n    // Check if session chainId is valid\n    if (sessionPermissions.chainId != 0 && sessionPermissions.chainId != block.chainid) {\n      revert SessionErrors.InvalidChainId(sessionPermissions.chainId);\n    }\n\n    // Check if session has expired.\n    if (sessionPermissions.deadline != 0 && block.timestamp > sessionPermissions.deadline) {\n      revert SessionErrors.SessionExpired(sessionPermissions.deadline);\n    }\n\n    // Delegate calls are not allowed\n    Payload.Call calldata call = payload.calls[callIdx];\n    if (call.delegateCall) {\n      revert SessionErrors.InvalidDelegateCall();\n    }\n\n    // Calls to incrementUsageLimit are the only allowed calls to this contract\n    if (call.to == address(this)) {\n      bytes4 selector = bytes4(call.data[0:4]);\n      if (call.value > 0 || selector != IExplicitSessionManager.incrementUsageLimit.selector) {\n        revert SessionErrors.InvalidSelfCall();\n      }\n      // No permissions required\n      return sessionUsageLimits;\n    }\n\n    // Get the permission for the current call\n    if (permissionIdx >= sessionPermissions.permissions.length) {\n      revert SessionErrors.MissingPermission();\n    }\n    Permission memory permission = sessionPermissions.permissions[permissionIdx];\n\n    // Validate the permission for the current call\n    (bool isValid, UsageLimit[] memory limits) =\n      validatePermission(permission, call, wallet, sessionSigner, sessionUsageLimits.limits);\n    if (!isValid) {\n      revert SessionErrors.InvalidPermission();\n    }\n    sessionUsageLimits.limits = limits;\n\n    // Increment the total value used\n    if (call.value > 0) {\n      sessionUsageLimits.totalValueUsed += call.value;\n    }\n    if (sessionUsageLimits.totalValueUsed > sessionPermissions.valueLimit) {\n      // Value limit exceeded\n      revert SessionErrors.InvalidValue();\n    }\n\n    return sessionUsageLimits;\n  }\n\n  /// @notice Verifies the limit usage increment\n  /// @param call The call to validate\n  /// @param sessionUsageLimits The session usage limits\n  /// @dev Reverts if the required increment call is missing or invalid\n  /// @dev If no usage limits are used, this function does nothing\n  function _validateLimitUsageIncrement(\n    Payload.Call calldata call,\n    SessionUsageLimits[] memory sessionUsageLimits\n  ) internal view {\n    // Limits call is only required if there are usage limits used\n    if (sessionUsageLimits.length > 0) {\n      // Verify the last call is the increment call\n      if (call.to != address(this) || call.behaviorOnError != Payload.BEHAVIOR_REVERT_ON_ERROR) {\n        revert SessionErrors.InvalidLimitUsageIncrement();\n      }\n\n      // Construct expected limit increments\n      uint256 totalLimitsLength = 0;\n      for (uint256 i = 0; i < sessionUsageLimits.length; i++) {\n        totalLimitsLength += sessionUsageLimits[i].limits.length;\n        if (sessionUsageLimits[i].totalValueUsed > 0) {\n          totalLimitsLength++;\n        }\n      }\n      UsageLimit[] memory limits = new UsageLimit[](totalLimitsLength);\n      uint256 limitIndex = 0;\n      for (uint256 i = 0; i < sessionUsageLimits.length; i++) {\n        for (uint256 j = 0; j < sessionUsageLimits[i].limits.length; j++) {\n          limits[limitIndex++] = sessionUsageLimits[i].limits[j];\n        }\n        if (sessionUsageLimits[i].totalValueUsed > 0) {\n          limits[limitIndex++] = UsageLimit({\n            usageHash: keccak256(abi.encode(sessionUsageLimits[i].signer, VALUE_TRACKING_ADDRESS)),\n            usageAmount: sessionUsageLimits[i].totalValueUsed\n          });\n        }\n      }\n\n      // Verify the increment call data\n      bytes memory expectedData = abi.encodeWithSelector(this.incrementUsageLimit.selector, limits);\n      bytes32 expectedDataHash = keccak256(expectedData);\n      bytes32 actualDataHash = keccak256(call.data);\n      if (actualDataHash != expectedDataHash) {\n        revert SessionErrors.InvalidLimitUsageIncrement();\n      }\n    }\n  }\n\n}\n'
      },
      'src/extensions/sessions/explicit/Permission.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibBytes } from "../../../utils/LibBytes.sol";\n\n/// @notice Permission for a specific session signer\n/// @param target Address of the target contract this permission applies to\n/// @param rules Array of parameter rules\nstruct Permission {\n  address target;\n  ParameterRule[] rules;\n}\n\n/// @notice Parameter operation for a specific session signer\nenum ParameterOperation {\n  EQUAL,\n  NOT_EQUAL,\n  GREATER_THAN_OR_EQUAL,\n  LESS_THAN_OR_EQUAL\n}\n\n/// @notice Parameter rule for a specific session signer\n/// @param cumulative If the value should accumulate over multiple calls\n/// @param operation Operation to apply to the parameter\n/// @param value Value to compare against the masked parameter\n/// @param offset Offset in calldata to read the parameter\n/// @param mask Mask to apply to the parameter\nstruct ParameterRule {\n  bool cumulative;\n  ParameterOperation operation;\n  bytes32 value;\n  uint256 offset;\n  bytes32 mask;\n}\n\n/// @notice Usage limit for a specific session signer\n/// @param usageHash Usage identifier\n/// @param usageAmount Amount of usage\nstruct UsageLimit {\n  bytes32 usageHash;\n  uint256 usageAmount;\n}\n\nusing LibBytes for bytes;\n\n/// @title LibPermission\n/// @author Michael Standen\n/// @notice Library for permission management\nlibrary LibPermission {\n\n  /// @notice Error thrown when the rules length exceeds the maximum\n  error RulesLengthExceedsMax();\n\n  /// @notice Reads a permission from a packed bytes array\n  /// @param encoded The packed bytes array\n  /// @param pointer The pointer to the start of the permission\n  /// @return permission The decoded permission\n  /// @return newPointer The new pointer to the end of the permission\n  function readPermission(\n    bytes calldata encoded,\n    uint256 pointer\n  ) internal pure returns (Permission memory permission, uint256 newPointer) {\n    // Target\n    (permission.target, pointer) = encoded.readAddress(pointer);\n    // Rules\n    uint256 rulesLength;\n    (rulesLength, pointer) = encoded.readUint8(pointer);\n    permission.rules = new ParameterRule[](rulesLength);\n    for (uint256 i = 0; i < rulesLength; i++) {\n      uint8 operationCumulative;\n      (operationCumulative, pointer) = encoded.readUint8(pointer);\n      // 000X: cumulative\n      permission.rules[i].cumulative = operationCumulative & 1 != 0;\n      // XXX0: operation\n      permission.rules[i].operation = ParameterOperation(operationCumulative >> 1);\n\n      (permission.rules[i].value, pointer) = encoded.readBytes32(pointer);\n      (permission.rules[i].offset, pointer) = encoded.readUint256(pointer);\n      (permission.rules[i].mask, pointer) = encoded.readBytes32(pointer);\n    }\n    return (permission, pointer);\n  }\n\n  /// @notice Encodes a permission into a packed bytes array\n  /// @param permission The permission to encode\n  /// @return packed The packed bytes array\n  function toPacked(\n    Permission calldata permission\n  ) internal pure returns (bytes memory packed) {\n    if (permission.rules.length > type(uint8).max) {\n      revert RulesLengthExceedsMax();\n    }\n    packed = abi.encodePacked(permission.target, uint8(permission.rules.length));\n    for (uint256 i = 0; i < permission.rules.length; i++) {\n      packed = abi.encodePacked(packed, ruleToPacked(permission.rules[i]));\n    }\n  }\n\n  /// @notice Encodes a rule into a packed bytes array\n  /// @param rule The rule to encode\n  /// @return packed The packed bytes array\n  function ruleToPacked(\n    ParameterRule calldata rule\n  ) internal pure returns (bytes memory packed) {\n    // Combine operation and cumulative flag into a single byte\n    // 0x[operationx3][cumulative]\n    uint8 operationCumulative = (uint8(rule.operation) << 1) | (rule.cumulative ? 1 : 0);\n\n    return abi.encodePacked(operationCumulative, rule.value, rule.offset, rule.mask);\n  }\n\n}\n'
      },
      'src/extensions/sessions/implicit/ImplicitSessionManager.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from "../../../modules/Payload.sol";\n\nimport { SessionErrors } from "../SessionErrors.sol";\nimport { Attestation, LibAttestation } from "./Attestation.sol";\nimport { ISignalsImplicitMode } from "./ISignalsImplicitMode.sol";\n\nusing LibAttestation for Attestation;\n\n/// @title ImplicitSessionManager\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Manager for implicit sessions\nabstract contract ImplicitSessionManager {\n\n  /// @notice Validates a call in implicit mode\n  /// @param call The call to validate\n  /// @param wallet The wallet\'s address\n  /// @param sessionSigner The session signer\'s address\n  /// @param attestation The session attestation\n  function _validateImplicitCall(\n    Payload.Call calldata call,\n    address wallet,\n    address sessionSigner,\n    Attestation memory attestation,\n    address[] memory blacklist\n  ) internal view {\n    // Validate the session signer is attested\n    if (sessionSigner != attestation.approvedSigner) {\n      revert SessionErrors.InvalidSessionSigner(sessionSigner);\n    }\n\n    // Delegate calls are not allowed\n    if (call.delegateCall) {\n      revert SessionErrors.InvalidDelegateCall();\n    }\n    // Check if the signer is blacklisted\n    if (_isAddressBlacklisted(sessionSigner, blacklist)) {\n      revert SessionErrors.BlacklistedAddress(sessionSigner);\n    }\n    // Check if the target address is blacklisted\n    if (_isAddressBlacklisted(call.to, blacklist)) {\n      revert SessionErrors.BlacklistedAddress(call.to);\n    }\n    // No value\n    if (call.value > 0) {\n      revert SessionErrors.InvalidValue();\n    }\n\n    // Validate the implicit request\n    bytes32 result = ISignalsImplicitMode(call.to).acceptImplicitRequest(wallet, attestation, call);\n    bytes32 attestationMagic = attestation.generateImplicitRequestMagic(wallet);\n    if (result != attestationMagic) {\n      revert SessionErrors.InvalidImplicitResult();\n    }\n  }\n\n  /// @notice Checks if an address is in the blacklist using binary search\n  /// @param target The address to check\n  /// @param blacklist The sorted array of blacklisted addresses\n  /// @return bool True if the address is blacklisted, false otherwise\n  function _isAddressBlacklisted(address target, address[] memory blacklist) internal pure returns (bool) {\n    int256 left = 0;\n    int256 right = int256(blacklist.length) - 1;\n\n    while (left <= right) {\n      int256 mid = left + (right - left) / 2;\n      address currentAddress = blacklist[uint256(mid)];\n\n      if (currentAddress == target) {\n        return true;\n      } else if (currentAddress < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n\n    return false;\n  }\n\n}\n'
      },
      'src/utils/LibOptim.sol': {
        content:
          "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\n/// @title LibOptim\n/// @author Agustin Aguilar\n/// @notice Library for optimized EVM operations\nlibrary LibOptim {\n\n  /**\n   * @notice Computes the keccak256 hash of two 32-byte inputs.\n   * @dev It uses only scratch memory space.\n   * @param _a The first 32 bytes of the hash.\n   * @param _b The second 32 bytes of the hash.\n   * @return c The keccak256 hash of the two 32-byte inputs.\n   */\n  function fkeccak256(bytes32 _a, bytes32 _b) internal pure returns (bytes32 c) {\n    assembly {\n      mstore(0, _a)\n      mstore(32, _b)\n      c := keccak256(0, 64)\n    }\n  }\n\n  /**\n   * @notice Returns the return data from the last call.\n   * @return r The return data from the last call.\n   */\n  function returnData() internal pure returns (bytes memory r) {\n    assembly {\n      let size := returndatasize()\n      r := mload(0x40)\n      let start := add(r, 32)\n      mstore(0x40, add(start, size))\n      mstore(r, size)\n      returndatacopy(start, 0, size)\n    }\n  }\n\n  /**\n   * @notice Calls another contract with the given parameters.\n   * @dev This method doesn't increase the memory pointer.\n   * @param _to The address of the contract to call.\n   * @param _val The value to send to the contract.\n   * @param _gas The amount of gas to provide for the call.\n   * @param _data The data to send to the contract.\n   * @return r The success status of the call.\n   */\n  function call(address _to, uint256 _val, uint256 _gas, bytes memory _data) internal returns (bool r) {\n    assembly {\n      r := call(_gas, _to, _val, add(_data, 32), mload(_data), 0, 0)\n    }\n  }\n\n  /**\n   * @notice Calls another contract with the given parameters, using delegatecall.\n   * @dev This method doesn't increase the memory pointer.\n   * @param _to The address of the contract to call.\n   * @param _gas The amount of gas to provide for the call.\n   * @param _data The data to send to the contract.\n   * @return r The success status of the call.\n   */\n  function delegatecall(address _to, uint256 _gas, bytes memory _data) internal returns (bool r) {\n    assembly {\n      r := delegatecall(_gas, _to, add(_data, 32), mload(_data), 0, 0)\n    }\n  }\n\n}\n"
      },
      'src/extensions/sessions/explicit/IExplicitSessionManager.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Permission, UsageLimit } from "./Permission.sol";\n\n/// @notice Permissions configuration for a specific session signer\n/// @param signer Address of the session signer these permissions apply to\n/// @param chainId Chain ID of the session (0 = any chain)\n/// @param valueLimit Maximum native token value this signer can send\n/// @param deadline Deadline for the session. (0 = no deadline)\n/// @param permissions Array of encoded permissions granted to this signer\nstruct SessionPermissions {\n  address signer;\n  uint256 chainId;\n  uint256 valueLimit;\n  uint64 deadline;\n  Permission[] permissions;\n}\n\n/// @notice Usage limits configuration for a specific session signer\n/// @param signer Address of the session signer these limits apply to\n/// @param limits Array of usage limits\n/// @param totalValueUsed Total native token value used\nstruct SessionUsageLimits {\n  address signer;\n  UsageLimit[] limits;\n  uint256 totalValueUsed;\n}\n\n/// @title IExplicitSessionManager\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Interface for the explicit session manager\ninterface IExplicitSessionManager {\n\n  /// @notice Increment usage for a caller\'s given session and target\n  /// @param limits Array of limit/session/target combinations\n  function incrementUsageLimit(\n    UsageLimit[] calldata limits\n  ) external;\n\n}\n'
      },
      'src/extensions/sessions/implicit/Attestation.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibBytes } from "../../../utils/LibBytes.sol";\nimport { ACCEPT_IMPLICIT_REQUEST_MAGIC_PREFIX } from "./ISignalsImplicitMode.sol";\n\nusing LibBytes for bytes;\n\n/// @notice Attestation for a specific session\n/// @param approvedSigner Address of the approved signer\n/// @param identityType Identity type\n/// @param issuerHash Hash of the issuer\n/// @param audienceHash Hash of the audience\n/// @param applicationData Unspecified application data\n/// @param authData Auth data\nstruct Attestation {\n  address approvedSigner;\n  bytes4 identityType;\n  bytes32 issuerHash;\n  bytes32 audienceHash;\n  bytes applicationData;\n  AuthData authData;\n}\n\n/// @notice Auth data for an attestation\n/// @param redirectUrl Authorization redirect URL\n/// @param issuedAt Timestamp of the attestation issuance\nstruct AuthData {\n  string redirectUrl;\n  uint64 issuedAt;\n}\n\n/// @title LibAttestation\n/// @author Michael Standen\n/// @notice Library for attestation management\nlibrary LibAttestation {\n\n  /// @notice Hashes an attestation\n  function toHash(\n    Attestation memory attestation\n  ) internal pure returns (bytes32) {\n    return keccak256(toPacked(attestation));\n  }\n\n  /// @notice Decodes an attestation from a packed bytes array\n  /// @param encoded The packed bytes array\n  /// @param pointer The pointer to the start of the attestation\n  /// @return attestation The decoded attestation\n  /// @return newPointer The new pointer to the end of the attestation\n  function fromPacked(\n    bytes calldata encoded,\n    uint256 pointer\n  ) internal pure returns (Attestation memory attestation, uint256 newPointer) {\n    newPointer = pointer;\n    (attestation.approvedSigner, newPointer) = encoded.readAddress(newPointer);\n    (attestation.identityType, newPointer) = encoded.readBytes4(newPointer);\n    (attestation.issuerHash, newPointer) = encoded.readBytes32(newPointer);\n    (attestation.audienceHash, newPointer) = encoded.readBytes32(newPointer);\n    // Application data (arbitrary bytes)\n    uint256 dataSize;\n    (dataSize, newPointer) = encoded.readUint24(newPointer);\n    attestation.applicationData = encoded[newPointer:newPointer + dataSize];\n    newPointer += dataSize;\n    // Auth data\n    (attestation.authData, newPointer) = fromPackedAuthData(encoded, newPointer);\n    return (attestation, newPointer);\n  }\n\n  /// @notice Decodes the auth data from a packed bytes\n  /// @param encoded The packed bytes containing the auth data\n  /// @param pointer The pointer to the start of the auth data within the encoded data\n  /// @return authData The decoded auth data\n  /// @return newPointer The pointer to the end of the auth data within the encoded data\n  function fromPackedAuthData(\n    bytes calldata encoded,\n    uint256 pointer\n  ) internal pure returns (AuthData memory authData, uint256 newPointer) {\n    uint24 redirectUrlLength;\n    (redirectUrlLength, pointer) = encoded.readUint24(pointer);\n    authData.redirectUrl = string(encoded[pointer:pointer + redirectUrlLength]);\n    pointer += redirectUrlLength;\n    (authData.issuedAt, pointer) = encoded.readUint64(pointer);\n    return (authData, pointer);\n  }\n\n  /// @notice Encodes an attestation into a packed bytes array\n  /// @param attestation The attestation to encode\n  /// @return encoded The packed bytes array\n  function toPacked(\n    Attestation memory attestation\n  ) internal pure returns (bytes memory encoded) {\n    return abi.encodePacked(\n      attestation.approvedSigner,\n      attestation.identityType,\n      attestation.issuerHash,\n      attestation.audienceHash,\n      uint24(attestation.applicationData.length),\n      attestation.applicationData,\n      toPackAuthData(attestation.authData)\n    );\n  }\n\n  /// @notice Encodes the auth data into a packed bytes array\n  /// @param authData The auth data to encode\n  /// @return encoded The packed bytes array\n  function toPackAuthData(\n    AuthData memory authData\n  ) internal pure returns (bytes memory encoded) {\n    return abi.encodePacked(uint24(bytes(authData.redirectUrl).length), bytes(authData.redirectUrl), authData.issuedAt);\n  }\n\n  /// @notice Generates the implicit request magic return value\n  /// @param attestation The attestation\n  /// @param wallet The wallet\n  /// @return magic The expected implicit request magic\n  function generateImplicitRequestMagic(Attestation memory attestation, address wallet) internal pure returns (bytes32) {\n    return keccak256(\n      abi.encodePacked(ACCEPT_IMPLICIT_REQUEST_MAGIC_PREFIX, wallet, attestation.audienceHash, attestation.issuerHash)\n    );\n  }\n\n}\n'
      },
      'src/extensions/sessions/explicit/PermissionValidator.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from "../../../modules/Payload.sol";\nimport { LibBytes } from "../../../utils/LibBytes.sol";\nimport { ParameterOperation, ParameterRule, Permission, UsageLimit } from "./Permission.sol";\n\n/// @title PermissionValidator\n/// @author Michael Standen, Agustin Aguilar\n/// @notice Validates permissions for a given call\nabstract contract PermissionValidator {\n\n  using LibBytes for bytes;\n\n  /// @notice Emitted when the usage amount for a given wallet and usage hash is updated\n  event LimitUsageUpdated(address wallet, bytes32 usageHash, uint256 usageAmount);\n\n  /// @notice Mapping of usage limit hashes to their usage amounts\n  mapping(address => mapping(bytes32 => uint256)) private limitUsage;\n\n  /// @notice Get the usage amount for a given usage hash and wallet\n  /// @param wallet The wallet address\n  /// @param usageHash The usage hash\n  /// @return The usage amount\n  function getLimitUsage(address wallet, bytes32 usageHash) public view returns (uint256) {\n    return limitUsage[wallet][usageHash];\n  }\n\n  /// @notice Set the usage amount for a given usage hash and wallet\n  /// @param wallet The wallet address\n  /// @param usageHash The usage hash\n  /// @param usageAmount The usage amount\n  function setLimitUsage(address wallet, bytes32 usageHash, uint256 usageAmount) internal {\n    limitUsage[wallet][usageHash] = usageAmount;\n    emit LimitUsageUpdated(wallet, usageHash, usageAmount);\n  }\n\n  /// @notice Validates a rules permission\n  /// @param permission The rules permission to validate\n  /// @param call The call to validate against\n  /// @param wallet The wallet address\n  /// @param signer The signer address\n  /// @param usageLimits Array of current usage limits\n  /// @return True if the permission is valid, false otherwise\n  /// @return newUsageLimits New array of usage limits\n  function validatePermission(\n    Permission memory permission,\n    Payload.Call calldata call,\n    address wallet,\n    address signer,\n    UsageLimit[] memory usageLimits\n  ) public view returns (bool, UsageLimit[] memory newUsageLimits) {\n    if (permission.target != call.to) {\n      return (false, usageLimits);\n    }\n\n    // Copy usage limits into array with space for new rules\n    newUsageLimits = new UsageLimit[](usageLimits.length + permission.rules.length);\n    for (uint256 i = 0; i < usageLimits.length; i++) {\n      newUsageLimits[i] = usageLimits[i];\n    }\n    uint256 actualLimitsCount = usageLimits.length;\n\n    // Check each rule\n    for (uint256 i = 0; i < permission.rules.length; i++) {\n      ParameterRule memory rule = permission.rules[i];\n\n      // Extract value from calldata at offset\n      (bytes32 value,) = call.data.readBytes32(rule.offset);\n\n      // Apply mask\n      value = value & rule.mask;\n\n      if (rule.cumulative) {\n        // Calculate cumulative usage\n        uint256 value256 = uint256(value);\n        // Find the usage limit for the current rule\n        bytes32 usageHash = keccak256(abi.encode(signer, permission, i));\n        uint256 previousUsage;\n        UsageLimit memory usageLimit;\n        for (uint256 j = 0; j < newUsageLimits.length; j++) {\n          if (newUsageLimits[j].usageHash == bytes32(0)) {\n            // Initialize new usage limit\n            usageLimit = UsageLimit({ usageHash: usageHash, usageAmount: 0 });\n            newUsageLimits[j] = usageLimit;\n            actualLimitsCount = j + 1;\n            break;\n          }\n          if (newUsageLimits[j].usageHash == usageHash) {\n            // Value exists, use it\n            usageLimit = newUsageLimits[j];\n            previousUsage = usageLimit.usageAmount;\n            break;\n          }\n        }\n        if (previousUsage == 0) {\n          // Not in current payload, use storage\n          previousUsage = getLimitUsage(wallet, usageHash);\n        }\n        // Cumulate usage\n        value256 += previousUsage;\n        usageLimit.usageAmount = value256;\n        // Use the cumulative value for comparison\n        value = bytes32(value256);\n      }\n\n      // Compare based on operation\n      if (rule.operation == ParameterOperation.EQUAL) {\n        if (value != rule.value) {\n          return (false, usageLimits);\n        }\n      } else if (rule.operation == ParameterOperation.LESS_THAN_OR_EQUAL) {\n        if (uint256(value) > uint256(rule.value)) {\n          return (false, usageLimits);\n        }\n      } else if (rule.operation == ParameterOperation.NOT_EQUAL) {\n        if (value == rule.value) {\n          return (false, usageLimits);\n        }\n      } else if (rule.operation == ParameterOperation.GREATER_THAN_OR_EQUAL) {\n        if (uint256(value) < uint256(rule.value)) {\n          return (false, usageLimits);\n        }\n      }\n    }\n\n    // Fix array length\n    assembly {\n      mstore(newUsageLimits, actualLimitsCount)\n    }\n\n    return (true, newUsageLimits);\n  }\n\n}\n'
      },
      'src/extensions/sessions/implicit/ISignalsImplicitMode.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from "../../../modules/Payload.sol";\nimport { Attestation } from "./Attestation.sol";\n\n/// @dev Magic prefix for the implicit request\nbytes32 constant ACCEPT_IMPLICIT_REQUEST_MAGIC_PREFIX = keccak256(abi.encodePacked("acceptImplicitRequest"));\n\n/// @title ISignalsImplicitMode\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Interface for the contracts that support implicit mode validation\ninterface ISignalsImplicitMode {\n\n  /// @notice Determines if an implicit request is valid\n  /// @param wallet The wallet\'s address\n  /// @param attestation The attestation data\n  /// @param call The call to validate\n  /// @return magic The hash of the implicit request if valid\n  function acceptImplicitRequest(\n    address wallet,\n    Attestation calldata attestation,\n    Payload.Call calldata call\n  ) external view returns (bytes32 magic);\n\n}\n'
      }
    },
    settings: {
      remappings: [
        '@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/',
        'erc2470-libs/=lib/erc2470-libs/',
        'erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/',
        'forge-std/=lib/forge-std/src/',
        'halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/',
        'openzeppelin-contracts/=lib/openzeppelin-contracts/'
      ],
      optimizer: {
        enabled: false,
        runs: 200
      },
      metadata: {
        useLiteralContent: false,
        bytecodeHash: 'ipfs',
        appendCBOR: true
      },
      outputSelection: {
        '*': {
          '*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']
        }
      },
      evmVersion: 'cancun',
      viaIR: false,
      libraries: {}
    }
  }
}
