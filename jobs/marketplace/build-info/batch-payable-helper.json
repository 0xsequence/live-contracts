{
	"id": "118023c5ff370ab1adedbfda89f7b1b4",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.19",
	"solcLongVersion": "0.8.19+commit.7dd6d404",
	"input": {
		"language": "Solidity",
		"settings": {
			"remappings": [
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"@0xsequence/erc20-meta-token/=lib/0xsequence/erc20-meta-token/src/",
				"@0xsequence/erc-1155/=lib/0xsequence/erc-1155/src/",
				"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
				"@openzeppelin/contracts/=lib/openzeppelin/contracts/",
				"@uniswap/lib/=lib/uniswap-lib/",
				"0xsequence/=lib/0xsequence/",
				"erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/",
				"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
				"openzeppelin/=lib/openzeppelin/",
				"uniswap-lib/=lib/uniswap-lib/contracts/"
			],
			"optimizer": {
				"enabled": true,
				"runs": 200
			},
			"metadata": {
				"useLiteralContent": true,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"*": {
					"*": [
						"evm.bytecode",
						"evm.deployedBytecode",
						"devdoc",
						"userdoc",
						"metadata",
						"abi"
					]
				}
			},
			"evmVersion": "paris",
			"viaIR": true,
			"libraries": {}
		},
		"sources": {
			"contracts/BatchPayableHelper.sol": {
				"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\nimport {ISequenceMarketFunctions} from \"./interfaces/ISequenceMarket.sol\";\n\nerror InvalidBatchRequest();\n\ncontract BatchPayableHelper {\n  /**\n   * Accepts requests.\n   * @param market The market to accept requests on.\n   * @param requestIds The IDs of the requests.\n   * @param quantities The quantities of tokens to accept.\n   * @param recipients The recipients of the accepted tokens.\n   * @param additionalFees The additional fees to pay.\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\n   * @dev Additional fees are applied to each request.\n   */\n  function acceptRequestBatch(\n    ISequenceMarketFunctions market,\n    uint256[] calldata requestIds,\n    uint256[] calldata quantities,\n    address[] calldata recipients,\n    uint256[] calldata additionalFees,\n    address[] calldata additionalFeeRecipients\n  ) external payable {\n    if (requestIds.length != quantities.length || requestIds.length != recipients.length) {\n      revert InvalidBatchRequest();\n    }\n\n    for (uint256 i = 0; i < requestIds.length; i++) {\n      market.acceptRequest{value: address(this).balance}(\n        requestIds[i], quantities[i], recipients[i], additionalFees, additionalFeeRecipients\n      );\n    }\n\n    // Return any remaining ETH\n    if (address(this).balance > 0) {\n      payable(msg.sender).transfer(address(this).balance);\n    }\n  }\n\n  receive() external payable {}\n}\n"
			},
			"contracts/interfaces/ISequenceMarket.sol": {
				"content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.19;\n\ninterface ISequenceMarketStorage {\n  /**\n   * Request parameters.\n   * @param isListing True if the request is a listing, false if it is an offer.\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\n   * @param tokenContract The address of the token contract.\n   * @param tokenId The ID of the token.\n   * @param quantity The quantity of tokens.\n   * @param expiry The expiry of the request.\n   * @param currency The address of the currency. address(0) for native token.\n   * @param pricePerToken The price per token, including royalty fees.\n   */\n  struct RequestParams {\n    bool isListing;\n    bool isERC1155;\n    address tokenContract;\n    uint256 tokenId;\n    uint256 quantity;\n    uint96 expiry;\n    address currency;\n    uint256 pricePerToken;\n  }\n\n  /**\n   * Request storage.\n   * @param creator The address of the request creator.\n   * @param isListing True if the request is a listing, false if it is an offer.\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\n   * @param tokenContract The address of the token contract.\n   * @param tokenId The ID of the token.\n   * @param quantity The quantity of tokens.\n   * @param expiry The expiry of the request.\n   * @param currency The address of the currency. address(0) for native token.\n   * @param pricePerToken The price per token, including royalty fees.\n   */\n  struct Request {\n    address creator;\n    bool isListing;\n    bool isERC1155;\n    address tokenContract;\n    uint256 tokenId;\n    uint256 quantity;\n    uint96 expiry;\n    address currency;\n    uint256 pricePerToken;\n  }\n\n  /**\n   * Custom royalty parameters.\n   * @param recipient Address to send the fees to.\n   * @param fee Fee percentage with a 10000 basis (e.g. 0.3% is 30 and 1% is 100 and 100% is 10000).\n   * @dev Used to store custom royalty settings for contracts do not support ERC2981.\n   */\n  struct CustomRoyalty {\n    address recipient;\n    uint96 fee;\n  }\n}\n\ninterface ISequenceMarketFunctions is ISequenceMarketStorage {\n  /**\n   * Creates a request.\n   * @param request The request's details.\n   * @return requestId The ID of the request.\n   * @notice A listing is when the maker is selling tokens for currency.\n   * @notice An offer is when the maker is buying tokens with currency.\n   */\n  function createRequest(RequestParams calldata request) external returns (uint256 requestId);\n\n  /**\n   * Creates requests.\n   * @param requests The requests' details.\n   * @return requestIds The IDs of the requests.\n   */\n  function createRequestBatch(RequestParams[] calldata requests) external returns (uint256[] memory requestIds);\n\n  /**\n   * Accepts a request.\n   * @param requestId The ID of the request.\n   * @param quantity The quantity of tokens to accept.\n   * @param recipient The recipient of the accepted tokens.\n   * @param additionalFees The additional fees to pay.\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\n   */\n  function acceptRequest(\n    uint256 requestId,\n    uint256 quantity,\n    address recipient,\n    uint256[] calldata additionalFees,\n    address[] calldata additionalFeeRecipients\n  )\n    external payable;\n\n  /**\n   * Accepts requests.\n   * @param requestIds The IDs of the requests.\n   * @param quantities The quantities of tokens to accept.\n   * @param recipients The recipients of the accepted tokens.\n   * @param additionalFees The additional fees to pay.\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\n   * @dev Additional fees are applied to each request.\n   */\n  function acceptRequestBatch(\n    uint256[] calldata requestIds,\n    uint256[] calldata quantities,\n    address[] calldata recipients,\n    uint256[] calldata additionalFees,\n    address[] calldata additionalFeeRecipients\n  )\n    external;\n\n  /**\n   * Cancels a request.\n   * @param requestId The ID of the request.\n   */\n  function cancelRequest(uint256 requestId) external;\n\n  /**\n   * Cancels requests.\n   * @param requestIds The IDs of the requests.\n   */\n  function cancelRequestBatch(uint256[] calldata requestIds) external;\n\n  /**\n   * Gets a request.\n   * @param requestId The ID of the request.\n   * @return request The request.\n   */\n  function getRequest(uint256 requestId) external view returns (Request memory request);\n\n  /**\n   * Gets requests.\n   * @param requestIds The IDs of the requests.\n   * @return requests The requests.\n   */\n  function getRequestBatch(uint256[] calldata requestIds) external view returns (Request[] memory requests);\n\n  /**\n   * Invalidates all current requests for the msg.sender.\n   */\n  function invalidateRequests() external;\n\n  /**\n   * Invalidates all current requests for a given `tokenContract` for the msg.sender.\n   */\n  function invalidateRequests(address tokenContract) external;\n\n  /**\n   * Checks if a request is valid.\n   * @param requestId The ID of the request.\n   * @param quantity The amount of tokens to exchange. 0 is assumed to be the request's available quantity.\n   * @return valid The validity of the request.\n   * @return request The request.\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\n   */\n  function isRequestValid(uint256 requestId, uint256 quantity) external view returns (bool valid, Request memory request);\n\n  /**\n   * Checks if requests are valid.\n   * @param requestIds The IDs of the requests.\n   * @param quantities The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.\n   * @return valid The validities of the requests.\n   * @return requests The requests.\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\n   */\n  function isRequestValidBatch(uint256[] calldata requestIds, uint256[] calldata quantities)\n    external\n    view\n    returns (bool[] memory valid, Request[] memory requests);\n\n  /**\n   * Returns the royalty details for the given token and cost.\n   * @param tokenContract Address of the token being traded.\n   * @param tokenId The ID of the token.\n   * @param cost Amount of currency sent/received for the trade.\n   * @return recipient Address to send royalties to.\n   * @return royalty Amount of currency to be paid as royalties.\n   */\n  function getRoyaltyInfo(address tokenContract, uint256 tokenId, uint256 cost)\n    external\n    view\n    returns (address recipient, uint256 royalty);\n}\n\ninterface ISequenceMarketSignals {\n  //\n  // Events\n  //\n\n  /// Emitted when a request is created.\n  event RequestCreated(\n    uint256 indexed requestId,\n    address indexed creator,\n    address indexed tokenContract,\n    uint256 tokenId,\n    bool isListing,\n    uint256 quantity,\n    address currency,\n    uint256 pricePerToken,\n    uint256 expiry\n  );\n\n  /// Emitted when a request is accepted.\n  event RequestAccepted(\n    uint256 indexed requestId,\n    address indexed buyer,\n    address indexed tokenContract,\n    address recipient,\n    uint256 quantity,\n    uint256 quantityRemaining\n  );\n\n  /// Emitted when a request is cancelled.\n  event RequestCancelled(uint256 indexed requestId, address indexed tokenContract);\n\n  /// Emitted when a user bulk invalidates requests.\n  event RequestsInvalidated(address indexed creator, uint256 indexed invalidatedBefore);\n\n  /// Emitted when a user bulk invalidates requests.\n  event RequestsInvalidated(address indexed creator, address indexed tokenContract, uint256 indexed invalidatedBefore);\n\n  /// Emitted when custom royalty settings are changed.\n  event CustomRoyaltyChanged(address indexed tokenContract, address recipient, uint96 fee);\n\n  //\n  // Errors\n  //\n\n  /// Thrown when the contract address does not support the required interface.\n  error UnsupportedContractInterface(address contractAddress, bytes4 interfaceId);\n\n  /// Thrown when the token approval is invalid.\n  error InvalidTokenApproval(address tokenContract, uint256 tokenId, uint256 quantity, address owner);\n\n  /// Thrown when the currency address is invalid.\n  error InvalidCurrency();\n\n  /// Thrown when the currency approval is invalid.\n  error InvalidCurrencyApproval(address currency, uint256 quantity, address owner);\n\n  /// Thrown when request id is invalid.\n  error InvalidRequestId(uint256 requestId);\n\n  /// Thrown when the parameters of a batch accept request are invalid.\n  error InvalidBatchRequest();\n\n  /// Thrown when quantity is invalid.\n  error InvalidQuantity();\n\n  /// Thrown when price is invalid.\n  error InvalidPrice();\n\n  /// Thrown when royalty is invalid.\n  error InvalidRoyalty();\n\n  /// Thrown when expiry is invalid.\n  error InvalidExpiry();\n\n  /// Thrown when request has been explicitly invalidated.\n  error Invalidated();\n\n  /// Thrown when the additional fees are invalid.\n  error InvalidAdditionalFees();\n}\n\n// solhint-disable-next-line no-empty-blocks\ninterface ISequenceMarket is ISequenceMarketFunctions, ISequenceMarketSignals {}\n"
			}
		}
	},
	"output": {
		"contracts": {
			"contracts/BatchPayableHelper.sol": {
				"BatchPayableHelper": {
					"abi": [
						{
							"inputs": [],
							"name": "InvalidBatchRequest",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "contract ISequenceMarketFunctions",
									"name": "market",
									"type": "address"
								},
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								},
								{
									"internalType": "uint256[]",
									"name": "quantities",
									"type": "uint256[]"
								},
								{
									"internalType": "address[]",
									"name": "recipients",
									"type": "address[]"
								},
								{
									"internalType": "uint256[]",
									"name": "additionalFees",
									"type": "uint256[]"
								},
								{
									"internalType": "address[]",
									"name": "additionalFeeRecipients",
									"type": "address[]"
								}
							],
							"name": "acceptRequestBatch",
							"outputs": [],
							"stateMutability": "payable",
							"type": "function"
						},
						{
							"stateMutability": "payable",
							"type": "receive"
						}
					],
					"devdoc": {
						"kind": "dev",
						"methods": {
							"acceptRequestBatch(address,uint256[],uint256[],address[],uint256[],address[])": {
								"details": "Additional fees are applied to each request.",
								"params": {
									"additionalFeeRecipients": "The addresses to send the additional fees to.",
									"additionalFees": "The additional fees to pay.",
									"market": "The market to accept requests on.",
									"quantities": "The quantities of tokens to accept.",
									"recipients": "The recipients of the accepted tokens.",
									"requestIds": "The IDs of the requests."
								}
							}
						},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "6080806040523461001657610360908161001c8239f35b600080fdfe6080604052600436101561001b575b361561001957600080fd5b005b60003560e01c638c7080c90361000e5760c03660031901126102b3576004356001600160a01b03811681036102b35760243567ffffffffffffffff81116102b35761006a9036906004016102d3565b909160443567ffffffffffffffff81116102b35761008c9036906004016102d3565b93909260643567ffffffffffffffff81116102b3576100af9036906004016102d3565b959060843567ffffffffffffffff81116102b3576100d19036906004016102d3565b9167ffffffffffffffff60a435116102b3576100f23660a4356004016102d3565b9490958181148015906102c9575b6102b85760005b818110610142574761011557005b600080808047818115610139575b3390f11561012d57005b6040513d6000823e3d90fd5b506108fc610123565b8a898d61016984610161818961015a828b4799610304565b3597610304565b359289610304565b35906001600160a01b03821682036102b3576001600160a01b038e163b156102b35760405163735eb90760e11b8152600481019490945260248401526001600160a01b0316604483015260a0606483015260a482018890526001600160fb1b0388116102b357818c60e48a60051b8c60c491808d84880137850191820160c086840301608487015252018c60005b8d811061027757506000949184900392849291506001600160a01b03165af1801561012d57610249575b50600019811461023357600101610107565b634e487b7160e01b600052601160045260246000fd5b67ffffffffffffffff81116102615760405238610221565b634e487b7160e01b600052604160045260246000fd5b90935091508235906001600160a01b03821682036102b3576001600160a01b03909116815284928f9260209283019291909101906001016101f7565b600080fd5b6355ca07b760e11b60805260046080fd5b508a811415610100565b9181601f840112156102b35782359167ffffffffffffffff83116102b3576020808501948460051b0101116102b357565b91908110156103145760051b0190565b634e487b7160e01b600052603260045260246000fdfea26469706673582212203d65e458361e6ed154313c1fee4d625f6539a08b82ac3d52e9e20033e8b8691c64736f6c63430008130033",
							"opcodes": "PUSH1 0x80 DUP1 PUSH1 0x40 MSTORE CALLVALUE PUSH2 0x16 JUMPI PUSH2 0x360 SWAP1 DUP2 PUSH2 0x1C DUP3 CODECOPY RETURN JUMPDEST PUSH1 0x0 DUP1 REVERT INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT ISZERO PUSH2 0x1B JUMPI JUMPDEST CALLDATASIZE ISZERO PUSH2 0x19 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST STOP JUMPDEST PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR PUSH4 0x8C7080C9 SUB PUSH2 0xE JUMPI PUSH1 0xC0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0x2B3 JUMPI PUSH1 0x4 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 SUB PUSH2 0x2B3 JUMPI PUSH1 0x24 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x2B3 JUMPI PUSH2 0x6A SWAP1 CALLDATASIZE SWAP1 PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP1 SWAP2 PUSH1 0x44 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x2B3 JUMPI PUSH2 0x8C SWAP1 CALLDATASIZE SWAP1 PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP4 SWAP1 SWAP3 PUSH1 0x64 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x2B3 JUMPI PUSH2 0xAF SWAP1 CALLDATASIZE SWAP1 PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP6 SWAP1 PUSH1 0x84 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x2B3 JUMPI PUSH2 0xD1 SWAP1 CALLDATASIZE SWAP1 PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP2 PUSH8 0xFFFFFFFFFFFFFFFF PUSH1 0xA4 CALLDATALOAD GT PUSH2 0x2B3 JUMPI PUSH2 0xF2 CALLDATASIZE PUSH1 0xA4 CALLDATALOAD PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP5 SWAP1 SWAP6 DUP2 DUP2 EQ DUP1 ISZERO SWAP1 PUSH2 0x2C9 JUMPI JUMPDEST PUSH2 0x2B8 JUMPI PUSH1 0x0 JUMPDEST DUP2 DUP2 LT PUSH2 0x142 JUMPI SELFBALANCE PUSH2 0x115 JUMPI STOP JUMPDEST PUSH1 0x0 DUP1 DUP1 DUP1 SELFBALANCE DUP2 DUP2 ISZERO PUSH2 0x139 JUMPI JUMPDEST CALLER SWAP1 CALL ISZERO PUSH2 0x12D JUMPI STOP JUMPDEST PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST POP PUSH2 0x8FC PUSH2 0x123 JUMP JUMPDEST DUP11 DUP10 DUP14 PUSH2 0x169 DUP5 PUSH2 0x161 DUP2 DUP10 PUSH2 0x15A DUP3 DUP12 SELFBALANCE SWAP10 PUSH2 0x304 JUMP JUMPDEST CALLDATALOAD SWAP8 PUSH2 0x304 JUMP JUMPDEST CALLDATALOAD SWAP3 DUP10 PUSH2 0x304 JUMP JUMPDEST CALLDATALOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND DUP3 SUB PUSH2 0x2B3 JUMPI PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP15 AND EXTCODESIZE ISZERO PUSH2 0x2B3 JUMPI PUSH1 0x40 MLOAD PUSH4 0x735EB907 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD SWAP5 SWAP1 SWAP5 MSTORE PUSH1 0x24 DUP5 ADD MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x44 DUP4 ADD MSTORE PUSH1 0xA0 PUSH1 0x64 DUP4 ADD MSTORE PUSH1 0xA4 DUP3 ADD DUP9 SWAP1 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xFB SHL SUB DUP9 GT PUSH2 0x2B3 JUMPI DUP2 DUP13 PUSH1 0xE4 DUP11 PUSH1 0x5 SHL DUP13 PUSH1 0xC4 SWAP2 DUP1 DUP14 DUP5 DUP9 ADD CALLDATACOPY DUP6 ADD SWAP2 DUP3 ADD PUSH1 0xC0 DUP7 DUP5 SUB ADD PUSH1 0x84 DUP8 ADD MSTORE MSTORE ADD DUP13 PUSH1 0x0 JUMPDEST DUP14 DUP2 LT PUSH2 0x277 JUMPI POP PUSH1 0x0 SWAP5 SWAP2 DUP5 SWAP1 SUB SWAP3 DUP5 SWAP3 SWAP2 POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND GAS CALL DUP1 ISZERO PUSH2 0x12D JUMPI PUSH2 0x249 JUMPI JUMPDEST POP PUSH1 0x0 NOT DUP2 EQ PUSH2 0x233 JUMPI PUSH1 0x1 ADD PUSH2 0x107 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x261 JUMPI PUSH1 0x40 MSTORE CODESIZE PUSH2 0x221 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST SWAP1 SWAP4 POP SWAP2 POP DUP3 CALLDATALOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND DUP3 SUB PUSH2 0x2B3 JUMPI PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND DUP2 MSTORE DUP5 SWAP3 DUP16 SWAP3 PUSH1 0x20 SWAP3 DUP4 ADD SWAP3 SWAP2 SWAP1 SWAP2 ADD SWAP1 PUSH1 0x1 ADD PUSH2 0x1F7 JUMP JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH4 0x55CA07B7 PUSH1 0xE1 SHL PUSH1 0x80 MSTORE PUSH1 0x4 PUSH1 0x80 REVERT JUMPDEST POP DUP11 DUP2 EQ ISZERO PUSH2 0x100 JUMP JUMPDEST SWAP2 DUP2 PUSH1 0x1F DUP5 ADD SLT ISZERO PUSH2 0x2B3 JUMPI DUP3 CALLDATALOAD SWAP2 PUSH8 0xFFFFFFFFFFFFFFFF DUP4 GT PUSH2 0x2B3 JUMPI PUSH1 0x20 DUP1 DUP6 ADD SWAP5 DUP5 PUSH1 0x5 SHL ADD ADD GT PUSH2 0x2B3 JUMPI JUMP JUMPDEST SWAP2 SWAP1 DUP2 LT ISZERO PUSH2 0x314 JUMPI PUSH1 0x5 SHL ADD SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x32 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 RETURNDATASIZE PUSH6 0xE458361E6ED1 SLOAD BALANCE EXTCODECOPY 0x1F 0xEE 0x4D PUSH3 0x5F6539 LOG0 DUP12 DUP3 0xAC RETURNDATASIZE MSTORE 0xE9 0xE2 STOP CALLER 0xE8 0xB8 PUSH10 0x1C64736F6C6343000813 STOP CALLER ",
							"sourceMap": "170:1289:0:-:0;;;;;;;;;;;;;;;;;"
						},
						"deployedBytecode": {
							"functionDebugData": {
								"abi_decode_array_uint256_dyn_calldata": {
									"entryPoint": 723,
									"id": null,
									"parameterSlots": 2,
									"returnSlots": 2
								},
								"calldata_array_index_access_uint256_dyn_calldata": {
									"entryPoint": 772,
									"id": null,
									"parameterSlots": 3,
									"returnSlots": 1
								}
							},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "6080604052600436101561001b575b361561001957600080fd5b005b60003560e01c638c7080c90361000e5760c03660031901126102b3576004356001600160a01b03811681036102b35760243567ffffffffffffffff81116102b35761006a9036906004016102d3565b909160443567ffffffffffffffff81116102b35761008c9036906004016102d3565b93909260643567ffffffffffffffff81116102b3576100af9036906004016102d3565b959060843567ffffffffffffffff81116102b3576100d19036906004016102d3565b9167ffffffffffffffff60a435116102b3576100f23660a4356004016102d3565b9490958181148015906102c9575b6102b85760005b818110610142574761011557005b600080808047818115610139575b3390f11561012d57005b6040513d6000823e3d90fd5b506108fc610123565b8a898d61016984610161818961015a828b4799610304565b3597610304565b359289610304565b35906001600160a01b03821682036102b3576001600160a01b038e163b156102b35760405163735eb90760e11b8152600481019490945260248401526001600160a01b0316604483015260a0606483015260a482018890526001600160fb1b0388116102b357818c60e48a60051b8c60c491808d84880137850191820160c086840301608487015252018c60005b8d811061027757506000949184900392849291506001600160a01b03165af1801561012d57610249575b50600019811461023357600101610107565b634e487b7160e01b600052601160045260246000fd5b67ffffffffffffffff81116102615760405238610221565b634e487b7160e01b600052604160045260246000fd5b90935091508235906001600160a01b03821682036102b3576001600160a01b03909116815284928f9260209283019291909101906001016101f7565b600080fd5b6355ca07b760e11b60805260046080fd5b508a811415610100565b9181601f840112156102b35782359167ffffffffffffffff83116102b3576020808501948460051b0101116102b357565b91908110156103145760051b0190565b634e487b7160e01b600052603260045260246000fdfea26469706673582212203d65e458361e6ed154313c1fee4d625f6539a08b82ac3d52e9e20033e8b8691c64736f6c63430008130033",
							"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT ISZERO PUSH2 0x1B JUMPI JUMPDEST CALLDATASIZE ISZERO PUSH2 0x19 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST STOP JUMPDEST PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR PUSH4 0x8C7080C9 SUB PUSH2 0xE JUMPI PUSH1 0xC0 CALLDATASIZE PUSH1 0x3 NOT ADD SLT PUSH2 0x2B3 JUMPI PUSH1 0x4 CALLDATALOAD PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP2 AND DUP2 SUB PUSH2 0x2B3 JUMPI PUSH1 0x24 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x2B3 JUMPI PUSH2 0x6A SWAP1 CALLDATASIZE SWAP1 PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP1 SWAP2 PUSH1 0x44 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x2B3 JUMPI PUSH2 0x8C SWAP1 CALLDATASIZE SWAP1 PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP4 SWAP1 SWAP3 PUSH1 0x64 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x2B3 JUMPI PUSH2 0xAF SWAP1 CALLDATASIZE SWAP1 PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP6 SWAP1 PUSH1 0x84 CALLDATALOAD PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x2B3 JUMPI PUSH2 0xD1 SWAP1 CALLDATASIZE SWAP1 PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP2 PUSH8 0xFFFFFFFFFFFFFFFF PUSH1 0xA4 CALLDATALOAD GT PUSH2 0x2B3 JUMPI PUSH2 0xF2 CALLDATASIZE PUSH1 0xA4 CALLDATALOAD PUSH1 0x4 ADD PUSH2 0x2D3 JUMP JUMPDEST SWAP5 SWAP1 SWAP6 DUP2 DUP2 EQ DUP1 ISZERO SWAP1 PUSH2 0x2C9 JUMPI JUMPDEST PUSH2 0x2B8 JUMPI PUSH1 0x0 JUMPDEST DUP2 DUP2 LT PUSH2 0x142 JUMPI SELFBALANCE PUSH2 0x115 JUMPI STOP JUMPDEST PUSH1 0x0 DUP1 DUP1 DUP1 SELFBALANCE DUP2 DUP2 ISZERO PUSH2 0x139 JUMPI JUMPDEST CALLER SWAP1 CALL ISZERO PUSH2 0x12D JUMPI STOP JUMPDEST PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x0 DUP3 RETURNDATACOPY RETURNDATASIZE SWAP1 REVERT JUMPDEST POP PUSH2 0x8FC PUSH2 0x123 JUMP JUMPDEST DUP11 DUP10 DUP14 PUSH2 0x169 DUP5 PUSH2 0x161 DUP2 DUP10 PUSH2 0x15A DUP3 DUP12 SELFBALANCE SWAP10 PUSH2 0x304 JUMP JUMPDEST CALLDATALOAD SWAP8 PUSH2 0x304 JUMP JUMPDEST CALLDATALOAD SWAP3 DUP10 PUSH2 0x304 JUMP JUMPDEST CALLDATALOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND DUP3 SUB PUSH2 0x2B3 JUMPI PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP15 AND EXTCODESIZE ISZERO PUSH2 0x2B3 JUMPI PUSH1 0x40 MLOAD PUSH4 0x735EB907 PUSH1 0xE1 SHL DUP2 MSTORE PUSH1 0x4 DUP2 ADD SWAP5 SWAP1 SWAP5 MSTORE PUSH1 0x24 DUP5 ADD MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND PUSH1 0x44 DUP4 ADD MSTORE PUSH1 0xA0 PUSH1 0x64 DUP4 ADD MSTORE PUSH1 0xA4 DUP3 ADD DUP9 SWAP1 MSTORE PUSH1 0x1 PUSH1 0x1 PUSH1 0xFB SHL SUB DUP9 GT PUSH2 0x2B3 JUMPI DUP2 DUP13 PUSH1 0xE4 DUP11 PUSH1 0x5 SHL DUP13 PUSH1 0xC4 SWAP2 DUP1 DUP14 DUP5 DUP9 ADD CALLDATACOPY DUP6 ADD SWAP2 DUP3 ADD PUSH1 0xC0 DUP7 DUP5 SUB ADD PUSH1 0x84 DUP8 ADD MSTORE MSTORE ADD DUP13 PUSH1 0x0 JUMPDEST DUP14 DUP2 LT PUSH2 0x277 JUMPI POP PUSH1 0x0 SWAP5 SWAP2 DUP5 SWAP1 SUB SWAP3 DUP5 SWAP3 SWAP2 POP PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB AND GAS CALL DUP1 ISZERO PUSH2 0x12D JUMPI PUSH2 0x249 JUMPI JUMPDEST POP PUSH1 0x0 NOT DUP2 EQ PUSH2 0x233 JUMPI PUSH1 0x1 ADD PUSH2 0x107 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x11 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST PUSH8 0xFFFFFFFFFFFFFFFF DUP2 GT PUSH2 0x261 JUMPI PUSH1 0x40 MSTORE CODESIZE PUSH2 0x221 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x41 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT JUMPDEST SWAP1 SWAP4 POP SWAP2 POP DUP3 CALLDATALOAD SWAP1 PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB DUP3 AND DUP3 SUB PUSH2 0x2B3 JUMPI PUSH1 0x1 PUSH1 0x1 PUSH1 0xA0 SHL SUB SWAP1 SWAP2 AND DUP2 MSTORE DUP5 SWAP3 DUP16 SWAP3 PUSH1 0x20 SWAP3 DUP4 ADD SWAP3 SWAP2 SWAP1 SWAP2 ADD SWAP1 PUSH1 0x1 ADD PUSH2 0x1F7 JUMP JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH4 0x55CA07B7 PUSH1 0xE1 SHL PUSH1 0x80 MSTORE PUSH1 0x4 PUSH1 0x80 REVERT JUMPDEST POP DUP11 DUP2 EQ ISZERO PUSH2 0x100 JUMP JUMPDEST SWAP2 DUP2 PUSH1 0x1F DUP5 ADD SLT ISZERO PUSH2 0x2B3 JUMPI DUP3 CALLDATALOAD SWAP2 PUSH8 0xFFFFFFFFFFFFFFFF DUP4 GT PUSH2 0x2B3 JUMPI PUSH1 0x20 DUP1 DUP6 ADD SWAP5 DUP5 PUSH1 0x5 SHL ADD ADD GT PUSH2 0x2B3 JUMPI JUMP JUMPDEST SWAP2 SWAP1 DUP2 LT ISZERO PUSH2 0x314 JUMPI PUSH1 0x5 SHL ADD SWAP1 JUMP JUMPDEST PUSH4 0x4E487B71 PUSH1 0xE0 SHL PUSH1 0x0 MSTORE PUSH1 0x32 PUSH1 0x4 MSTORE PUSH1 0x24 PUSH1 0x0 REVERT INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 RETURNDATASIZE PUSH6 0xE458361E6ED1 SLOAD BALANCE EXTCODECOPY 0x1F 0xEE 0x4D PUSH3 0x5F6539 LOG0 DUP12 DUP3 0xAC RETURNDATASIZE MSTORE 0xE9 0xE2 STOP CALLER 0xE8 0xB8 PUSH10 0x1C64736F6C6343000813 STOP CALLER ",
							"sourceMap": "170:1289:0:-:0;;;;;;;;;-1:-1:-1;170:1289:0;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;170:1289:0;;;;;;-1:-1:-1;;;;;170:1289:0;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;:::i;:::-;939:38;;;;;;;;:80;;;170:1289;935:129;;170:1289;1090:21;;;;;;1327;1323:97;;170:1289;1323:97;170:1289;1391:21;;;;1362:51;;;;;1323:97;1370:10;1362:51;;;;;170:1289;1362:51;170:1289;;;;;;;;;1362:51;;;;;1113:3;1154:21;;;1216:13;1154:21;1201:13;1154:21;;1186:13;1154:21;;;1186:13;;:::i;:::-;170:1289;1201:13;;:::i;:::-;170:1289;1216:13;;;:::i;:::-;170:1289;;-1:-1:-1;;;;;170:1289:0;;;;;;-1:-1:-1;;;;;170:1289:0;;1126:152;;;;170:1289;;-1:-1:-1;;;1126:152:0;;170:1289;1126:152;;170:1289;;;;;;;;-1:-1:-1;;;;;170:1289:0;;;;;;;;;;;;;;;;-1:-1:-1;;;;;170:1289:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;170:1289:0;;1126:152;;;;;;;;-1:-1:-1;;;;;;170:1289:0;1126:152;;;;;;;;170:1289;-1:-1:-1;;;170:1289:0;;;;;;1075:13;;170:1289;;;;;;;;;;;;1126:152;170:1289;;;;;;;1126:152;;;170:1289;;;;;;;;;;;;;;;-1:-1:-1;170:1289:0;-1:-1:-1;170:1289:0;;;-1:-1:-1;;;;;170:1289:0;;;;;;-1:-1:-1;;;;;170:1289:0;;;;;;;;;;;;;;;;;;;;;;;;;;;935:129;1036:21;;;170:1289;1036:21;170:1289;;1036:21;939:80;981:38;;;;;939:80;;170:1289;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;:::o;:::-;;;;;;;;;;;"
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidBatchRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract ISequenceMarketFunctions\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"additionalFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"additionalFeeRecipients\",\"type\":\"address[]\"}],\"name\":\"acceptRequestBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"acceptRequestBatch(address,uint256[],uint256[],address[],uint256[],address[])\":{\"details\":\"Additional fees are applied to each request.\",\"params\":{\"additionalFeeRecipients\":\"The addresses to send the additional fees to.\",\"additionalFees\":\"The additional fees to pay.\",\"market\":\"The market to accept requests on.\",\"quantities\":\"The quantities of tokens to accept.\",\"recipients\":\"The recipients of the accepted tokens.\",\"requestIds\":\"The IDs of the requests.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"acceptRequestBatch(address,uint256[],uint256[],address[],uint256[],address[])\":{\"notice\":\"Accepts requests.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/BatchPayableHelper.sol\":\"BatchPayableHelper\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":0xsequence/=lib/0xsequence/\",\":@0xsequence/erc-1155/=lib/0xsequence/erc-1155/src/\",\":@0xsequence/erc20-meta-token/=lib/0xsequence/erc20-meta-token/src/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin/contracts/\",\":@uniswap/lib/=lib/uniswap-lib/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin/=lib/openzeppelin/\",\":uniswap-lib/=lib/uniswap-lib/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/BatchPayableHelper.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.19;\\n\\nimport {ISequenceMarketFunctions} from \\\"./interfaces/ISequenceMarket.sol\\\";\\n\\nerror InvalidBatchRequest();\\n\\ncontract BatchPayableHelper {\\n  /**\\n   * Accepts requests.\\n   * @param market The market to accept requests on.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The quantities of tokens to accept.\\n   * @param recipients The recipients of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   * @dev Additional fees are applied to each request.\\n   */\\n  function acceptRequestBatch(\\n    ISequenceMarketFunctions market,\\n    uint256[] calldata requestIds,\\n    uint256[] calldata quantities,\\n    address[] calldata recipients,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  ) external payable {\\n    if (requestIds.length != quantities.length || requestIds.length != recipients.length) {\\n      revert InvalidBatchRequest();\\n    }\\n\\n    for (uint256 i = 0; i < requestIds.length; i++) {\\n      market.acceptRequest{value: address(this).balance}(\\n        requestIds[i], quantities[i], recipients[i], additionalFees, additionalFeeRecipients\\n      );\\n    }\\n\\n    // Return any remaining ETH\\n    if (address(this).balance > 0) {\\n      payable(msg.sender).transfer(address(this).balance);\\n    }\\n  }\\n\\n  receive() external payable {}\\n}\\n\",\"keccak256\":\"0x93d6d5f2de19ce2223f6f3d744ff16419e1efdaf04412486817579f03c78c8bb\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/ISequenceMarket.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.19;\\n\\ninterface ISequenceMarketStorage {\\n  /**\\n   * Request parameters.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct RequestParams {\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Request storage.\\n   * @param creator The address of the request creator.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct Request {\\n    address creator;\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Custom royalty parameters.\\n   * @param recipient Address to send the fees to.\\n   * @param fee Fee percentage with a 10000 basis (e.g. 0.3% is 30 and 1% is 100 and 100% is 10000).\\n   * @dev Used to store custom royalty settings for contracts do not support ERC2981.\\n   */\\n  struct CustomRoyalty {\\n    address recipient;\\n    uint96 fee;\\n  }\\n}\\n\\ninterface ISequenceMarketFunctions is ISequenceMarketStorage {\\n  /**\\n   * Creates a request.\\n   * @param request The request's details.\\n   * @return requestId The ID of the request.\\n   * @notice A listing is when the maker is selling tokens for currency.\\n   * @notice An offer is when the maker is buying tokens with currency.\\n   */\\n  function createRequest(RequestParams calldata request) external returns (uint256 requestId);\\n\\n  /**\\n   * Creates requests.\\n   * @param requests The requests' details.\\n   * @return requestIds The IDs of the requests.\\n   */\\n  function createRequestBatch(RequestParams[] calldata requests) external returns (uint256[] memory requestIds);\\n\\n  /**\\n   * Accepts a request.\\n   * @param requestId The ID of the request.\\n   * @param quantity The quantity of tokens to accept.\\n   * @param recipient The recipient of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   */\\n  function acceptRequest(\\n    uint256 requestId,\\n    uint256 quantity,\\n    address recipient,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external payable;\\n\\n  /**\\n   * Accepts requests.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The quantities of tokens to accept.\\n   * @param recipients The recipients of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   * @dev Additional fees are applied to each request.\\n   */\\n  function acceptRequestBatch(\\n    uint256[] calldata requestIds,\\n    uint256[] calldata quantities,\\n    address[] calldata recipients,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external;\\n\\n  /**\\n   * Cancels a request.\\n   * @param requestId The ID of the request.\\n   */\\n  function cancelRequest(uint256 requestId) external;\\n\\n  /**\\n   * Cancels requests.\\n   * @param requestIds The IDs of the requests.\\n   */\\n  function cancelRequestBatch(uint256[] calldata requestIds) external;\\n\\n  /**\\n   * Gets a request.\\n   * @param requestId The ID of the request.\\n   * @return request The request.\\n   */\\n  function getRequest(uint256 requestId) external view returns (Request memory request);\\n\\n  /**\\n   * Gets requests.\\n   * @param requestIds The IDs of the requests.\\n   * @return requests The requests.\\n   */\\n  function getRequestBatch(uint256[] calldata requestIds) external view returns (Request[] memory requests);\\n\\n  /**\\n   * Invalidates all current requests for the msg.sender.\\n   */\\n  function invalidateRequests() external;\\n\\n  /**\\n   * Invalidates all current requests for a given `tokenContract` for the msg.sender.\\n   */\\n  function invalidateRequests(address tokenContract) external;\\n\\n  /**\\n   * Checks if a request is valid.\\n   * @param requestId The ID of the request.\\n   * @param quantity The amount of tokens to exchange. 0 is assumed to be the request's available quantity.\\n   * @return valid The validity of the request.\\n   * @return request The request.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValid(uint256 requestId, uint256 quantity) external view returns (bool valid, Request memory request);\\n\\n  /**\\n   * Checks if requests are valid.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.\\n   * @return valid The validities of the requests.\\n   * @return requests The requests.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValidBatch(uint256[] calldata requestIds, uint256[] calldata quantities)\\n    external\\n    view\\n    returns (bool[] memory valid, Request[] memory requests);\\n\\n  /**\\n   * Returns the royalty details for the given token and cost.\\n   * @param tokenContract Address of the token being traded.\\n   * @param tokenId The ID of the token.\\n   * @param cost Amount of currency sent/received for the trade.\\n   * @return recipient Address to send royalties to.\\n   * @return royalty Amount of currency to be paid as royalties.\\n   */\\n  function getRoyaltyInfo(address tokenContract, uint256 tokenId, uint256 cost)\\n    external\\n    view\\n    returns (address recipient, uint256 royalty);\\n}\\n\\ninterface ISequenceMarketSignals {\\n  //\\n  // Events\\n  //\\n\\n  /// Emitted when a request is created.\\n  event RequestCreated(\\n    uint256 indexed requestId,\\n    address indexed creator,\\n    address indexed tokenContract,\\n    uint256 tokenId,\\n    bool isListing,\\n    uint256 quantity,\\n    address currency,\\n    uint256 pricePerToken,\\n    uint256 expiry\\n  );\\n\\n  /// Emitted when a request is accepted.\\n  event RequestAccepted(\\n    uint256 indexed requestId,\\n    address indexed buyer,\\n    address indexed tokenContract,\\n    address recipient,\\n    uint256 quantity,\\n    uint256 quantityRemaining\\n  );\\n\\n  /// Emitted when a request is cancelled.\\n  event RequestCancelled(uint256 indexed requestId, address indexed tokenContract);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, address indexed tokenContract, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when custom royalty settings are changed.\\n  event CustomRoyaltyChanged(address indexed tokenContract, address recipient, uint96 fee);\\n\\n  //\\n  // Errors\\n  //\\n\\n  /// Thrown when the contract address does not support the required interface.\\n  error UnsupportedContractInterface(address contractAddress, bytes4 interfaceId);\\n\\n  /// Thrown when the token approval is invalid.\\n  error InvalidTokenApproval(address tokenContract, uint256 tokenId, uint256 quantity, address owner);\\n\\n  /// Thrown when the currency address is invalid.\\n  error InvalidCurrency();\\n\\n  /// Thrown when the currency approval is invalid.\\n  error InvalidCurrencyApproval(address currency, uint256 quantity, address owner);\\n\\n  /// Thrown when request id is invalid.\\n  error InvalidRequestId(uint256 requestId);\\n\\n  /// Thrown when the parameters of a batch accept request are invalid.\\n  error InvalidBatchRequest();\\n\\n  /// Thrown when quantity is invalid.\\n  error InvalidQuantity();\\n\\n  /// Thrown when price is invalid.\\n  error InvalidPrice();\\n\\n  /// Thrown when royalty is invalid.\\n  error InvalidRoyalty();\\n\\n  /// Thrown when expiry is invalid.\\n  error InvalidExpiry();\\n\\n  /// Thrown when request has been explicitly invalidated.\\n  error Invalidated();\\n\\n  /// Thrown when the additional fees are invalid.\\n  error InvalidAdditionalFees();\\n}\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISequenceMarket is ISequenceMarketFunctions, ISequenceMarketSignals {}\\n\",\"keccak256\":\"0xfe58559dd9ea4a0e4765b98cd76a5ad0044e08d70b71fbf004d0decfc5635e14\",\"license\":\"Apache-2.0\"}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {
							"acceptRequestBatch(address,uint256[],uint256[],address[],uint256[],address[])": {
								"notice": "Accepts requests."
							}
						},
						"version": 1
					}
				}
			},
			"contracts/interfaces/ISequenceMarket.sol": {
				"ISequenceMarket": {
					"abi": [
						{
							"inputs": [],
							"name": "InvalidAdditionalFees",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidBatchRequest",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidCurrency",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "currency",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								}
							],
							"name": "InvalidCurrencyApproval",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidExpiry",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidPrice",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidQuantity",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								}
							],
							"name": "InvalidRequestId",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidRoyalty",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "tokenId",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								}
							],
							"name": "InvalidTokenApproval",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "Invalidated",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "contractAddress",
									"type": "address"
								},
								{
									"internalType": "bytes4",
									"name": "interfaceId",
									"type": "bytes4"
								}
							],
							"name": "UnsupportedContractInterface",
							"type": "error"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "address",
									"name": "recipient",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint96",
									"name": "fee",
									"type": "uint96"
								}
							],
							"name": "CustomRoyaltyChanged",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "buyer",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "address",
									"name": "recipient",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "quantityRemaining",
									"type": "uint256"
								}
							],
							"name": "RequestAccepted",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								}
							],
							"name": "RequestCancelled",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "creator",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "tokenId",
									"type": "uint256"
								},
								{
									"indexed": false,
									"internalType": "bool",
									"name": "isListing",
									"type": "bool"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"indexed": false,
									"internalType": "address",
									"name": "currency",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "pricePerToken",
									"type": "uint256"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "expiry",
									"type": "uint256"
								}
							],
							"name": "RequestCreated",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "creator",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "invalidatedBefore",
									"type": "uint256"
								}
							],
							"name": "RequestsInvalidated",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "creator",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "invalidatedBefore",
									"type": "uint256"
								}
							],
							"name": "RequestsInvalidated",
							"type": "event"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"internalType": "address",
									"name": "recipient",
									"type": "address"
								},
								{
									"internalType": "uint256[]",
									"name": "additionalFees",
									"type": "uint256[]"
								},
								{
									"internalType": "address[]",
									"name": "additionalFeeRecipients",
									"type": "address[]"
								}
							],
							"name": "acceptRequest",
							"outputs": [],
							"stateMutability": "payable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								},
								{
									"internalType": "uint256[]",
									"name": "quantities",
									"type": "uint256[]"
								},
								{
									"internalType": "address[]",
									"name": "recipients",
									"type": "address[]"
								},
								{
									"internalType": "uint256[]",
									"name": "additionalFees",
									"type": "uint256[]"
								},
								{
									"internalType": "address[]",
									"name": "additionalFeeRecipients",
									"type": "address[]"
								}
							],
							"name": "acceptRequestBatch",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								}
							],
							"name": "cancelRequest",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								}
							],
							"name": "cancelRequestBatch",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.RequestParams",
									"name": "request",
									"type": "tuple"
								}
							],
							"name": "createRequest",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.RequestParams[]",
									"name": "requests",
									"type": "tuple[]"
								}
							],
							"name": "createRequestBatch",
							"outputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								}
							],
							"name": "getRequest",
							"outputs": [
								{
									"components": [
										{
											"internalType": "address",
											"name": "creator",
											"type": "address"
										},
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.Request",
									"name": "request",
									"type": "tuple"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								}
							],
							"name": "getRequestBatch",
							"outputs": [
								{
									"components": [
										{
											"internalType": "address",
											"name": "creator",
											"type": "address"
										},
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.Request[]",
									"name": "requests",
									"type": "tuple[]"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "tokenId",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "cost",
									"type": "uint256"
								}
							],
							"name": "getRoyaltyInfo",
							"outputs": [
								{
									"internalType": "address",
									"name": "recipient",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "royalty",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "invalidateRequests",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								}
							],
							"name": "invalidateRequests",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								}
							],
							"name": "isRequestValid",
							"outputs": [
								{
									"internalType": "bool",
									"name": "valid",
									"type": "bool"
								},
								{
									"components": [
										{
											"internalType": "address",
											"name": "creator",
											"type": "address"
										},
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.Request",
									"name": "request",
									"type": "tuple"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								},
								{
									"internalType": "uint256[]",
									"name": "quantities",
									"type": "uint256[]"
								}
							],
							"name": "isRequestValidBatch",
							"outputs": [
								{
									"internalType": "bool[]",
									"name": "valid",
									"type": "bool[]"
								},
								{
									"components": [
										{
											"internalType": "address",
											"name": "creator",
											"type": "address"
										},
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.Request[]",
									"name": "requests",
									"type": "tuple[]"
								}
							],
							"stateMutability": "view",
							"type": "function"
						}
					],
					"devdoc": {
						"kind": "dev",
						"methods": {
							"acceptRequest(uint256,uint256,address,uint256[],address[])": {
								"params": {
									"additionalFeeRecipients": "The addresses to send the additional fees to.",
									"additionalFees": "The additional fees to pay.",
									"quantity": "The quantity of tokens to accept.",
									"recipient": "The recipient of the accepted tokens.",
									"requestId": "The ID of the request."
								}
							},
							"acceptRequestBatch(uint256[],uint256[],address[],uint256[],address[])": {
								"details": "Additional fees are applied to each request.",
								"params": {
									"additionalFeeRecipients": "The addresses to send the additional fees to.",
									"additionalFees": "The additional fees to pay.",
									"quantities": "The quantities of tokens to accept.",
									"recipients": "The recipients of the accepted tokens.",
									"requestIds": "The IDs of the requests."
								}
							},
							"cancelRequest(uint256)": {
								"params": {
									"requestId": "The ID of the request."
								}
							},
							"cancelRequestBatch(uint256[])": {
								"params": {
									"requestIds": "The IDs of the requests."
								}
							},
							"createRequest((bool,bool,address,uint256,uint256,uint96,address,uint256))": {
								"params": {
									"request": "The request's details."
								},
								"returns": {
									"requestId": "The ID of the request."
								}
							},
							"createRequestBatch((bool,bool,address,uint256,uint256,uint96,address,uint256)[])": {
								"params": {
									"requests": "The requests' details."
								},
								"returns": {
									"requestIds": "The IDs of the requests."
								}
							},
							"getRequest(uint256)": {
								"params": {
									"requestId": "The ID of the request."
								},
								"returns": {
									"request": "The request."
								}
							},
							"getRequestBatch(uint256[])": {
								"params": {
									"requestIds": "The IDs of the requests."
								},
								"returns": {
									"requests": "The requests."
								}
							},
							"getRoyaltyInfo(address,uint256,uint256)": {
								"params": {
									"cost": "Amount of currency sent/received for the trade.",
									"tokenContract": "Address of the token being traded.",
									"tokenId": "The ID of the token."
								},
								"returns": {
									"recipient": "Address to send royalties to.",
									"royalty": "Amount of currency to be paid as royalties."
								}
							},
							"isRequestValid(uint256,uint256)": {
								"params": {
									"quantity": "The amount of tokens to exchange. 0 is assumed to be the request's available quantity.",
									"requestId": "The ID of the request."
								},
								"returns": {
									"request": "The request.",
									"valid": "The validity of the request."
								}
							},
							"isRequestValidBatch(uint256[],uint256[])": {
								"params": {
									"quantities": "The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.",
									"requestIds": "The IDs of the requests."
								},
								"returns": {
									"requests": "The requests.",
									"valid": "The validities of the requests."
								}
							}
						},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidAdditionalFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBatchRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCurrency\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"InvalidCurrencyApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidExpiry\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"InvalidRequestId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoyalty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"InvalidTokenApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalidated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"UnsupportedContractInterface\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"fee\",\"type\":\"uint96\"}],\"name\":\"CustomRoyaltyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantityRemaining\",\"type\":\"uint256\"}],\"name\":\"RequestAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"RequestCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"RequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"invalidatedBefore\",\"type\":\"uint256\"}],\"name\":\"RequestsInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"invalidatedBefore\",\"type\":\"uint256\"}],\"name\":\"RequestsInvalidated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"additionalFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"additionalFeeRecipients\",\"type\":\"address[]\"}],\"name\":\"acceptRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"additionalFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"additionalFeeRecipients\",\"type\":\"address[]\"}],\"name\":\"acceptRequestBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"cancelRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"}],\"name\":\"cancelRequestBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.RequestParams\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"createRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.RequestParams[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"name\":\"createRequestBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getRequest\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"}],\"name\":\"getRequestBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.Request[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invalidateRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"invalidateRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"isRequestValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"}],\"name\":\"isRequestValidBatch\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"valid\",\"type\":\"bool[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.Request[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"acceptRequest(uint256,uint256,address,uint256[],address[])\":{\"params\":{\"additionalFeeRecipients\":\"The addresses to send the additional fees to.\",\"additionalFees\":\"The additional fees to pay.\",\"quantity\":\"The quantity of tokens to accept.\",\"recipient\":\"The recipient of the accepted tokens.\",\"requestId\":\"The ID of the request.\"}},\"acceptRequestBatch(uint256[],uint256[],address[],uint256[],address[])\":{\"details\":\"Additional fees are applied to each request.\",\"params\":{\"additionalFeeRecipients\":\"The addresses to send the additional fees to.\",\"additionalFees\":\"The additional fees to pay.\",\"quantities\":\"The quantities of tokens to accept.\",\"recipients\":\"The recipients of the accepted tokens.\",\"requestIds\":\"The IDs of the requests.\"}},\"cancelRequest(uint256)\":{\"params\":{\"requestId\":\"The ID of the request.\"}},\"cancelRequestBatch(uint256[])\":{\"params\":{\"requestIds\":\"The IDs of the requests.\"}},\"createRequest((bool,bool,address,uint256,uint256,uint96,address,uint256))\":{\"params\":{\"request\":\"The request's details.\"},\"returns\":{\"requestId\":\"The ID of the request.\"}},\"createRequestBatch((bool,bool,address,uint256,uint256,uint96,address,uint256)[])\":{\"params\":{\"requests\":\"The requests' details.\"},\"returns\":{\"requestIds\":\"The IDs of the requests.\"}},\"getRequest(uint256)\":{\"params\":{\"requestId\":\"The ID of the request.\"},\"returns\":{\"request\":\"The request.\"}},\"getRequestBatch(uint256[])\":{\"params\":{\"requestIds\":\"The IDs of the requests.\"},\"returns\":{\"requests\":\"The requests.\"}},\"getRoyaltyInfo(address,uint256,uint256)\":{\"params\":{\"cost\":\"Amount of currency sent/received for the trade.\",\"tokenContract\":\"Address of the token being traded.\",\"tokenId\":\"The ID of the token.\"},\"returns\":{\"recipient\":\"Address to send royalties to.\",\"royalty\":\"Amount of currency to be paid as royalties.\"}},\"isRequestValid(uint256,uint256)\":{\"params\":{\"quantity\":\"The amount of tokens to exchange. 0 is assumed to be the request's available quantity.\",\"requestId\":\"The ID of the request.\"},\"returns\":{\"request\":\"The request.\",\"valid\":\"The validity of the request.\"}},\"isRequestValidBatch(uint256[],uint256[])\":{\"params\":{\"quantities\":\"The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.\",\"requestIds\":\"The IDs of the requests.\"},\"returns\":{\"requests\":\"The requests.\",\"valid\":\"The validities of the requests.\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"InvalidAdditionalFees()\":[{\"notice\":\"Thrown when the additional fees are invalid.\"}],\"InvalidBatchRequest()\":[{\"notice\":\"Thrown when the parameters of a batch accept request are invalid.\"}],\"InvalidCurrency()\":[{\"notice\":\"Thrown when the currency address is invalid.\"}],\"InvalidCurrencyApproval(address,uint256,address)\":[{\"notice\":\"Thrown when the currency approval is invalid.\"}],\"InvalidExpiry()\":[{\"notice\":\"Thrown when expiry is invalid.\"}],\"InvalidPrice()\":[{\"notice\":\"Thrown when price is invalid.\"}],\"InvalidQuantity()\":[{\"notice\":\"Thrown when quantity is invalid.\"}],\"InvalidRequestId(uint256)\":[{\"notice\":\"Thrown when request id is invalid.\"}],\"InvalidRoyalty()\":[{\"notice\":\"Thrown when royalty is invalid.\"}],\"InvalidTokenApproval(address,uint256,uint256,address)\":[{\"notice\":\"Thrown when the token approval is invalid.\"}],\"Invalidated()\":[{\"notice\":\"Thrown when request has been explicitly invalidated.\"}],\"UnsupportedContractInterface(address,bytes4)\":[{\"notice\":\"Thrown when the contract address does not support the required interface.\"}]},\"events\":{\"CustomRoyaltyChanged(address,address,uint96)\":{\"notice\":\"Emitted when custom royalty settings are changed.\"},\"RequestAccepted(uint256,address,address,address,uint256,uint256)\":{\"notice\":\"Emitted when a request is accepted.\"},\"RequestCancelled(uint256,address)\":{\"notice\":\"Emitted when a request is cancelled.\"},\"RequestCreated(uint256,address,address,uint256,bool,uint256,address,uint256,uint256)\":{\"notice\":\"Emitted when a request is created.\"},\"RequestsInvalidated(address,address,uint256)\":{\"notice\":\"Emitted when a user bulk invalidates requests.\"},\"RequestsInvalidated(address,uint256)\":{\"notice\":\"Emitted when a user bulk invalidates requests.\"}},\"kind\":\"user\",\"methods\":{\"acceptRequest(uint256,uint256,address,uint256[],address[])\":{\"notice\":\"Accepts a request.\"},\"acceptRequestBatch(uint256[],uint256[],address[],uint256[],address[])\":{\"notice\":\"Accepts requests.\"},\"cancelRequest(uint256)\":{\"notice\":\"Cancels a request.\"},\"cancelRequestBatch(uint256[])\":{\"notice\":\"Cancels requests.\"},\"createRequest((bool,bool,address,uint256,uint256,uint96,address,uint256))\":{\"notice\":\"Creates a request.A listing is when the maker is selling tokens for currency.An offer is when the maker is buying tokens with currency.\"},\"createRequestBatch((bool,bool,address,uint256,uint256,uint96,address,uint256)[])\":{\"notice\":\"Creates requests.\"},\"getRequest(uint256)\":{\"notice\":\"Gets a request.\"},\"getRequestBatch(uint256[])\":{\"notice\":\"Gets requests.\"},\"getRoyaltyInfo(address,uint256,uint256)\":{\"notice\":\"Returns the royalty details for the given token and cost.\"},\"invalidateRequests()\":{\"notice\":\"Invalidates all current requests for the msg.sender.\"},\"invalidateRequests(address)\":{\"notice\":\"Invalidates all current requests for a given `tokenContract` for the msg.sender.\"},\"isRequestValid(uint256,uint256)\":{\"notice\":\"Checks if a request is valid.A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\"},\"isRequestValidBatch(uint256[],uint256[])\":{\"notice\":\"Checks if requests are valid.A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/interfaces/ISequenceMarket.sol\":\"ISequenceMarket\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":0xsequence/=lib/0xsequence/\",\":@0xsequence/erc-1155/=lib/0xsequence/erc-1155/src/\",\":@0xsequence/erc20-meta-token/=lib/0xsequence/erc20-meta-token/src/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin/contracts/\",\":@uniswap/lib/=lib/uniswap-lib/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin/=lib/openzeppelin/\",\":uniswap-lib/=lib/uniswap-lib/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/ISequenceMarket.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.19;\\n\\ninterface ISequenceMarketStorage {\\n  /**\\n   * Request parameters.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct RequestParams {\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Request storage.\\n   * @param creator The address of the request creator.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct Request {\\n    address creator;\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Custom royalty parameters.\\n   * @param recipient Address to send the fees to.\\n   * @param fee Fee percentage with a 10000 basis (e.g. 0.3% is 30 and 1% is 100 and 100% is 10000).\\n   * @dev Used to store custom royalty settings for contracts do not support ERC2981.\\n   */\\n  struct CustomRoyalty {\\n    address recipient;\\n    uint96 fee;\\n  }\\n}\\n\\ninterface ISequenceMarketFunctions is ISequenceMarketStorage {\\n  /**\\n   * Creates a request.\\n   * @param request The request's details.\\n   * @return requestId The ID of the request.\\n   * @notice A listing is when the maker is selling tokens for currency.\\n   * @notice An offer is when the maker is buying tokens with currency.\\n   */\\n  function createRequest(RequestParams calldata request) external returns (uint256 requestId);\\n\\n  /**\\n   * Creates requests.\\n   * @param requests The requests' details.\\n   * @return requestIds The IDs of the requests.\\n   */\\n  function createRequestBatch(RequestParams[] calldata requests) external returns (uint256[] memory requestIds);\\n\\n  /**\\n   * Accepts a request.\\n   * @param requestId The ID of the request.\\n   * @param quantity The quantity of tokens to accept.\\n   * @param recipient The recipient of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   */\\n  function acceptRequest(\\n    uint256 requestId,\\n    uint256 quantity,\\n    address recipient,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external payable;\\n\\n  /**\\n   * Accepts requests.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The quantities of tokens to accept.\\n   * @param recipients The recipients of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   * @dev Additional fees are applied to each request.\\n   */\\n  function acceptRequestBatch(\\n    uint256[] calldata requestIds,\\n    uint256[] calldata quantities,\\n    address[] calldata recipients,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external;\\n\\n  /**\\n   * Cancels a request.\\n   * @param requestId The ID of the request.\\n   */\\n  function cancelRequest(uint256 requestId) external;\\n\\n  /**\\n   * Cancels requests.\\n   * @param requestIds The IDs of the requests.\\n   */\\n  function cancelRequestBatch(uint256[] calldata requestIds) external;\\n\\n  /**\\n   * Gets a request.\\n   * @param requestId The ID of the request.\\n   * @return request The request.\\n   */\\n  function getRequest(uint256 requestId) external view returns (Request memory request);\\n\\n  /**\\n   * Gets requests.\\n   * @param requestIds The IDs of the requests.\\n   * @return requests The requests.\\n   */\\n  function getRequestBatch(uint256[] calldata requestIds) external view returns (Request[] memory requests);\\n\\n  /**\\n   * Invalidates all current requests for the msg.sender.\\n   */\\n  function invalidateRequests() external;\\n\\n  /**\\n   * Invalidates all current requests for a given `tokenContract` for the msg.sender.\\n   */\\n  function invalidateRequests(address tokenContract) external;\\n\\n  /**\\n   * Checks if a request is valid.\\n   * @param requestId The ID of the request.\\n   * @param quantity The amount of tokens to exchange. 0 is assumed to be the request's available quantity.\\n   * @return valid The validity of the request.\\n   * @return request The request.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValid(uint256 requestId, uint256 quantity) external view returns (bool valid, Request memory request);\\n\\n  /**\\n   * Checks if requests are valid.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.\\n   * @return valid The validities of the requests.\\n   * @return requests The requests.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValidBatch(uint256[] calldata requestIds, uint256[] calldata quantities)\\n    external\\n    view\\n    returns (bool[] memory valid, Request[] memory requests);\\n\\n  /**\\n   * Returns the royalty details for the given token and cost.\\n   * @param tokenContract Address of the token being traded.\\n   * @param tokenId The ID of the token.\\n   * @param cost Amount of currency sent/received for the trade.\\n   * @return recipient Address to send royalties to.\\n   * @return royalty Amount of currency to be paid as royalties.\\n   */\\n  function getRoyaltyInfo(address tokenContract, uint256 tokenId, uint256 cost)\\n    external\\n    view\\n    returns (address recipient, uint256 royalty);\\n}\\n\\ninterface ISequenceMarketSignals {\\n  //\\n  // Events\\n  //\\n\\n  /// Emitted when a request is created.\\n  event RequestCreated(\\n    uint256 indexed requestId,\\n    address indexed creator,\\n    address indexed tokenContract,\\n    uint256 tokenId,\\n    bool isListing,\\n    uint256 quantity,\\n    address currency,\\n    uint256 pricePerToken,\\n    uint256 expiry\\n  );\\n\\n  /// Emitted when a request is accepted.\\n  event RequestAccepted(\\n    uint256 indexed requestId,\\n    address indexed buyer,\\n    address indexed tokenContract,\\n    address recipient,\\n    uint256 quantity,\\n    uint256 quantityRemaining\\n  );\\n\\n  /// Emitted when a request is cancelled.\\n  event RequestCancelled(uint256 indexed requestId, address indexed tokenContract);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, address indexed tokenContract, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when custom royalty settings are changed.\\n  event CustomRoyaltyChanged(address indexed tokenContract, address recipient, uint96 fee);\\n\\n  //\\n  // Errors\\n  //\\n\\n  /// Thrown when the contract address does not support the required interface.\\n  error UnsupportedContractInterface(address contractAddress, bytes4 interfaceId);\\n\\n  /// Thrown when the token approval is invalid.\\n  error InvalidTokenApproval(address tokenContract, uint256 tokenId, uint256 quantity, address owner);\\n\\n  /// Thrown when the currency address is invalid.\\n  error InvalidCurrency();\\n\\n  /// Thrown when the currency approval is invalid.\\n  error InvalidCurrencyApproval(address currency, uint256 quantity, address owner);\\n\\n  /// Thrown when request id is invalid.\\n  error InvalidRequestId(uint256 requestId);\\n\\n  /// Thrown when the parameters of a batch accept request are invalid.\\n  error InvalidBatchRequest();\\n\\n  /// Thrown when quantity is invalid.\\n  error InvalidQuantity();\\n\\n  /// Thrown when price is invalid.\\n  error InvalidPrice();\\n\\n  /// Thrown when royalty is invalid.\\n  error InvalidRoyalty();\\n\\n  /// Thrown when expiry is invalid.\\n  error InvalidExpiry();\\n\\n  /// Thrown when request has been explicitly invalidated.\\n  error Invalidated();\\n\\n  /// Thrown when the additional fees are invalid.\\n  error InvalidAdditionalFees();\\n}\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISequenceMarket is ISequenceMarketFunctions, ISequenceMarketSignals {}\\n\",\"keccak256\":\"0xfe58559dd9ea4a0e4765b98cd76a5ad0044e08d70b71fbf004d0decfc5635e14\",\"license\":\"Apache-2.0\"}},\"version\":1}",
					"userdoc": {
						"errors": {
							"InvalidAdditionalFees()": [
								{
									"notice": "Thrown when the additional fees are invalid."
								}
							],
							"InvalidBatchRequest()": [
								{
									"notice": "Thrown when the parameters of a batch accept request are invalid."
								}
							],
							"InvalidCurrency()": [
								{
									"notice": "Thrown when the currency address is invalid."
								}
							],
							"InvalidCurrencyApproval(address,uint256,address)": [
								{
									"notice": "Thrown when the currency approval is invalid."
								}
							],
							"InvalidExpiry()": [
								{
									"notice": "Thrown when expiry is invalid."
								}
							],
							"InvalidPrice()": [
								{
									"notice": "Thrown when price is invalid."
								}
							],
							"InvalidQuantity()": [
								{
									"notice": "Thrown when quantity is invalid."
								}
							],
							"InvalidRequestId(uint256)": [
								{
									"notice": "Thrown when request id is invalid."
								}
							],
							"InvalidRoyalty()": [
								{
									"notice": "Thrown when royalty is invalid."
								}
							],
							"InvalidTokenApproval(address,uint256,uint256,address)": [
								{
									"notice": "Thrown when the token approval is invalid."
								}
							],
							"Invalidated()": [
								{
									"notice": "Thrown when request has been explicitly invalidated."
								}
							],
							"UnsupportedContractInterface(address,bytes4)": [
								{
									"notice": "Thrown when the contract address does not support the required interface."
								}
							]
						},
						"events": {
							"CustomRoyaltyChanged(address,address,uint96)": {
								"notice": "Emitted when custom royalty settings are changed."
							},
							"RequestAccepted(uint256,address,address,address,uint256,uint256)": {
								"notice": "Emitted when a request is accepted."
							},
							"RequestCancelled(uint256,address)": {
								"notice": "Emitted when a request is cancelled."
							},
							"RequestCreated(uint256,address,address,uint256,bool,uint256,address,uint256,uint256)": {
								"notice": "Emitted when a request is created."
							},
							"RequestsInvalidated(address,address,uint256)": {
								"notice": "Emitted when a user bulk invalidates requests."
							},
							"RequestsInvalidated(address,uint256)": {
								"notice": "Emitted when a user bulk invalidates requests."
							}
						},
						"kind": "user",
						"methods": {
							"acceptRequest(uint256,uint256,address,uint256[],address[])": {
								"notice": "Accepts a request."
							},
							"acceptRequestBatch(uint256[],uint256[],address[],uint256[],address[])": {
								"notice": "Accepts requests."
							},
							"cancelRequest(uint256)": {
								"notice": "Cancels a request."
							},
							"cancelRequestBatch(uint256[])": {
								"notice": "Cancels requests."
							},
							"createRequest((bool,bool,address,uint256,uint256,uint96,address,uint256))": {
								"notice": "Creates a request.A listing is when the maker is selling tokens for currency.An offer is when the maker is buying tokens with currency."
							},
							"createRequestBatch((bool,bool,address,uint256,uint256,uint96,address,uint256)[])": {
								"notice": "Creates requests."
							},
							"getRequest(uint256)": {
								"notice": "Gets a request."
							},
							"getRequestBatch(uint256[])": {
								"notice": "Gets requests."
							},
							"getRoyaltyInfo(address,uint256,uint256)": {
								"notice": "Returns the royalty details for the given token and cost."
							},
							"invalidateRequests()": {
								"notice": "Invalidates all current requests for the msg.sender."
							},
							"invalidateRequests(address)": {
								"notice": "Invalidates all current requests for a given `tokenContract` for the msg.sender."
							},
							"isRequestValid(uint256,uint256)": {
								"notice": "Checks if a request is valid.A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable."
							},
							"isRequestValidBatch(uint256[],uint256[])": {
								"notice": "Checks if requests are valid.A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable."
							}
						},
						"version": 1
					}
				},
				"ISequenceMarketFunctions": {
					"abi": [
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"internalType": "address",
									"name": "recipient",
									"type": "address"
								},
								{
									"internalType": "uint256[]",
									"name": "additionalFees",
									"type": "uint256[]"
								},
								{
									"internalType": "address[]",
									"name": "additionalFeeRecipients",
									"type": "address[]"
								}
							],
							"name": "acceptRequest",
							"outputs": [],
							"stateMutability": "payable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								},
								{
									"internalType": "uint256[]",
									"name": "quantities",
									"type": "uint256[]"
								},
								{
									"internalType": "address[]",
									"name": "recipients",
									"type": "address[]"
								},
								{
									"internalType": "uint256[]",
									"name": "additionalFees",
									"type": "uint256[]"
								},
								{
									"internalType": "address[]",
									"name": "additionalFeeRecipients",
									"type": "address[]"
								}
							],
							"name": "acceptRequestBatch",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								}
							],
							"name": "cancelRequest",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								}
							],
							"name": "cancelRequestBatch",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.RequestParams",
									"name": "request",
									"type": "tuple"
								}
							],
							"name": "createRequest",
							"outputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"components": [
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.RequestParams[]",
									"name": "requests",
									"type": "tuple[]"
								}
							],
							"name": "createRequestBatch",
							"outputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								}
							],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								}
							],
							"name": "getRequest",
							"outputs": [
								{
									"components": [
										{
											"internalType": "address",
											"name": "creator",
											"type": "address"
										},
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.Request",
									"name": "request",
									"type": "tuple"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								}
							],
							"name": "getRequestBatch",
							"outputs": [
								{
									"components": [
										{
											"internalType": "address",
											"name": "creator",
											"type": "address"
										},
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.Request[]",
									"name": "requests",
									"type": "tuple[]"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "tokenId",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "cost",
									"type": "uint256"
								}
							],
							"name": "getRoyaltyInfo",
							"outputs": [
								{
									"internalType": "address",
									"name": "recipient",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "royalty",
									"type": "uint256"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [],
							"name": "invalidateRequests",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								}
							],
							"name": "invalidateRequests",
							"outputs": [],
							"stateMutability": "nonpayable",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								}
							],
							"name": "isRequestValid",
							"outputs": [
								{
									"internalType": "bool",
									"name": "valid",
									"type": "bool"
								},
								{
									"components": [
										{
											"internalType": "address",
											"name": "creator",
											"type": "address"
										},
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.Request",
									"name": "request",
									"type": "tuple"
								}
							],
							"stateMutability": "view",
							"type": "function"
						},
						{
							"inputs": [
								{
									"internalType": "uint256[]",
									"name": "requestIds",
									"type": "uint256[]"
								},
								{
									"internalType": "uint256[]",
									"name": "quantities",
									"type": "uint256[]"
								}
							],
							"name": "isRequestValidBatch",
							"outputs": [
								{
									"internalType": "bool[]",
									"name": "valid",
									"type": "bool[]"
								},
								{
									"components": [
										{
											"internalType": "address",
											"name": "creator",
											"type": "address"
										},
										{
											"internalType": "bool",
											"name": "isListing",
											"type": "bool"
										},
										{
											"internalType": "bool",
											"name": "isERC1155",
											"type": "bool"
										},
										{
											"internalType": "address",
											"name": "tokenContract",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "tokenId",
											"type": "uint256"
										},
										{
											"internalType": "uint256",
											"name": "quantity",
											"type": "uint256"
										},
										{
											"internalType": "uint96",
											"name": "expiry",
											"type": "uint96"
										},
										{
											"internalType": "address",
											"name": "currency",
											"type": "address"
										},
										{
											"internalType": "uint256",
											"name": "pricePerToken",
											"type": "uint256"
										}
									],
									"internalType": "struct ISequenceMarketStorage.Request[]",
									"name": "requests",
									"type": "tuple[]"
								}
							],
							"stateMutability": "view",
							"type": "function"
						}
					],
					"devdoc": {
						"kind": "dev",
						"methods": {
							"acceptRequest(uint256,uint256,address,uint256[],address[])": {
								"params": {
									"additionalFeeRecipients": "The addresses to send the additional fees to.",
									"additionalFees": "The additional fees to pay.",
									"quantity": "The quantity of tokens to accept.",
									"recipient": "The recipient of the accepted tokens.",
									"requestId": "The ID of the request."
								}
							},
							"acceptRequestBatch(uint256[],uint256[],address[],uint256[],address[])": {
								"details": "Additional fees are applied to each request.",
								"params": {
									"additionalFeeRecipients": "The addresses to send the additional fees to.",
									"additionalFees": "The additional fees to pay.",
									"quantities": "The quantities of tokens to accept.",
									"recipients": "The recipients of the accepted tokens.",
									"requestIds": "The IDs of the requests."
								}
							},
							"cancelRequest(uint256)": {
								"params": {
									"requestId": "The ID of the request."
								}
							},
							"cancelRequestBatch(uint256[])": {
								"params": {
									"requestIds": "The IDs of the requests."
								}
							},
							"createRequest((bool,bool,address,uint256,uint256,uint96,address,uint256))": {
								"params": {
									"request": "The request's details."
								},
								"returns": {
									"requestId": "The ID of the request."
								}
							},
							"createRequestBatch((bool,bool,address,uint256,uint256,uint96,address,uint256)[])": {
								"params": {
									"requests": "The requests' details."
								},
								"returns": {
									"requestIds": "The IDs of the requests."
								}
							},
							"getRequest(uint256)": {
								"params": {
									"requestId": "The ID of the request."
								},
								"returns": {
									"request": "The request."
								}
							},
							"getRequestBatch(uint256[])": {
								"params": {
									"requestIds": "The IDs of the requests."
								},
								"returns": {
									"requests": "The requests."
								}
							},
							"getRoyaltyInfo(address,uint256,uint256)": {
								"params": {
									"cost": "Amount of currency sent/received for the trade.",
									"tokenContract": "Address of the token being traded.",
									"tokenId": "The ID of the token."
								},
								"returns": {
									"recipient": "Address to send royalties to.",
									"royalty": "Amount of currency to be paid as royalties."
								}
							},
							"isRequestValid(uint256,uint256)": {
								"params": {
									"quantity": "The amount of tokens to exchange. 0 is assumed to be the request's available quantity.",
									"requestId": "The ID of the request."
								},
								"returns": {
									"request": "The request.",
									"valid": "The validity of the request."
								}
							},
							"isRequestValidBatch(uint256[],uint256[])": {
								"params": {
									"quantities": "The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.",
									"requestIds": "The IDs of the requests."
								},
								"returns": {
									"requests": "The requests.",
									"valid": "The validities of the requests."
								}
							}
						},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"additionalFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"additionalFeeRecipients\",\"type\":\"address[]\"}],\"name\":\"acceptRequest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"additionalFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"additionalFeeRecipients\",\"type\":\"address[]\"}],\"name\":\"acceptRequestBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"cancelRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"}],\"name\":\"cancelRequestBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.RequestParams\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"createRequest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.RequestParams[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"name\":\"createRequestBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"getRequest\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"}],\"name\":\"getRequestBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.Request[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invalidateRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"invalidateRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"isRequestValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.Request\",\"name\":\"request\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"requestIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"}],\"name\":\"isRequestValidBatch\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"valid\",\"type\":\"bool[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isERC1155\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"expiry\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequenceMarketStorage.Request[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"acceptRequest(uint256,uint256,address,uint256[],address[])\":{\"params\":{\"additionalFeeRecipients\":\"The addresses to send the additional fees to.\",\"additionalFees\":\"The additional fees to pay.\",\"quantity\":\"The quantity of tokens to accept.\",\"recipient\":\"The recipient of the accepted tokens.\",\"requestId\":\"The ID of the request.\"}},\"acceptRequestBatch(uint256[],uint256[],address[],uint256[],address[])\":{\"details\":\"Additional fees are applied to each request.\",\"params\":{\"additionalFeeRecipients\":\"The addresses to send the additional fees to.\",\"additionalFees\":\"The additional fees to pay.\",\"quantities\":\"The quantities of tokens to accept.\",\"recipients\":\"The recipients of the accepted tokens.\",\"requestIds\":\"The IDs of the requests.\"}},\"cancelRequest(uint256)\":{\"params\":{\"requestId\":\"The ID of the request.\"}},\"cancelRequestBatch(uint256[])\":{\"params\":{\"requestIds\":\"The IDs of the requests.\"}},\"createRequest((bool,bool,address,uint256,uint256,uint96,address,uint256))\":{\"params\":{\"request\":\"The request's details.\"},\"returns\":{\"requestId\":\"The ID of the request.\"}},\"createRequestBatch((bool,bool,address,uint256,uint256,uint96,address,uint256)[])\":{\"params\":{\"requests\":\"The requests' details.\"},\"returns\":{\"requestIds\":\"The IDs of the requests.\"}},\"getRequest(uint256)\":{\"params\":{\"requestId\":\"The ID of the request.\"},\"returns\":{\"request\":\"The request.\"}},\"getRequestBatch(uint256[])\":{\"params\":{\"requestIds\":\"The IDs of the requests.\"},\"returns\":{\"requests\":\"The requests.\"}},\"getRoyaltyInfo(address,uint256,uint256)\":{\"params\":{\"cost\":\"Amount of currency sent/received for the trade.\",\"tokenContract\":\"Address of the token being traded.\",\"tokenId\":\"The ID of the token.\"},\"returns\":{\"recipient\":\"Address to send royalties to.\",\"royalty\":\"Amount of currency to be paid as royalties.\"}},\"isRequestValid(uint256,uint256)\":{\"params\":{\"quantity\":\"The amount of tokens to exchange. 0 is assumed to be the request's available quantity.\",\"requestId\":\"The ID of the request.\"},\"returns\":{\"request\":\"The request.\",\"valid\":\"The validity of the request.\"}},\"isRequestValidBatch(uint256[],uint256[])\":{\"params\":{\"quantities\":\"The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.\",\"requestIds\":\"The IDs of the requests.\"},\"returns\":{\"requests\":\"The requests.\",\"valid\":\"The validities of the requests.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"acceptRequest(uint256,uint256,address,uint256[],address[])\":{\"notice\":\"Accepts a request.\"},\"acceptRequestBatch(uint256[],uint256[],address[],uint256[],address[])\":{\"notice\":\"Accepts requests.\"},\"cancelRequest(uint256)\":{\"notice\":\"Cancels a request.\"},\"cancelRequestBatch(uint256[])\":{\"notice\":\"Cancels requests.\"},\"createRequest((bool,bool,address,uint256,uint256,uint96,address,uint256))\":{\"notice\":\"Creates a request.A listing is when the maker is selling tokens for currency.An offer is when the maker is buying tokens with currency.\"},\"createRequestBatch((bool,bool,address,uint256,uint256,uint96,address,uint256)[])\":{\"notice\":\"Creates requests.\"},\"getRequest(uint256)\":{\"notice\":\"Gets a request.\"},\"getRequestBatch(uint256[])\":{\"notice\":\"Gets requests.\"},\"getRoyaltyInfo(address,uint256,uint256)\":{\"notice\":\"Returns the royalty details for the given token and cost.\"},\"invalidateRequests()\":{\"notice\":\"Invalidates all current requests for the msg.sender.\"},\"invalidateRequests(address)\":{\"notice\":\"Invalidates all current requests for a given `tokenContract` for the msg.sender.\"},\"isRequestValid(uint256,uint256)\":{\"notice\":\"Checks if a request is valid.A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\"},\"isRequestValidBatch(uint256[],uint256[])\":{\"notice\":\"Checks if requests are valid.A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/interfaces/ISequenceMarket.sol\":\"ISequenceMarketFunctions\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":0xsequence/=lib/0xsequence/\",\":@0xsequence/erc-1155/=lib/0xsequence/erc-1155/src/\",\":@0xsequence/erc20-meta-token/=lib/0xsequence/erc20-meta-token/src/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin/contracts/\",\":@uniswap/lib/=lib/uniswap-lib/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin/=lib/openzeppelin/\",\":uniswap-lib/=lib/uniswap-lib/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/ISequenceMarket.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.19;\\n\\ninterface ISequenceMarketStorage {\\n  /**\\n   * Request parameters.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct RequestParams {\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Request storage.\\n   * @param creator The address of the request creator.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct Request {\\n    address creator;\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Custom royalty parameters.\\n   * @param recipient Address to send the fees to.\\n   * @param fee Fee percentage with a 10000 basis (e.g. 0.3% is 30 and 1% is 100 and 100% is 10000).\\n   * @dev Used to store custom royalty settings for contracts do not support ERC2981.\\n   */\\n  struct CustomRoyalty {\\n    address recipient;\\n    uint96 fee;\\n  }\\n}\\n\\ninterface ISequenceMarketFunctions is ISequenceMarketStorage {\\n  /**\\n   * Creates a request.\\n   * @param request The request's details.\\n   * @return requestId The ID of the request.\\n   * @notice A listing is when the maker is selling tokens for currency.\\n   * @notice An offer is when the maker is buying tokens with currency.\\n   */\\n  function createRequest(RequestParams calldata request) external returns (uint256 requestId);\\n\\n  /**\\n   * Creates requests.\\n   * @param requests The requests' details.\\n   * @return requestIds The IDs of the requests.\\n   */\\n  function createRequestBatch(RequestParams[] calldata requests) external returns (uint256[] memory requestIds);\\n\\n  /**\\n   * Accepts a request.\\n   * @param requestId The ID of the request.\\n   * @param quantity The quantity of tokens to accept.\\n   * @param recipient The recipient of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   */\\n  function acceptRequest(\\n    uint256 requestId,\\n    uint256 quantity,\\n    address recipient,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external payable;\\n\\n  /**\\n   * Accepts requests.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The quantities of tokens to accept.\\n   * @param recipients The recipients of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   * @dev Additional fees are applied to each request.\\n   */\\n  function acceptRequestBatch(\\n    uint256[] calldata requestIds,\\n    uint256[] calldata quantities,\\n    address[] calldata recipients,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external;\\n\\n  /**\\n   * Cancels a request.\\n   * @param requestId The ID of the request.\\n   */\\n  function cancelRequest(uint256 requestId) external;\\n\\n  /**\\n   * Cancels requests.\\n   * @param requestIds The IDs of the requests.\\n   */\\n  function cancelRequestBatch(uint256[] calldata requestIds) external;\\n\\n  /**\\n   * Gets a request.\\n   * @param requestId The ID of the request.\\n   * @return request The request.\\n   */\\n  function getRequest(uint256 requestId) external view returns (Request memory request);\\n\\n  /**\\n   * Gets requests.\\n   * @param requestIds The IDs of the requests.\\n   * @return requests The requests.\\n   */\\n  function getRequestBatch(uint256[] calldata requestIds) external view returns (Request[] memory requests);\\n\\n  /**\\n   * Invalidates all current requests for the msg.sender.\\n   */\\n  function invalidateRequests() external;\\n\\n  /**\\n   * Invalidates all current requests for a given `tokenContract` for the msg.sender.\\n   */\\n  function invalidateRequests(address tokenContract) external;\\n\\n  /**\\n   * Checks if a request is valid.\\n   * @param requestId The ID of the request.\\n   * @param quantity The amount of tokens to exchange. 0 is assumed to be the request's available quantity.\\n   * @return valid The validity of the request.\\n   * @return request The request.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValid(uint256 requestId, uint256 quantity) external view returns (bool valid, Request memory request);\\n\\n  /**\\n   * Checks if requests are valid.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.\\n   * @return valid The validities of the requests.\\n   * @return requests The requests.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValidBatch(uint256[] calldata requestIds, uint256[] calldata quantities)\\n    external\\n    view\\n    returns (bool[] memory valid, Request[] memory requests);\\n\\n  /**\\n   * Returns the royalty details for the given token and cost.\\n   * @param tokenContract Address of the token being traded.\\n   * @param tokenId The ID of the token.\\n   * @param cost Amount of currency sent/received for the trade.\\n   * @return recipient Address to send royalties to.\\n   * @return royalty Amount of currency to be paid as royalties.\\n   */\\n  function getRoyaltyInfo(address tokenContract, uint256 tokenId, uint256 cost)\\n    external\\n    view\\n    returns (address recipient, uint256 royalty);\\n}\\n\\ninterface ISequenceMarketSignals {\\n  //\\n  // Events\\n  //\\n\\n  /// Emitted when a request is created.\\n  event RequestCreated(\\n    uint256 indexed requestId,\\n    address indexed creator,\\n    address indexed tokenContract,\\n    uint256 tokenId,\\n    bool isListing,\\n    uint256 quantity,\\n    address currency,\\n    uint256 pricePerToken,\\n    uint256 expiry\\n  );\\n\\n  /// Emitted when a request is accepted.\\n  event RequestAccepted(\\n    uint256 indexed requestId,\\n    address indexed buyer,\\n    address indexed tokenContract,\\n    address recipient,\\n    uint256 quantity,\\n    uint256 quantityRemaining\\n  );\\n\\n  /// Emitted when a request is cancelled.\\n  event RequestCancelled(uint256 indexed requestId, address indexed tokenContract);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, address indexed tokenContract, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when custom royalty settings are changed.\\n  event CustomRoyaltyChanged(address indexed tokenContract, address recipient, uint96 fee);\\n\\n  //\\n  // Errors\\n  //\\n\\n  /// Thrown when the contract address does not support the required interface.\\n  error UnsupportedContractInterface(address contractAddress, bytes4 interfaceId);\\n\\n  /// Thrown when the token approval is invalid.\\n  error InvalidTokenApproval(address tokenContract, uint256 tokenId, uint256 quantity, address owner);\\n\\n  /// Thrown when the currency address is invalid.\\n  error InvalidCurrency();\\n\\n  /// Thrown when the currency approval is invalid.\\n  error InvalidCurrencyApproval(address currency, uint256 quantity, address owner);\\n\\n  /// Thrown when request id is invalid.\\n  error InvalidRequestId(uint256 requestId);\\n\\n  /// Thrown when the parameters of a batch accept request are invalid.\\n  error InvalidBatchRequest();\\n\\n  /// Thrown when quantity is invalid.\\n  error InvalidQuantity();\\n\\n  /// Thrown when price is invalid.\\n  error InvalidPrice();\\n\\n  /// Thrown when royalty is invalid.\\n  error InvalidRoyalty();\\n\\n  /// Thrown when expiry is invalid.\\n  error InvalidExpiry();\\n\\n  /// Thrown when request has been explicitly invalidated.\\n  error Invalidated();\\n\\n  /// Thrown when the additional fees are invalid.\\n  error InvalidAdditionalFees();\\n}\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISequenceMarket is ISequenceMarketFunctions, ISequenceMarketSignals {}\\n\",\"keccak256\":\"0xfe58559dd9ea4a0e4765b98cd76a5ad0044e08d70b71fbf004d0decfc5635e14\",\"license\":\"Apache-2.0\"}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {
							"acceptRequest(uint256,uint256,address,uint256[],address[])": {
								"notice": "Accepts a request."
							},
							"acceptRequestBatch(uint256[],uint256[],address[],uint256[],address[])": {
								"notice": "Accepts requests."
							},
							"cancelRequest(uint256)": {
								"notice": "Cancels a request."
							},
							"cancelRequestBatch(uint256[])": {
								"notice": "Cancels requests."
							},
							"createRequest((bool,bool,address,uint256,uint256,uint96,address,uint256))": {
								"notice": "Creates a request.A listing is when the maker is selling tokens for currency.An offer is when the maker is buying tokens with currency."
							},
							"createRequestBatch((bool,bool,address,uint256,uint256,uint96,address,uint256)[])": {
								"notice": "Creates requests."
							},
							"getRequest(uint256)": {
								"notice": "Gets a request."
							},
							"getRequestBatch(uint256[])": {
								"notice": "Gets requests."
							},
							"getRoyaltyInfo(address,uint256,uint256)": {
								"notice": "Returns the royalty details for the given token and cost."
							},
							"invalidateRequests()": {
								"notice": "Invalidates all current requests for the msg.sender."
							},
							"invalidateRequests(address)": {
								"notice": "Invalidates all current requests for a given `tokenContract` for the msg.sender."
							},
							"isRequestValid(uint256,uint256)": {
								"notice": "Checks if a request is valid.A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable."
							},
							"isRequestValidBatch(uint256[],uint256[])": {
								"notice": "Checks if requests are valid.A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable."
							}
						},
						"version": 1
					}
				},
				"ISequenceMarketSignals": {
					"abi": [
						{
							"inputs": [],
							"name": "InvalidAdditionalFees",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidBatchRequest",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidCurrency",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "currency",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								}
							],
							"name": "InvalidCurrencyApproval",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidExpiry",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidPrice",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidQuantity",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								}
							],
							"name": "InvalidRequestId",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "InvalidRoyalty",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"internalType": "uint256",
									"name": "tokenId",
									"type": "uint256"
								},
								{
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"internalType": "address",
									"name": "owner",
									"type": "address"
								}
							],
							"name": "InvalidTokenApproval",
							"type": "error"
						},
						{
							"inputs": [],
							"name": "Invalidated",
							"type": "error"
						},
						{
							"inputs": [
								{
									"internalType": "address",
									"name": "contractAddress",
									"type": "address"
								},
								{
									"internalType": "bytes4",
									"name": "interfaceId",
									"type": "bytes4"
								}
							],
							"name": "UnsupportedContractInterface",
							"type": "error"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "address",
									"name": "recipient",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint96",
									"name": "fee",
									"type": "uint96"
								}
							],
							"name": "CustomRoyaltyChanged",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "buyer",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "address",
									"name": "recipient",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "quantityRemaining",
									"type": "uint256"
								}
							],
							"name": "RequestAccepted",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								}
							],
							"name": "RequestCancelled",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "requestId",
									"type": "uint256"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "creator",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "tokenId",
									"type": "uint256"
								},
								{
									"indexed": false,
									"internalType": "bool",
									"name": "isListing",
									"type": "bool"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "quantity",
									"type": "uint256"
								},
								{
									"indexed": false,
									"internalType": "address",
									"name": "currency",
									"type": "address"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "pricePerToken",
									"type": "uint256"
								},
								{
									"indexed": false,
									"internalType": "uint256",
									"name": "expiry",
									"type": "uint256"
								}
							],
							"name": "RequestCreated",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "creator",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "invalidatedBefore",
									"type": "uint256"
								}
							],
							"name": "RequestsInvalidated",
							"type": "event"
						},
						{
							"anonymous": false,
							"inputs": [
								{
									"indexed": true,
									"internalType": "address",
									"name": "creator",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "address",
									"name": "tokenContract",
									"type": "address"
								},
								{
									"indexed": true,
									"internalType": "uint256",
									"name": "invalidatedBefore",
									"type": "uint256"
								}
							],
							"name": "RequestsInvalidated",
							"type": "event"
						}
					],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"InvalidAdditionalFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBatchRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCurrency\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"InvalidCurrencyApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidExpiry\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"InvalidRequestId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRoyalty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"InvalidTokenApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalidated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"UnsupportedContractInterface\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"fee\",\"type\":\"uint96\"}],\"name\":\"CustomRoyaltyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantityRemaining\",\"type\":\"uint256\"}],\"name\":\"RequestAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"RequestCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isListing\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"RequestCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"invalidatedBefore\",\"type\":\"uint256\"}],\"name\":\"RequestsInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"invalidatedBefore\",\"type\":\"uint256\"}],\"name\":\"RequestsInvalidated\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"errors\":{\"InvalidAdditionalFees()\":[{\"notice\":\"Thrown when the additional fees are invalid.\"}],\"InvalidBatchRequest()\":[{\"notice\":\"Thrown when the parameters of a batch accept request are invalid.\"}],\"InvalidCurrency()\":[{\"notice\":\"Thrown when the currency address is invalid.\"}],\"InvalidCurrencyApproval(address,uint256,address)\":[{\"notice\":\"Thrown when the currency approval is invalid.\"}],\"InvalidExpiry()\":[{\"notice\":\"Thrown when expiry is invalid.\"}],\"InvalidPrice()\":[{\"notice\":\"Thrown when price is invalid.\"}],\"InvalidQuantity()\":[{\"notice\":\"Thrown when quantity is invalid.\"}],\"InvalidRequestId(uint256)\":[{\"notice\":\"Thrown when request id is invalid.\"}],\"InvalidRoyalty()\":[{\"notice\":\"Thrown when royalty is invalid.\"}],\"InvalidTokenApproval(address,uint256,uint256,address)\":[{\"notice\":\"Thrown when the token approval is invalid.\"}],\"Invalidated()\":[{\"notice\":\"Thrown when request has been explicitly invalidated.\"}],\"UnsupportedContractInterface(address,bytes4)\":[{\"notice\":\"Thrown when the contract address does not support the required interface.\"}]},\"events\":{\"CustomRoyaltyChanged(address,address,uint96)\":{\"notice\":\"Emitted when custom royalty settings are changed.\"},\"RequestAccepted(uint256,address,address,address,uint256,uint256)\":{\"notice\":\"Emitted when a request is accepted.\"},\"RequestCancelled(uint256,address)\":{\"notice\":\"Emitted when a request is cancelled.\"},\"RequestCreated(uint256,address,address,uint256,bool,uint256,address,uint256,uint256)\":{\"notice\":\"Emitted when a request is created.\"},\"RequestsInvalidated(address,address,uint256)\":{\"notice\":\"Emitted when a user bulk invalidates requests.\"},\"RequestsInvalidated(address,uint256)\":{\"notice\":\"Emitted when a user bulk invalidates requests.\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/interfaces/ISequenceMarket.sol\":\"ISequenceMarketSignals\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":0xsequence/=lib/0xsequence/\",\":@0xsequence/erc-1155/=lib/0xsequence/erc-1155/src/\",\":@0xsequence/erc20-meta-token/=lib/0xsequence/erc20-meta-token/src/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin/contracts/\",\":@uniswap/lib/=lib/uniswap-lib/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin/=lib/openzeppelin/\",\":uniswap-lib/=lib/uniswap-lib/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/ISequenceMarket.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.19;\\n\\ninterface ISequenceMarketStorage {\\n  /**\\n   * Request parameters.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct RequestParams {\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Request storage.\\n   * @param creator The address of the request creator.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct Request {\\n    address creator;\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Custom royalty parameters.\\n   * @param recipient Address to send the fees to.\\n   * @param fee Fee percentage with a 10000 basis (e.g. 0.3% is 30 and 1% is 100 and 100% is 10000).\\n   * @dev Used to store custom royalty settings for contracts do not support ERC2981.\\n   */\\n  struct CustomRoyalty {\\n    address recipient;\\n    uint96 fee;\\n  }\\n}\\n\\ninterface ISequenceMarketFunctions is ISequenceMarketStorage {\\n  /**\\n   * Creates a request.\\n   * @param request The request's details.\\n   * @return requestId The ID of the request.\\n   * @notice A listing is when the maker is selling tokens for currency.\\n   * @notice An offer is when the maker is buying tokens with currency.\\n   */\\n  function createRequest(RequestParams calldata request) external returns (uint256 requestId);\\n\\n  /**\\n   * Creates requests.\\n   * @param requests The requests' details.\\n   * @return requestIds The IDs of the requests.\\n   */\\n  function createRequestBatch(RequestParams[] calldata requests) external returns (uint256[] memory requestIds);\\n\\n  /**\\n   * Accepts a request.\\n   * @param requestId The ID of the request.\\n   * @param quantity The quantity of tokens to accept.\\n   * @param recipient The recipient of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   */\\n  function acceptRequest(\\n    uint256 requestId,\\n    uint256 quantity,\\n    address recipient,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external payable;\\n\\n  /**\\n   * Accepts requests.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The quantities of tokens to accept.\\n   * @param recipients The recipients of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   * @dev Additional fees are applied to each request.\\n   */\\n  function acceptRequestBatch(\\n    uint256[] calldata requestIds,\\n    uint256[] calldata quantities,\\n    address[] calldata recipients,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external;\\n\\n  /**\\n   * Cancels a request.\\n   * @param requestId The ID of the request.\\n   */\\n  function cancelRequest(uint256 requestId) external;\\n\\n  /**\\n   * Cancels requests.\\n   * @param requestIds The IDs of the requests.\\n   */\\n  function cancelRequestBatch(uint256[] calldata requestIds) external;\\n\\n  /**\\n   * Gets a request.\\n   * @param requestId The ID of the request.\\n   * @return request The request.\\n   */\\n  function getRequest(uint256 requestId) external view returns (Request memory request);\\n\\n  /**\\n   * Gets requests.\\n   * @param requestIds The IDs of the requests.\\n   * @return requests The requests.\\n   */\\n  function getRequestBatch(uint256[] calldata requestIds) external view returns (Request[] memory requests);\\n\\n  /**\\n   * Invalidates all current requests for the msg.sender.\\n   */\\n  function invalidateRequests() external;\\n\\n  /**\\n   * Invalidates all current requests for a given `tokenContract` for the msg.sender.\\n   */\\n  function invalidateRequests(address tokenContract) external;\\n\\n  /**\\n   * Checks if a request is valid.\\n   * @param requestId The ID of the request.\\n   * @param quantity The amount of tokens to exchange. 0 is assumed to be the request's available quantity.\\n   * @return valid The validity of the request.\\n   * @return request The request.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValid(uint256 requestId, uint256 quantity) external view returns (bool valid, Request memory request);\\n\\n  /**\\n   * Checks if requests are valid.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.\\n   * @return valid The validities of the requests.\\n   * @return requests The requests.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValidBatch(uint256[] calldata requestIds, uint256[] calldata quantities)\\n    external\\n    view\\n    returns (bool[] memory valid, Request[] memory requests);\\n\\n  /**\\n   * Returns the royalty details for the given token and cost.\\n   * @param tokenContract Address of the token being traded.\\n   * @param tokenId The ID of the token.\\n   * @param cost Amount of currency sent/received for the trade.\\n   * @return recipient Address to send royalties to.\\n   * @return royalty Amount of currency to be paid as royalties.\\n   */\\n  function getRoyaltyInfo(address tokenContract, uint256 tokenId, uint256 cost)\\n    external\\n    view\\n    returns (address recipient, uint256 royalty);\\n}\\n\\ninterface ISequenceMarketSignals {\\n  //\\n  // Events\\n  //\\n\\n  /// Emitted when a request is created.\\n  event RequestCreated(\\n    uint256 indexed requestId,\\n    address indexed creator,\\n    address indexed tokenContract,\\n    uint256 tokenId,\\n    bool isListing,\\n    uint256 quantity,\\n    address currency,\\n    uint256 pricePerToken,\\n    uint256 expiry\\n  );\\n\\n  /// Emitted when a request is accepted.\\n  event RequestAccepted(\\n    uint256 indexed requestId,\\n    address indexed buyer,\\n    address indexed tokenContract,\\n    address recipient,\\n    uint256 quantity,\\n    uint256 quantityRemaining\\n  );\\n\\n  /// Emitted when a request is cancelled.\\n  event RequestCancelled(uint256 indexed requestId, address indexed tokenContract);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, address indexed tokenContract, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when custom royalty settings are changed.\\n  event CustomRoyaltyChanged(address indexed tokenContract, address recipient, uint96 fee);\\n\\n  //\\n  // Errors\\n  //\\n\\n  /// Thrown when the contract address does not support the required interface.\\n  error UnsupportedContractInterface(address contractAddress, bytes4 interfaceId);\\n\\n  /// Thrown when the token approval is invalid.\\n  error InvalidTokenApproval(address tokenContract, uint256 tokenId, uint256 quantity, address owner);\\n\\n  /// Thrown when the currency address is invalid.\\n  error InvalidCurrency();\\n\\n  /// Thrown when the currency approval is invalid.\\n  error InvalidCurrencyApproval(address currency, uint256 quantity, address owner);\\n\\n  /// Thrown when request id is invalid.\\n  error InvalidRequestId(uint256 requestId);\\n\\n  /// Thrown when the parameters of a batch accept request are invalid.\\n  error InvalidBatchRequest();\\n\\n  /// Thrown when quantity is invalid.\\n  error InvalidQuantity();\\n\\n  /// Thrown when price is invalid.\\n  error InvalidPrice();\\n\\n  /// Thrown when royalty is invalid.\\n  error InvalidRoyalty();\\n\\n  /// Thrown when expiry is invalid.\\n  error InvalidExpiry();\\n\\n  /// Thrown when request has been explicitly invalidated.\\n  error Invalidated();\\n\\n  /// Thrown when the additional fees are invalid.\\n  error InvalidAdditionalFees();\\n}\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISequenceMarket is ISequenceMarketFunctions, ISequenceMarketSignals {}\\n\",\"keccak256\":\"0xfe58559dd9ea4a0e4765b98cd76a5ad0044e08d70b71fbf004d0decfc5635e14\",\"license\":\"Apache-2.0\"}},\"version\":1}",
					"userdoc": {
						"errors": {
							"InvalidAdditionalFees()": [
								{
									"notice": "Thrown when the additional fees are invalid."
								}
							],
							"InvalidBatchRequest()": [
								{
									"notice": "Thrown when the parameters of a batch accept request are invalid."
								}
							],
							"InvalidCurrency()": [
								{
									"notice": "Thrown when the currency address is invalid."
								}
							],
							"InvalidCurrencyApproval(address,uint256,address)": [
								{
									"notice": "Thrown when the currency approval is invalid."
								}
							],
							"InvalidExpiry()": [
								{
									"notice": "Thrown when expiry is invalid."
								}
							],
							"InvalidPrice()": [
								{
									"notice": "Thrown when price is invalid."
								}
							],
							"InvalidQuantity()": [
								{
									"notice": "Thrown when quantity is invalid."
								}
							],
							"InvalidRequestId(uint256)": [
								{
									"notice": "Thrown when request id is invalid."
								}
							],
							"InvalidRoyalty()": [
								{
									"notice": "Thrown when royalty is invalid."
								}
							],
							"InvalidTokenApproval(address,uint256,uint256,address)": [
								{
									"notice": "Thrown when the token approval is invalid."
								}
							],
							"Invalidated()": [
								{
									"notice": "Thrown when request has been explicitly invalidated."
								}
							],
							"UnsupportedContractInterface(address,bytes4)": [
								{
									"notice": "Thrown when the contract address does not support the required interface."
								}
							]
						},
						"events": {
							"CustomRoyaltyChanged(address,address,uint96)": {
								"notice": "Emitted when custom royalty settings are changed."
							},
							"RequestAccepted(uint256,address,address,address,uint256,uint256)": {
								"notice": "Emitted when a request is accepted."
							},
							"RequestCancelled(uint256,address)": {
								"notice": "Emitted when a request is cancelled."
							},
							"RequestCreated(uint256,address,address,uint256,bool,uint256,address,uint256,uint256)": {
								"notice": "Emitted when a request is created."
							},
							"RequestsInvalidated(address,address,uint256)": {
								"notice": "Emitted when a user bulk invalidates requests."
							},
							"RequestsInvalidated(address,uint256)": {
								"notice": "Emitted when a user bulk invalidates requests."
							}
						},
						"kind": "user",
						"methods": {},
						"version": 1
					}
				},
				"ISequenceMarketStorage": {
					"abi": [],
					"devdoc": {
						"kind": "dev",
						"methods": {},
						"version": 1
					},
					"evm": {
						"bytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						},
						"deployedBytecode": {
							"functionDebugData": {},
							"generatedSources": [],
							"immutableReferences": {},
							"linkReferences": {},
							"object": "",
							"opcodes": "",
							"sourceMap": ""
						}
					},
					"metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/interfaces/ISequenceMarket.sol\":\"ISequenceMarketStorage\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":0xsequence/=lib/0xsequence/\",\":@0xsequence/erc-1155/=lib/0xsequence/erc-1155/src/\",\":@0xsequence/erc20-meta-token/=lib/0xsequence/erc20-meta-token/src/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin/contracts/\",\":@uniswap/lib/=lib/uniswap-lib/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin/=lib/openzeppelin/\",\":uniswap-lib/=lib/uniswap-lib/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/ISequenceMarket.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.19;\\n\\ninterface ISequenceMarketStorage {\\n  /**\\n   * Request parameters.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct RequestParams {\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Request storage.\\n   * @param creator The address of the request creator.\\n   * @param isListing True if the request is a listing, false if it is an offer.\\n   * @param isERC1155 True if the token is an ERC1155 token, false if it is an ERC721 token.\\n   * @param tokenContract The address of the token contract.\\n   * @param tokenId The ID of the token.\\n   * @param quantity The quantity of tokens.\\n   * @param expiry The expiry of the request.\\n   * @param currency The address of the currency. address(0) for native token.\\n   * @param pricePerToken The price per token, including royalty fees.\\n   */\\n  struct Request {\\n    address creator;\\n    bool isListing;\\n    bool isERC1155;\\n    address tokenContract;\\n    uint256 tokenId;\\n    uint256 quantity;\\n    uint96 expiry;\\n    address currency;\\n    uint256 pricePerToken;\\n  }\\n\\n  /**\\n   * Custom royalty parameters.\\n   * @param recipient Address to send the fees to.\\n   * @param fee Fee percentage with a 10000 basis (e.g. 0.3% is 30 and 1% is 100 and 100% is 10000).\\n   * @dev Used to store custom royalty settings for contracts do not support ERC2981.\\n   */\\n  struct CustomRoyalty {\\n    address recipient;\\n    uint96 fee;\\n  }\\n}\\n\\ninterface ISequenceMarketFunctions is ISequenceMarketStorage {\\n  /**\\n   * Creates a request.\\n   * @param request The request's details.\\n   * @return requestId The ID of the request.\\n   * @notice A listing is when the maker is selling tokens for currency.\\n   * @notice An offer is when the maker is buying tokens with currency.\\n   */\\n  function createRequest(RequestParams calldata request) external returns (uint256 requestId);\\n\\n  /**\\n   * Creates requests.\\n   * @param requests The requests' details.\\n   * @return requestIds The IDs of the requests.\\n   */\\n  function createRequestBatch(RequestParams[] calldata requests) external returns (uint256[] memory requestIds);\\n\\n  /**\\n   * Accepts a request.\\n   * @param requestId The ID of the request.\\n   * @param quantity The quantity of tokens to accept.\\n   * @param recipient The recipient of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   */\\n  function acceptRequest(\\n    uint256 requestId,\\n    uint256 quantity,\\n    address recipient,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external payable;\\n\\n  /**\\n   * Accepts requests.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The quantities of tokens to accept.\\n   * @param recipients The recipients of the accepted tokens.\\n   * @param additionalFees The additional fees to pay.\\n   * @param additionalFeeRecipients The addresses to send the additional fees to.\\n   * @dev Additional fees are applied to each request.\\n   */\\n  function acceptRequestBatch(\\n    uint256[] calldata requestIds,\\n    uint256[] calldata quantities,\\n    address[] calldata recipients,\\n    uint256[] calldata additionalFees,\\n    address[] calldata additionalFeeRecipients\\n  )\\n    external;\\n\\n  /**\\n   * Cancels a request.\\n   * @param requestId The ID of the request.\\n   */\\n  function cancelRequest(uint256 requestId) external;\\n\\n  /**\\n   * Cancels requests.\\n   * @param requestIds The IDs of the requests.\\n   */\\n  function cancelRequestBatch(uint256[] calldata requestIds) external;\\n\\n  /**\\n   * Gets a request.\\n   * @param requestId The ID of the request.\\n   * @return request The request.\\n   */\\n  function getRequest(uint256 requestId) external view returns (Request memory request);\\n\\n  /**\\n   * Gets requests.\\n   * @param requestIds The IDs of the requests.\\n   * @return requests The requests.\\n   */\\n  function getRequestBatch(uint256[] calldata requestIds) external view returns (Request[] memory requests);\\n\\n  /**\\n   * Invalidates all current requests for the msg.sender.\\n   */\\n  function invalidateRequests() external;\\n\\n  /**\\n   * Invalidates all current requests for a given `tokenContract` for the msg.sender.\\n   */\\n  function invalidateRequests(address tokenContract) external;\\n\\n  /**\\n   * Checks if a request is valid.\\n   * @param requestId The ID of the request.\\n   * @param quantity The amount of tokens to exchange. 0 is assumed to be the request's available quantity.\\n   * @return valid The validity of the request.\\n   * @return request The request.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValid(uint256 requestId, uint256 quantity) external view returns (bool valid, Request memory request);\\n\\n  /**\\n   * Checks if requests are valid.\\n   * @param requestIds The IDs of the requests.\\n   * @param quantities The amount of tokens to exchange per request. 0 is assumed to be the request's available quantity.\\n   * @return valid The validities of the requests.\\n   * @return requests The requests.\\n   * @notice A request is valid if it is active, has not expired and give amount of tokens (currency for offers, tokens for listings) are transferrable.\\n   */\\n  function isRequestValidBatch(uint256[] calldata requestIds, uint256[] calldata quantities)\\n    external\\n    view\\n    returns (bool[] memory valid, Request[] memory requests);\\n\\n  /**\\n   * Returns the royalty details for the given token and cost.\\n   * @param tokenContract Address of the token being traded.\\n   * @param tokenId The ID of the token.\\n   * @param cost Amount of currency sent/received for the trade.\\n   * @return recipient Address to send royalties to.\\n   * @return royalty Amount of currency to be paid as royalties.\\n   */\\n  function getRoyaltyInfo(address tokenContract, uint256 tokenId, uint256 cost)\\n    external\\n    view\\n    returns (address recipient, uint256 royalty);\\n}\\n\\ninterface ISequenceMarketSignals {\\n  //\\n  // Events\\n  //\\n\\n  /// Emitted when a request is created.\\n  event RequestCreated(\\n    uint256 indexed requestId,\\n    address indexed creator,\\n    address indexed tokenContract,\\n    uint256 tokenId,\\n    bool isListing,\\n    uint256 quantity,\\n    address currency,\\n    uint256 pricePerToken,\\n    uint256 expiry\\n  );\\n\\n  /// Emitted when a request is accepted.\\n  event RequestAccepted(\\n    uint256 indexed requestId,\\n    address indexed buyer,\\n    address indexed tokenContract,\\n    address recipient,\\n    uint256 quantity,\\n    uint256 quantityRemaining\\n  );\\n\\n  /// Emitted when a request is cancelled.\\n  event RequestCancelled(uint256 indexed requestId, address indexed tokenContract);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when a user bulk invalidates requests.\\n  event RequestsInvalidated(address indexed creator, address indexed tokenContract, uint256 indexed invalidatedBefore);\\n\\n  /// Emitted when custom royalty settings are changed.\\n  event CustomRoyaltyChanged(address indexed tokenContract, address recipient, uint96 fee);\\n\\n  //\\n  // Errors\\n  //\\n\\n  /// Thrown when the contract address does not support the required interface.\\n  error UnsupportedContractInterface(address contractAddress, bytes4 interfaceId);\\n\\n  /// Thrown when the token approval is invalid.\\n  error InvalidTokenApproval(address tokenContract, uint256 tokenId, uint256 quantity, address owner);\\n\\n  /// Thrown when the currency address is invalid.\\n  error InvalidCurrency();\\n\\n  /// Thrown when the currency approval is invalid.\\n  error InvalidCurrencyApproval(address currency, uint256 quantity, address owner);\\n\\n  /// Thrown when request id is invalid.\\n  error InvalidRequestId(uint256 requestId);\\n\\n  /// Thrown when the parameters of a batch accept request are invalid.\\n  error InvalidBatchRequest();\\n\\n  /// Thrown when quantity is invalid.\\n  error InvalidQuantity();\\n\\n  /// Thrown when price is invalid.\\n  error InvalidPrice();\\n\\n  /// Thrown when royalty is invalid.\\n  error InvalidRoyalty();\\n\\n  /// Thrown when expiry is invalid.\\n  error InvalidExpiry();\\n\\n  /// Thrown when request has been explicitly invalidated.\\n  error Invalidated();\\n\\n  /// Thrown when the additional fees are invalid.\\n  error InvalidAdditionalFees();\\n}\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface ISequenceMarket is ISequenceMarketFunctions, ISequenceMarketSignals {}\\n\",\"keccak256\":\"0xfe58559dd9ea4a0e4765b98cd76a5ad0044e08d70b71fbf004d0decfc5635e14\",\"license\":\"Apache-2.0\"}},\"version\":1}",
					"userdoc": {
						"kind": "user",
						"methods": {},
						"version": 1
					}
				}
			}
		},
		"sources": {
			"contracts/BatchPayableHelper.sol": {
				"id": 0
			},
			"contracts/interfaces/ISequenceMarket.sol": {
				"id": 1
			}
		}
	}
}