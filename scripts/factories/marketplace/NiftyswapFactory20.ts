import type { EtherscanVerificationRequest } from '@0xsequence/solidity-deployer'
import { ContractFactory, type ethers } from 'ethers'

// https://github.com/0xsequence/niftyswap/blob/1d3f8370d0dce384ea4f3bb0944a2644011751b2/src/contracts/exchange/NiftyswapFactory20.sol

const abi = [
  {
    inputs: [
      {
        internalType: 'address',
        name: '_admin',
        type: 'address'
      }
    ],
    stateMutability: 'nonpayable',
    type: 'constructor'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'address',
        name: 'metadataContract',
        type: 'address'
      }
    ],
    name: 'MetadataContractChanged',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'address',
        name: 'token',
        type: 'address'
      },
      {
        indexed: true,
        internalType: 'address',
        name: 'currency',
        type: 'address'
      },
      {
        indexed: true,
        internalType: 'uint256',
        name: 'salt',
        type: 'uint256'
      },
      {
        indexed: false,
        internalType: 'uint256',
        name: 'lpFee',
        type: 'uint256'
      },
      {
        indexed: false,
        internalType: 'address',
        name: 'exchange',
        type: 'address'
      }
    ],
    name: 'NewExchange',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'address',
        name: 'previousOwner',
        type: 'address'
      },
      {
        indexed: true,
        internalType: 'address',
        name: 'newOwner',
        type: 'address'
      }
    ],
    name: 'OwnershipTransferred',
    type: 'event'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '_token',
        type: 'address'
      },
      {
        internalType: 'address',
        name: '_currency',
        type: 'address'
      },
      {
        internalType: 'uint256',
        name: '_lpFee',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '_instance',
        type: 'uint256'
      }
    ],
    name: 'createExchange',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [],
    name: 'getOwner',
    outputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '_token',
        type: 'address'
      },
      {
        internalType: 'address',
        name: '_currency',
        type: 'address'
      }
    ],
    name: 'getPairExchanges',
    outputs: [
      {
        internalType: 'address[]',
        name: '',
        type: 'address[]'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'metadataProvider',
    outputs: [
      {
        internalType: 'contract IERC1155Metadata',
        name: '',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'contract IERC1155Metadata',
        name: '_contract',
        type: 'address'
      }
    ],
    name: 'setMetadataContract',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      },
      {
        internalType: 'address',
        name: '',
        type: 'address'
      },
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256'
      },
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256'
      }
    ],
    name: 'tokensToExchange',
    outputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '_newOwner',
        type: 'address'
      }
    ],
    name: 'transferOwnership',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  }
]

export const NIFTYSWAP_FACTORY_20_DEFAULT_ADMIN = '0xec32359f21cf24e7d5097813577ee1f2c22fa57b'

export class NiftyswapFactory20 extends ContractFactory {
  constructor(signer: ethers.Signer) {
    super(
      abi,
      '0x608060405234801561001057600080fd5b506040516160123803806160128339818101604052602081101561003357600080fd5b5051600080546001600160a01b0319166001600160a01b03831690811782556040518392907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a35050615f848061008e6000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c8063bcb9bfa71161005b578063bcb9bfa714610162578063d3d72d2a1461019e578063e5187f43146101a6578063f2fde38b146101cc5761007d565b8063893d20e814610082578063968bd691146100a65780639b307388146100e4575b600080fd5b61008a6101f2565b604080516001600160a01b039092168252519081900360200190f35b6100e2600480360360808110156100bc57600080fd5b506001600160a01b03813581169160208101359091169060408101359060600135610201565b005b610112600480360360408110156100fa57600080fd5b506001600160a01b03813581169160200135166103ae565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561014e578181015183820152602001610136565b505050509050019250505060405180910390f35b61008a6004803603608081101561017857600080fd5b506001600160a01b03813581169160208101359091169060408101359060600135610431565b61008a610466565b6100e2600480360360208110156101bc57600080fd5b50356001600160a01b0316610475565b6100e2600480360360208110156101e257600080fd5b50356001600160a01b031661050b565b6000546001600160a01b031690565b6001600160a01b038481166000908152600160209081526040808320878516845282528083208684528252808320858452909152902054161561028b576040805162461bcd60e51b815260206004820152600660248201527f4e46323023310000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b600084848460405161029c906105b6565b80846001600160a01b03168152602001836001600160a01b031681526020018281526020019350505050604051809103906000f0801580156102e2573d6000803e3d6000fd5b506001600160a01b0380871660008181526001602081815260408084208b87168086529083528185208b865283528185208a86528352818520805497891673ffffffffffffffffffffffffffffffffffffffff19988916811790915586865260028452828620828752845282862080549586018155865294839020909301805490961684179095558451898152908101929092528351949550869490937f86ced3b5b0ff3a7cb4c6f9b6ec3ee75869dcd58bebd573ce9e6feedc2b7ec2c8928290030190a45050505050565b6001600160a01b03808316600090815260026020908152604080832093851683529281529082902080548351818402810184019094528084526060939283018282801561042457602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610406575b5050505050905092915050565b60016020908152600094855260408086208252938552838520815291845282842090915282529020546001600160a01b031681565b6003546001600160a01b031690565b6000546001600160a01b031633146104a85760405162461bcd60e51b815260040161049f90610621565b60405180910390fd5b6040516001600160a01b038216907f77a13e6b663954e04643194e292dcbc227c9e00893741047e969a5d206d4986990600090a26003805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6000546001600160a01b031633146105355760405162461bcd60e51b815260040161049f90610621565b6001600160a01b03811661055b5760405162461bcd60e51b815260040161049f906105c4565b6000805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383811691821780845560405192939116917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a350565b6158d0806200067f83390190565b6020808252602a908201527f4f776e61626c65237472616e736665724f776e6572736869703a20494e56414c60408201527f49445f4144445245535300000000000000000000000000000000000000000000606082015260800190565b60208082526026908201527f4f776e61626c65236f6e6c794f776e65723a2053454e4445525f49535f4e4f5460408201527f5f4f574e4552000000000000000000000000000000000000000000000000000060608201526080019056fe6101206040523480156200001257600080fd5b50604051620058d0380380620058d083398101604081905262000035916200028e565b336001600081905550806001600160a01b031663893d20e86040518163ffffffff1660e01b815260040160206040518083038186803b1580156200007857600080fd5b505afa925050508015620000ab575060408051601f3d908101601f19168201909252620000a8918101906200026a565b60015b620000d35760405162461bcd60e51b8152600401620000ca9062000345565b60405180910390fd5b50600380546001600160a01b0319166001600160a01b0383169081179091556040516000907ffca4bc097843727c93a8ab8d241a38481cccf8ec96dda1a342574712cfe8eb40908290a3506001600160a01b038316158015906200013f57506001600160a01b03821615155b6200015e5760405162461bcd60e51b8152600401620000ca9062000325565b6103e8811115620001835760405162461bcd60e51b8152600401620000ca9062000305565b33606090811b60c0526001600160601b031984821b81166080529083901b1660a0526103e881900360e0526040516301ffc9a760e01b81526001600160a01b038416906301ffc9a790620001e39063152a902d60e11b90600401620002f0565b60206040518083038186803b158015620001fc57600080fd5b505afa9250505080156200022f575060408051601f3d908101601f191682019092526200022c91810190620002ce565b60015b6200023a5762000244565b151560f81b610100525b50505062000363565b80516001600160a01b03811681146200026557600080fd5b919050565b6000602082840312156200027c578081fd5b62000287826200024d565b9392505050565b600080600060608486031215620002a3578182fd5b620002ae846200024d565b9250620002be602085016200024d565b9150604084015190509250925092565b600060208284031215620002e0578081fd5b8151801515811462000287578182fd5b6001600160e01b031991909116815260200190565b60208082526006908201526527229918119960d11b604082015260600190565b6020808252600690820152654e453230233160d01b604082015260600190565b602080825260049082015263444f233160e01b604082015260600190565b60805160601c60a05160601c60c05160601c60e0516101005160f81c6154bd62000413600039806115bd5250806108f65280610aa95280611b425250806105ac5280610eeb5250806109395280610e8a52806113d05280611753528061259c528061298a5280612da252806132c35250806106bc5280610b635280610f895280611125528061128c528061149452806115f85280612ddf528061324852806135fc52806137e952506154bd6000f3fe608060405234801561001057600080fd5b50600436106101ee5760003560e01c8063893d20e81161010f578063be571468116100a2578063e985e9c511610071578063e985e9c51461043d578063f23a6e6114610450578063f242432a14610463578063fca16c3b14610476576101ee565b8063be571468146103ee578063c7ed115e14610401578063d93e8aaa14610422578063e523d3fc14610435576101ee565b8063a9c2e36c116100de578063a9c2e36c146103a0578063aeaad208146103a8578063b5de3d14146103bb578063bc197c81146103ce576101ee565b8063893d20e81461035f578063a22cb46514610367578063a63138751461037a578063a7380f6e1461038d576101ee565b80632eb2c2d6116101875780634e1273f4116101565780634e1273f4146103135780636ee8e13414610326578063863ed3001461033957806389382ca01461034c576101ee565b80632eb2c2d6146102db5780633750a8bd146102f057806338b49e2d146102f857806346adf5ca1461030b576101ee565b806310fe9ae8116101c357806310fe9ae81461028057806314556a5614610295578063209b96c5146102a85780632bef5e38146102c8576101ee565b80628e09d81461020f578062fdd58e1461022d57806301ffc9a7146102405780630e89341c14610260575b60405162461bcd60e51b815260040161020690614c9a565b60405180910390fd5b610217610489565b6040516102249190615154565b60405180910390f35b61021761023b36600461418b565b61048f565b61025361024e366004614410565b6104ba565b6040516102249190614a21565b61027361026e3660046146e7565b6105a8565b6040516102249190614a41565b6102886106ba565b604051610224919061482a565b6102176102a3366004613fdd565b6106de565b6102bb6102b6366004614244565b6106fe565b60405161022491906148d4565b6102bb6102d6366004614244565b61079f565b6102ee6102e936600461404d565b610837565b005b6102176108f4565b610217610306366004613fdd565b61091c565b610288610937565b6102bb6103213660046141e3565b61095b565b61021761033436600461475c565b610a74565b6102bb610347366004614284565b610b0c565b6102ee61035a366004613fdd565b610c92565b610288610d58565b6102ee61037536600461415e565b610df3565b6102ee610388366004613fdd565b610e61565b61021761039b366004614787565b610eb4565b610288610ee9565b6102176103b6366004614787565b610f0d565b6102ee6103c9366004614717565b610f37565b6103e16103dc36600461404d565b6110cf565b6040516102249190614a2c565b6102bb6103fc366004614284565b61143d565b61041461040f36600461473b565b6115b8565b604051610224929190614896565b6102bb610430366004614328565b61170b565b610288611934565b61025361044b366004614015565b611943565b6103e161045e3660046140f7565b611971565b6102ee6104713660046140f7565b611a3e565b61021761048436600461475c565b611af4565b60045490565b6001600160a01b03821660009081526001602090815260408083208484529091529020545b92915050565b60006001600160e01b031982167f36372b0700000000000000000000000000000000000000000000000000000000148061050457506001600160e01b031982166301ffc9a760e01b145b8061053857506001600160e01b031982167fd9b67a2600000000000000000000000000000000000000000000000000000000145b8061056c57506001600160e01b031982167f4e2312e000000000000000000000000000000000000000000000000000000000145b806105a057506001600160e01b031982167f0e89341c00000000000000000000000000000000000000000000000000000000145b90505b919050565b60607f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663d3d72d2a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561060357600080fd5b505afa158015610617573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061063b9190613ff9565b6001600160a01b0316630e89341c836040518263ffffffff1660e01b81526004016106669190615154565b60006040518083038186803b15801561067e57600080fd5b505afa158015610692573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526105a09190810190614674565b7f000000000000000000000000000000000000000000000000000000000000000090565b6001600160a01b0316600090815260086020526040902054612710900490565b606081818167ffffffffffffffff8111801561071957600080fd5b50604051908082528060200260200182016040528015610743578160200160208202803683370190505b50905060005b82811015610796576007600087878481811061076157fe5b9050602002013581526020019081526020016000205482828151811061078357fe5b6020908102919091010152600101610749565b50949350505050565b606081818167ffffffffffffffff811180156107ba57600080fd5b506040519080825280602002602001820160405280156107e4578160200160208202803683370190505b50905060005b82811015610796576006600087878481811061080257fe5b9050602002013581526020019081526020016000205482828151811061082457fe5b60209081029190910101526001016107ea565b336001600160a01b038616148061085357506108538533611943565b61088e5760405162461bcd60e51b815260040180806020018281038252602f815260200180615383602f913960400191505060405180910390fd5b6001600160a01b0384166108d35760405162461bcd60e51b81526004018080602001828103825260308152602001806152f76030913960400191505060405180910390fd5b6108df85858585611b77565b6108ed858585855a86611e12565b5050505050565b7f00000000000000000000000000000000000000000000000000000000000000006103e80390565b6001600160a01b031660009081526008602052604090205490565b7f000000000000000000000000000000000000000000000000000000000000000090565b6060815183511461099d5760405162461bcd60e51b815260040180806020018281038252602c815260200180615357602c913960400191505060405180910390fd5b6060835167ffffffffffffffff811180156109b757600080fd5b506040519080825280602002602001820160405280156109e1578160200160208202803683370190505b50905060005b8451811015610a6c5760016000868381518110610a0057fe5b60200260200101516001600160a01b03166001600160a01b031681526020019081526020016000206000858381518110610a3657fe5b6020026020010151815260200190815260200160002054828281518110610a5957fe5b60209081029190910101526001016109e7565b509392505050565b60008083118015610a855750600082115b610aa15760405162461bcd60e51b815260040161020690614cd1565b6000610acd857f000000000000000000000000000000000000000000000000000000000000000061200a565b90506000610adb828561200a565b90506000610af583610aef886103e861200a565b90612080565b9050808281610b0057fe5b04979650505050505050565b606083818167ffffffffffffffff81118015610b2757600080fd5b50604051908082528060200260200182016040528015610b51578160200160208202803683370190505b50905060005b82811015610c875760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031662fdd58e308b8b86818110610b9c57fe5b905060200201356040518363ffffffff1660e01b8152600401610bc0929190614896565b60206040518083038186803b158015610bd857600080fd5b505afa158015610bec573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c1091906146ff565b9050610c67898984818110610c2157fe5b90506020020135888885818110610c3457fe5b9050602002013583600760008e8e89818110610c4c57fe5b90506020020135815260200190815260200160002054610eb4565b838381518110610c7357fe5b602090810291909101015250600101610b57565b509695505050505050565b610c9a610d58565b6001600160a01b0316336001600160a01b031614610cca5760405162461bcd60e51b815260040161020690614aab565b6001600160a01b038116610cf05760405162461bcd60e51b815260040161020690614b19565b600380547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0383811691821792839055604051919216907ffca4bc097843727c93a8ab8d241a38481cccf8ec96dda1a342574712cfe8eb4090600090a350565b600354604080517f893d20e800000000000000000000000000000000000000000000000000000000815290516000926001600160a01b03169163893d20e8916004808301926020929190829003018186803b158015610db657600080fd5b505afa158015610dca573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dee9190613ff9565b905090565b3360008181526002602090815260408083206001600160a01b03871680855290835292819020805460ff1916861515908117909155815190815290519293927f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31929181900390910190a35050565b6001600160a01b0381166000908152600860205260409020805461271080820690925504610eb07f000000000000000000000000000000000000000000000000000000000000000083836120da565b5050565b600080610ec2858585610a74565b90506000610ed087836115b8565b9150610ede90508282612255565b979650505050505050565b7f000000000000000000000000000000000000000000000000000000000000000090565b600080610f1b858585611af4565b90506000610f2987836115b8565b9150610ede90508282612080565b610f3f610d58565b6001600160a01b0316336001600160a01b031614610f6f5760405162461bcd60e51b815260040161020690614aab565b6040516301ffc9a760e01b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906301ffc9a790610fc59063152a902d60e11b90600401614a2c565b60206040518083038186803b158015610fdd57600080fd5b505afa158015610ff1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061101591906143f4565b905080156110355760405162461bcd60e51b815260040161020690614e52565b6109c48311156110575760405162461bcd60e51b81526004016102069061511d565b6004839055600580547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0384169081179091556040517f02365318429bf1d603e8383b62068288a077545c5c9e709201d563b3f56ce2b3906110c2908690615154565b60405180910390a2505050565b600080828060200190518101906110e6919061442c565b90506001600160e01b031981167fade79c7a00000000000000000000000000000000000000000000000000000000141561124f57336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146111625760405162461bcd60e51b815260040161020690614ec0565b61116a613d02565b8380602001905181019061117e919061459d565b8051909250600091506001600160a01b03161561119c57815161119e565b875b9050816060015151826040015151146111c95760405162461bcd60e51b815260040161020690614e1b565b60606111ea88888560200151866080015186886040015189606001516122b2565b9050816001600160a01b0316896001600160a01b03167fb57378559821141c0e7ae964206b7523234d19e5783ade99b3d665eee495c9978a8a858860400151896060015160405161123f9594939291906149b4565b60405180910390a350505061142a565b6001600160e01b031981167f82da2b7300000000000000000000000000000000000000000000000000000000141561130657336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146112c95760405162461bcd60e51b815260040161020690614de4565b6112d1613d3a565b838060200190518101906112e59190614448565b905080915050611300878787846000015185602001516125d5565b5061142a565b6001600160e01b031981167f5c0bf259000000000000000000000000000000000000000000000000000000001415611393573330146113575760405162461bcd60e51b8152600401610206906150e6565b61135f613d54565b8380602001905181019061137391906144e1565b905080915050611300878787846000015185602001518660400151612a22565b6001600160e01b031981167fc8c323f900000000000000000000000000000000000000000000000000000000141561141257336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461140d5760405162461bcd60e51b815260040161020690614c63565b61142a565b60405162461bcd60e51b815260040161020690614e89565b5063bc197c8160e01b9695505050505050565b606083818167ffffffffffffffff8111801561145857600080fd5b50604051908082528060200260200182016040528015611482578160200160208202803683370190505b50905060005b82811015610c875760007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031662fdd58e308b8b868181106114cd57fe5b905060200201356040518363ffffffff1660e01b81526004016114f1929190614896565b60206040518083038186803b15801561150957600080fd5b505afa15801561151d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154191906146ff565b905061159889898481811061155257fe5b9050602002013588888581811061156557fe5b90506020020135600760008d8d8881811061157c57fe5b9050602002013581526020019081526020016000205484610f0d565b8383815181106115a457fe5b602090810291909101015250600101611488565b6000807f0000000000000000000000000000000000000000000000000000000000000000156116e35760405163152a902d60e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690632a55205a9061162f908790879060040161515d565b604080518083038186803b15801561164657600080fd5b505afa925050508015611676575060408051601f3d908101601f19168201909252611673918101906141b6565b60015b6116ac576005546004546001600160a01b03909116906127109061169b90869061200a565b816116a257fe5b0491509150611704565b60006127106116bd876109c461200a565b816116c457fe5b049050828183116116d557826116d7565b815b94509450505050611704565b6005546004546001600160a01b03909116906127109061169b90869061200a565b9250929050565b60604285101561172d5760405162461bcd60e51b815260040161020690614ae2565b600088511161174e5760405162461bcd60e51b815260040161020690614d76565b61177a7f0000000000000000000000000000000000000000000000000000000000000000333089612ea3565b60006001600160a01b038516156117915784611793565b335b84518451919250889181146117ba5760405162461bcd60e51b815260040161020690614f9c565b60005b818110156118c05760008682815181106117d357fe5b602002602001015111156118b8576118078682815181106117f057fe5b60200260200101518461225590919063ffffffff16565b925061187b61183461271088848151811061181e57fe5b602002602001015161200a90919063ffffffff16565b600860008a858151811061184457fe5b60200260200101516001600160a01b03166001600160a01b031681526020019081526020016000205461208090919063ffffffff16565b6008600089848151811061188b57fe5b60200260200101516001600160a01b03166001600160a01b03168152602001908152602001600020819055505b6001016117bd565b5060606118d08c8c858c88613026565b9050836001600160a01b0316336001600160a01b03167f28fb4c13c000d11e44ba9e45029f385ed02ffeae62dc5704e2c0706a4dab5ecb8e8e858c8c60405161191d9594939291906149b4565b60405180910390a39b9a5050505050505050505050565b6005546001600160a01b031690565b6001600160a01b03918216600090815260026020908152604080832093909416825291909152205460ff1690565b6040805160018082528183019092526000916060919060208083019080368337505060408051600180825281830190925292935060609291506020808301908036833701905050905085826000815181106119c857fe5b60200260200101818152505084816000815181106119e257fe5b6020026020010181815250506119fb88888484886110cf565b6001600160e01b03191663bc197c8160e01b14611a2a5760405162461bcd60e51b815260040161020690614ef7565b5063f23a6e6160e01b979650505050505050565b336001600160a01b0386161480611a5a5750611a5a8533611943565b611a955760405162461bcd60e51b815260040180806020018281038252602a815260200180615267602a913960400191505060405180910390fd5b6001600160a01b038416611ada5760405162461bcd60e51b815260040180806020018281038252602b81526020018061523c602b913960400191505060405180910390fd5b611ae6858585856132fa565b6108ed858585855a866133db565b60008083118015611b055750600082115b611b215760405162461bcd60e51b81526004016102069061500a565b6000611b396103e8611b33868861200a565b9061200a565b90506000611b6b7f0000000000000000000000000000000000000000000000000000000000000000611b338689612255565b9050610c87828261354d565b8051825114611bb75760405162461bcd60e51b81526004018080602001828103825260358152602001806152c26035913960400191505060405180910390fd5b815160005b81811015611d3157611c33838281518110611bd357fe5b602002602001015160016000896001600160a01b03166001600160a01b031681526020019081526020016000206000878581518110611c0e57fe5b602002602001015181526020019081526020016000205461225590919063ffffffff16565b6001600160a01b03871660009081526001602052604081208651909190879085908110611c5c57fe5b6020026020010151815260200190815260200160002081905550611ce5838281518110611c8557fe5b602002602001015160016000886001600160a01b03166001600160a01b031681526020019081526020016000206000878581518110611cc057fe5b602002602001015181526020019081526020016000205461208090919063ffffffff16565b6001600160a01b03861660009081526001602052604081208651909190879085908110611d0e57fe5b602090810291909101810151825281019190915260400160002055600101611bbc565b50836001600160a01b0316856001600160a01b0316336001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb8686604051808060200180602001838103835285818151815260200191508051906020019060200280838360005b83811015611db7578181015183820152602001611d9f565b50505050905001838103825284818151815260200191508051906020019060200280838360005b83811015611df6578181015183820152602001611dde565b5050505090500194505050505060405180910390a45050505050565b611e24856001600160a01b0316613593565b15612002576000856001600160a01b031663bc197c8184338a8989886040518763ffffffff1660e01b815260040180866001600160a01b03168152602001856001600160a01b03168152602001806020018060200180602001848103845287818151815260200191508051906020019060200280838360005b83811015611eb5578181015183820152602001611e9d565b50505050905001848103835286818151815260200191508051906020019060200280838360005b83811015611ef4578181015183820152602001611edc565b50505050905001848103825285818151815260200191508051906020019080838360005b83811015611f30578181015183820152602001611f18565b50505050905090810190601f168015611f5d5780820380516001836020036101000a031916815260200191505b5098505050505050505050602060405180830381600088803b158015611f8257600080fd5b5087f1158015611f96573d6000803e3d6000fd5b50505050506040513d6020811015611fad57600080fd5b505190506001600160e01b0319811663bc197c8160e01b146120005760405162461bcd60e51b815260040180806020018281038252603f8152602001806153e2603f913960400191505060405180910390fd5b505b505050505050565b600082612019575060006104b4565b8282028284828161202657fe5b0414612079576040805162461bcd60e51b815260206004820152601660248201527f536166654d617468236d756c3a204f564552464c4f5700000000000000000000604482015290519081900360640190fd5b9392505050565b600082820183811015612079576040805162461bcd60e51b815260206004820152601660248201527f536166654d617468236164643a204f564552464c4f5700000000000000000000604482015290519081900360640190fd5b604080516001600160a01b038481166024830152604480830185905283518084039091018152606490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fa9059cbb00000000000000000000000000000000000000000000000000000000178152925182516000946060949389169392918291908083835b602083106121855780518252601f199092019160209182019101612166565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d80600081146121e7576040519150601f19603f3d011682016040523d82523d6000602084013e6121ec565b606091505b509150915081801561221a57508051158061221a575080806020019051602081101561221757600080fd5b50515b6108ed5760405162461bcd60e51b815260040180806020018281038252602d81526020018061545b602d913960400191505060405180910390fd5b6000828211156122ac576040805162461bcd60e51b815260206004820152601760248201527f536166654d617468237375623a20554e444552464c4f57000000000000000000604482015290519081900360640190fd5b50900390565b60606002600054141561230c576040805162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015290519081900360640190fd5b60026000558751428610156123335760405162461bcd60e51b815260040161020690614d3f565b60008167ffffffffffffffff8111801561234c57600080fd5b50604051908082528060200260200182016040528015612376578160200160208202803683370190505b50925060606123848b6135ca565b905060005b838110156124e25760008c828151811061239f57fe5b6020026020010151905060008c83815181106123b757fe5b6020026020010151905060008484815181106123cf57fe5b60200260200101519050600082116123f95760405162461bcd60e51b815260040161020690614fd3565b6000838152600760205260408120549061241d846124178582612255565b84610a74565b905060008061242c87846115b8565b9092509050801561247f576124656124468261271061200a565b6001600160a01b03841660009081526008602052604090205490612080565b6001600160a01b0383166000908152600860205260409020555b61249361248c8483612255565b8b90612080565b995061249f8484612255565b6000888152600760205260409020556124b88382612255565b8c89815181106124c457fe5b60209081029190910101525050600190950194506123899350505050565b5060005b85518110156125765760008682815181106124fd57fe5b6020026020010151111561256e5761251a8682815181106117f057fe5b925061253161183461271088848151811061181e57fe5b6008600089848151811061254157fe5b60200260200101516001600160a01b03166001600160a01b03168152602001908152602001600020819055505b6001016124e6565b50888210156125975760405162461bcd60e51b815260040161020690614d08565b6125c27f000000000000000000000000000000000000000000000000000000000000000088846120da565b5050506001600055979650505050505050565b6002600054141561262d576040805162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015290519081900360640190fd5b6002600055428110156126525760405162461bcd60e51b8152600401610206906150af565b8351600060608267ffffffffffffffff8111801561266f57600080fd5b50604051908082528060200260200182016040528015612699578160200160208202803683370190505b50905060608367ffffffffffffffff811180156126b557600080fd5b506040519080825280602002602001820160405280156126df578160200160208202803683370190505b50905060606126ed896135ca565b905060005b858110156129845760008a828151811061270857fe5b6020026020010151905060008a838151811061272057fe5b6020026020010151905060008a848151811061273857fe5b60200260200101511161275d5760405162461bcd60e51b815260040161020690614f2e565b6000811161277d5760405162461bcd60e51b815260040161020690615078565b60008281526006602052604090205480156128d95760008381526007602052604081205486519091908790879081106127b257fe5b602002602001015190506000806127e46127d5858861200a90919063ffffffff16565b6127df8589612255565b61354d565b91509150818f89815181106127f557fe5b6020026020010151101561281b5760405162461bcd60e51b815260040161020690614b50565b6128258483612080565b60008881526007602052604090205561283e8c83612080565b9b508361286186611b3384612854576000612857565b60015b869060ff16612255565b8161286857fe5b048b898151811061287557fe5b602002602001018181525050818a898151811061288e57fe5b6020026020010181815250506128c08b89815181106128a957fe5b60200260200101518661208090919063ffffffff16565b6000888152600660205260409020555061297992505050565b60008b85815181106128e757fe5b602002602001015190506103e88110156129135760405162461bcd60e51b815260040161020690614c2c565b600084815260076020526040902081905561292e8982612080565b60008581526006602052604090208290558851909950819089908790811061295257fe5b6020026020010181815250508087868151811061296b57fe5b602002602001018181525050505b5050506001016126f2565b506129b17f00000000000000000000000000000000000000000000000000000000000000008b3087612ea3565b6129cc8a8a856040518060200160405280600081525061387d565b896001600160a01b03167f403f9dc4582dae52d3eeb4a22d37540ffb13c32d964c92ec5ac0d3d5628da3168a8a85604051612a0993929190614971565b60405180910390a2505060016000555050505050505050565b60026000541415612a7a576040805162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015290519081900360640190fd5b6002600055428111612a9e5760405162461bcd60e51b815260040161020690614bbe565b8451600060608267ffffffffffffffff81118015612abb57600080fd5b50604051908082528060200260200182016040528015612ae5578160200160208202803683370190505b50905060608367ffffffffffffffff81118015612b0157600080fd5b50604051908082528060200260200182016040528015612b3b57816020015b612b28613d75565b815260200190600190039081612b205790505b5090506060612b498a6135ca565b905060005b85811015612d915760008b8281518110612b6457fe5b6020026020010151905060008b8381518110612b7c57fe5b6020026020010151905060006006600084815260200190815260200160002054905060008111612bbe5760405162461bcd60e51b815260040161020690614bf5565b600083815260076020526040812054865190919081908190899089908110612be257fe5b60200260200101519050600080600080612bff8b8b878b8d613a4a565b6001600160a01b038216600090815260086020526040902054959c50939a50919750955093509150612c319082612080565b6001600160a01b0383166000908152600860205260409020558d5184908f908e908110612c5a57fe5b60200260200101516020018181525050828e8d81518110612c7757fe5b60200260200101516040018181525050888e8d81518110612c9457fe5b6020026020010151606001818152505050505050508e8781518110612cb557fe5b6020026020010151821015612cdc5760405162461bcd60e51b815260040161020690614f65565b8d8781518110612ce857fe5b6020026020010151811015612d0f5760405162461bcd60e51b815260040161020690614a74565b612d198486612255565b600087815260066020526040902055612d328383612255565b600087815260076020526040902055612d4b8b83612080565b9a50808a8881518110612d5a57fe5b60200260200101818152505081898881518110612d7357fe5b602090810291909101015152505060019094019350612b4e92505050565b50612d9d308b8b613b3f565b612dc87f00000000000000000000000000000000000000000000000000000000000000008c866120da565b604051631759616b60e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690632eb2c2d690612e1a9030908f908f90899060040161483e565b600060405180830381600087803b158015612e3457600080fd5b505af1158015612e48573d6000803e3d6000fd5b505050508a6001600160a01b03167f3024a3223ce9e6a0b0324a52224694f329e7f092c1a7b74067b8f3cbfa1885718b8585604051612e89939291906148e7565b60405180910390a250506001600055505050505050505050565b604080516001600160a01b0385811660248301528481166044830152606480830185905283518084039091018152608490920183526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd0000000000000000000000000000000000000000000000000000000017815292518251600094606094938a169392918291908083835b60208310612f565780518252601f199092019160209182019101612f37565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612fb8576040519150601f19603f3d011682016040523d82523d6000602084013e612fbd565b606091505b5091509150818015612feb575080511580612feb5750808060200190516020811015612fe857600080fd5b50515b6120025760405162461bcd60e51b81526004018080602001828103825260318152602001806152916031913960400191505060405180910390fd5b606060026000541415613080576040805162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015290519081900360640190fd5b6002600055428310156130a55760405162461bcd60e51b815260040161020690615041565b8551848167ffffffffffffffff811180156130bf57600080fd5b506040519080825280602002602001820160405280156130e9578160200160208202803683370190505b50925060606130f7896135ca565b905060005b838110156132305760008a828151811061311257fe5b6020026020010151905060008a838151811061312a57fe5b60200260200101519050600084848151811061314257fe5b602002602001015190506000821161316c5760405162461bcd60e51b815260040161020690614b87565b60008381526007602052604081205490613187848385611af4565b905060008061319687846115b8565b909250905080156131ca576131b06124468261271061200a565b6001600160a01b0383166000908152600860205260409020555b6131de816131d88c86612255565b90612255565b99506131ea8382612080565b8c89815181106131f657fe5b602090810291909101015261320b8484612080565b600097885260076020526040909720969096555050600190940193506130fc92505050565b50604051631759616b60e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690632eb2c2d69061328390309089908e908e9060040161483e565b600060405180830381600087803b15801561329d57600080fd5b505af11580156132b1573d6000803e3d6000fd5b5050505060008211156132e9576132e97f000000000000000000000000000000000000000000000000000000000000000086846120da565b505050600160005595945050505050565b6001600160a01b03841660009081526001602090815260408083208584529091529020546133289082612255565b6001600160a01b03808616600090815260016020818152604080842088855282528084209590955592871682528252828120858252909152205461336c9082612080565b6001600160a01b038085166000818152600160209081526040808320888452825291829020949094558051868152938401859052805191939288169233927fc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62929181900390910190a450505050565b6133ed856001600160a01b0316613593565b15612002576000856001600160a01b031663f23a6e6184338a8989886040518763ffffffff1660e01b815260040180866001600160a01b03168152602001856001600160a01b0316815260200184815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561347f578181015183820152602001613467565b50505050905090810190601f1680156134ac5780820380516001836020036101000a031916815260200191505b509650505050505050602060405180830381600088803b1580156134cf57600080fd5b5087f11580156134e3573d6000803e3d6000fd5b50505050506040513d60208110156134fa57600080fd5b505190506001600160e01b0319811663f23a6e6160e01b146120005760405162461bcd60e51b815260040180806020018281038252603a815260200180615421603a913960400191505060405180910390fd5b60008082848161355957fe5b061561357b57613574600184868161356d57fe5b0490612080565b6001613588565b82848161358457fe5b0460005b915091509250929050565b6000813f801580159061207957507fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470141592915050565b805160609060018114156136cc57604080516001808252818301909252606091602080830190803683370190505090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031662fdd58e308660008151811061363657fe5b60200260200101516040518363ffffffff1660e01b815260040161365b929190614896565b60206040518083038186803b15801561367357600080fd5b505afa158015613687573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906136ab91906146ff565b816000815181106136b857fe5b602090810291909101015291506105a39050565b60608167ffffffffffffffff811180156136e557600080fd5b5060405190808252806020026020018201604052801561370f578160200160208202803683370190505b509050308160008151811061372057fe5b6001600160a01b039092166020928302919091019091015260015b828110156137b85784818151811061374f57fe5b602002602001015185600183038151811061376657fe5b60200260200101511061378b5760405162461bcd60e51b815260040161020690614dad565b3082828151811061379857fe5b6001600160a01b039092166020928302919091019091015260010161373b565b506040517f4e1273f40000000000000000000000000000000000000000000000000000000081526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690634e1273f49061382090849088906004016148af565b60006040518083038186803b15801561383857600080fd5b505afa15801561384c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261387491908101906142ed565b925050506105a3565b81518351146138bd5760405162461bcd60e51b81526004018080602001828103825260308152602001806153b26030913960400191505060405180910390fd5b825160005b81811015613960576139148482815181106138d957fe5b602002602001015160016000896001600160a01b03166001600160a01b031681526020019081526020016000206000888581518110611cc057fe5b6001600160a01b0387166000908152600160205260408120875190919088908590811061393d57fe5b6020908102919091018101518252810191909152604001600020556001016138c2565b50846001600160a01b031660006001600160a01b0316336001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb8787604051808060200180602001838103835285818151815260200191508051906020019060200280838360005b838110156139e75781810151838201526020016139cf565b50505050905001838103825284818151815260200191508051906020019060200280838360005b83811015613a26578181015183820152602001613a0e565b5050505090500194505050505060405180910390a46108ed60008686865a87611e12565b6000808080808080613a5c8b8a61200a565b90506000613a6a8c8c61200a565b9050888181613a7557fe5b0695508515613b18576000613aa08a611b338c8581613a9057fe5b048f61225590919063ffffffff16565b90506000613ab48b611b338d8781613a9057fe5b90508015801590613ac457508115155b15613b1557613ad4888383610a74565b9650613ae08f886115b8565b9096509450613aef8786612255565b9650613afb8488612080565b93508a613b0a8661271061200a565b81613b1157fe5b0494505b50505b888281613b2157fe5b049750888181613b2d57fe5b04965050509550955095509550955095565b815181518114613b805760405162461bcd60e51b81526004018080602001828103825260308152602001806153276030913960400191505060405180910390fd5b60005b81811015613c2157613bd5838281518110613b9a57fe5b602002602001015160016000886001600160a01b03166001600160a01b031681526020019081526020016000206000878581518110611c0e57fe5b6001600160a01b03861660009081526001602052604081208651909190879085908110613bfe57fe5b602090810291909101810151825281019190915260400160002055600101613b83565b5060006001600160a01b0316846001600160a01b0316336001600160a01b03167f4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb8686604051808060200180602001838103835285818151815260200191508051906020019060200280838360005b83811015613ca8578181015183820152602001613c90565b50505050905001838103825284818151815260200191508051906020019060200280838360005b83811015613ce7578181015183820152602001613ccf565b5050505090500194505050505060405180910390a450505050565b6040518060a0016040528060006001600160a01b03168152602001600081526020016060815260200160608152602001600081525090565b604051806040016040528060608152602001600081525090565b60405180606001604052806060815260200160608152602001600081525090565b6040518060800160405280600081526020016000815260200160008152602001600081525090565b80356105a3816151ff565b80516105a3816151ff565b600082601f830112613dc3578081fd5b8135613dd6613dd18261518f565b61516b565b818152915060208083019084810181840286018201871015613df757600080fd5b60005b84811015613e1f578135613e0d816151ff565b84529282019290820190600101613dfa565b505050505092915050565b600082601f830112613e3a578081fd5b8151613e48613dd18261518f565b818152915060208083019084810181840286018201871015613e6957600080fd5b60005b84811015613e1f578151613e7f816151ff565b84529282019290820190600101613e6c565b60008083601f840112613ea2578182fd5b50813567ffffffffffffffff811115613eb9578182fd5b602083019150836020808302850101111561170457600080fd5b600082601f830112613ee3578081fd5b8135613ef1613dd18261518f565b818152915060208083019084810181840286018201871015613f1257600080fd5b60005b84811015613e1f57813584529282019290820190600101613f15565b600082601f830112613f41578081fd5b8151613f4f613dd18261518f565b818152915060208083019084810181840286018201871015613f7057600080fd5b60005b84811015613e1f57815184529282019290820190600101613f73565b600082601f830112613f9f578081fd5b8135613fad613dd1826151ad565b9150808252836020828501011115613fc457600080fd5b8060208401602084013760009082016020015292915050565b600060208284031215613fee578081fd5b8135612079816151ff565b60006020828403121561400a578081fd5b8151612079816151ff565b60008060408385031215614027578081fd5b8235614032816151ff565b91506020830135614042816151ff565b809150509250929050565b600080600080600060a08688031215614064578081fd5b853561406f816151ff565b9450602086013561407f816151ff565b9350604086013567ffffffffffffffff8082111561409b578283fd5b6140a789838a01613ed3565b945060608801359150808211156140bc578283fd5b6140c889838a01613ed3565b935060808801359150808211156140dd578283fd5b506140ea88828901613f8f565b9150509295509295909350565b600080600080600060a0868803121561410e578283fd5b8535614119816151ff565b94506020860135614129816151ff565b93506040860135925060608601359150608086013567ffffffffffffffff811115614152578182fd5b6140ea88828901613f8f565b60008060408385031215614170578182fd5b823561417b816151ff565b9150602083013561404281615217565b6000806040838503121561419d578182fd5b82356141a8816151ff565b946020939093013593505050565b600080604083850312156141c8578182fd5b82516141d3816151ff565b6020939093015192949293505050565b600080604083850312156141f5578182fd5b823567ffffffffffffffff8082111561420c578384fd5b61421886838701613db3565b9350602085013591508082111561422d578283fd5b5061423a85828601613ed3565b9150509250929050565b60008060208385031215614256578182fd5b823567ffffffffffffffff81111561426c578283fd5b61427885828601613e91565b90969095509350505050565b60008060008060408587031215614299578182fd5b843567ffffffffffffffff808211156142b0578384fd5b6142bc88838901613e91565b909650945060208701359150808211156142d4578384fd5b506142e187828801613e91565b95989497509550505050565b6000602082840312156142fe578081fd5b815167ffffffffffffffff811115614314578182fd5b61432084828501613f31565b949350505050565b600080600080600080600060e0888a031215614342578485fd5b873567ffffffffffffffff80821115614359578687fd5b6143658b838c01613ed3565b985060208a013591508082111561437a578687fd5b6143868b838c01613ed3565b975060408a0135965060608a013595506143a260808b01613d9d565b945060a08a01359150808211156143b7578384fd5b6143c38b838c01613db3565b935060c08a01359150808211156143d8578283fd5b506143e58a828b01613ed3565b91505092959891949750929550565b600060208284031215614405578081fd5b815161207981615217565b600060208284031215614421578081fd5b813561207981615225565b60006020828403121561443d578081fd5b815161207981615225565b6000806040838503121561445a578182fd5b825161446581615225565b602084015190925067ffffffffffffffff80821115614482578283fd5b9084019060408287031215614495578283fd5b6040516040810181811083821117156144aa57fe5b6040528251828111156144bb578485fd5b6144c788828601613f31565b825250602083015160208201528093505050509250929050565b600080604083850312156144f3578182fd5b82516144fe81615225565b602084015190925067ffffffffffffffff8082111561451b578283fd5b908401906060828703121561452e578283fd5b60405160608101818110838211171561454357fe5b604052825182811115614554578485fd5b61456088828601613f31565b825250602083015182811115614574578485fd5b61458088828601613f31565b602083015250604083015160408201528093505050509250929050565b600080604083850312156145af578182fd5b82516145ba81615225565b602084015190925067ffffffffffffffff808211156145d7578283fd5b9084019060a082870312156145ea578283fd5b60405160a0810181811083821117156145ff57fe5b60405261460b83613da8565b815260208301516020820152604083015182811115614628578485fd5b61463488828601613e2a565b60408301525060608301518281111561464b578485fd5b61465788828601613f31565b606083015250608083015160808201528093505050509250929050565b600060208284031215614685578081fd5b815167ffffffffffffffff81111561469b578182fd5b8201601f810184136146ab578182fd5b80516146b9613dd1826151ad565b8181528560208385010111156146cd578384fd5b6146de8260208301602086016151cf565b95945050505050565b6000602082840312156146f8578081fd5b5035919050565b600060208284031215614710578081fd5b5051919050565b60008060408385031215614729578182fd5b823591506020830135614042816151ff565b6000806040838503121561474d578182fd5b50508035926020909101359150565b600080600060608486031215614770578081fd5b505081359360208301359350604090920135919050565b6000806000806080858703121561479c578182fd5b5050823594602084013594506040840135936060013592509050565b6000815180845260208085019450808401835b838110156147f05781516001600160a01b0316875295820195908201906001016147cb565b509495945050505050565b6000815180845260208085019450808401835b838110156147f05781518752958201959082019060010161480e565b6001600160a01b0391909116815260200190565b60006001600160a01b03808716835280861660208401525060a0604083015261486a60a08301856147fb565b828103606084015261487c81856147fb565b838103608090940193909352508152602001949350505050565b6001600160a01b03929092168252602082015260400190565b6000604082526148c260408301856147b8565b82810360208401526146de81856147fb565b60006020825261207960208301846147fb565b600060608083526148fa818401876147fb565b60208482038186015261490d82886147fb565b915060408583038187015282875180855283850191508389019450865b818110156149615785518051845285810151868501528481015185850152870151878401529484019460809092019160010161492a565b50909a9950505050505050505050565b60006060825261498460608301866147fb565b828103602084015261499681866147fb565b905082810360408401526149aa81856147fb565b9695505050505050565b600060a082526149c760a08301886147fb565b82810360208401526149d981886147fb565b905082810360408401526149ed81876147fb565b90508281036060840152614a0181866147b8565b90508281036080840152614a1581856147fb565b98975050505050505050565b901515815260200190565b6001600160e01b031991909116815260200190565b6000602082528251806020840152614a608160408501602087016151cf565b601f01601f19169190910160400192915050565b60208082526007908201527f4e45323023313800000000000000000000000000000000000000000000000000604082015260600190565b60208082526004908201527f444f233200000000000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313900000000000000000000000000000000000000000000000000604082015260600190565b60208082526002908201527f4433000000000000000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313300000000000000000000000000000000000000000000000000604082015260600190565b60208082526006908201527f4e45323023340000000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313500000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313600000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313400000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323600000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323900000000000000000000000000000000000000000000000000604082015260600190565b60208082526006908201527f4e45323023390000000000000000000000000000000000000000000000000000604082015260600190565b60208082526006908201527f4e45323023380000000000000000000000000000000000000000000000000000604082015260600190565b60208082526006908201527f4e45323023360000000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323000000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023333200000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323400000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323300000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023333000000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323700000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323200000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323800000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313100000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313700000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323100000000000000000000000000000000000000000000000000604082015260600190565b60208082526006908201527f4e45323023370000000000000000000000000000000000000000000000000000604082015260600190565b60208082526006908201527f4e45323023350000000000000000000000000000000000000000000000000000604082015260600190565b60208082526006908201527f4e45323023330000000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313200000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023313000000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023323500000000000000000000000000000000000000000000000000604082015260600190565b60208082526007908201527f4e45323023333100000000000000000000000000000000000000000000000000604082015260600190565b90815260200190565b918252602082015260400190565b60405181810167ffffffffffffffff8111828210171561518757fe5b604052919050565b600067ffffffffffffffff8211156151a357fe5b5060209081020190565b600067ffffffffffffffff8211156151c157fe5b50601f01601f191660200190565b60005b838110156151ea5781810151838201526020016151d2565b838111156151f9576000848401525b50505050565b6001600160a01b038116811461521457600080fd5b50565b801515811461521457600080fd5b6001600160e01b03198116811461521457600080fdfe4552433131353523736166655472616e7366657246726f6d3a20494e56414c49445f524543495049454e544552433131353523736166655472616e7366657246726f6d3a20494e56414c49445f4f50455241544f525472616e7366657248656c7065723a3a7472616e7366657246726f6d3a207472616e7366657246726f6d206661696c656445524331313535235f7361666542617463685472616e7366657246726f6d3a20494e56414c49445f4152524159535f4c454e47544845524331313535237361666542617463685472616e7366657246726f6d3a20494e56414c49445f524543495049454e54455243313135354d696e744275726e2362617463684275726e3a20494e56414c49445f4152524159535f4c454e475448455243313135352362616c616e63654f6642617463683a20494e56414c49445f41525241595f4c454e47544845524331313535237361666542617463685472616e7366657246726f6d3a20494e56414c49445f4f50455241544f52455243313135354d696e744275726e2362617463684d696e743a20494e56414c49445f4152524159535f4c454e47544845524331313535235f63616c6c6f6e45524331313535426174636852656365697665643a20494e56414c49445f4f4e5f524543454956455f4d45535341474545524331313535235f63616c6c6f6e4552433131353552656365697665643a20494e56414c49445f4f4e5f524543454956455f4d4553534147455472616e7366657248656c7065723a3a736166655472616e736665723a207472616e73666572206661696c6564a26469706673582212202dc63d0c0e701b05bb7a2e01b5aebb63e707d1a3ef615a4f251537f1c65e678964736f6c63430007040033a2646970667358221220facf5ad0627762fb1d2754eeb047696edc1a412671e74278905d36838089ee9d64736f6c63430007040033',
      signer
    )
  }
}

export const NIFTYSWAP_FACTORY_20_VERIFICATION: Omit<EtherscanVerificationRequest, 'waitForSuccess'> = {
  contractToVerify: 'contracts/exchange/NiftyswapFactory20.sol:NiftyswapFactory20',
  version: 'v0.7.4+commit.3f05b770',
  compilerInput: {
    language: 'Solidity',
    sources: {
      'contracts/exchange/NiftyswapFactory20.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\nimport "./NiftyswapExchange20.sol";\nimport "../utils/Ownable.sol";\nimport "../interfaces/INiftyswapFactory20.sol";\nimport "../interfaces/IDelegatedERC1155Metadata.sol";\n\n\ncontract NiftyswapFactory20 is INiftyswapFactory20, Ownable, IDelegatedERC1155Metadata {\n\n  /***********************************|\n  |       Events And Variables        |\n  |__________________________________*/\n\n  // tokensToExchange[erc1155_token_address][currency_address][lp_fee][instance]\n  mapping(address => mapping(address => mapping(uint256 => mapping(uint256 => address)))) public override tokensToExchange;\n  mapping(address => mapping(address => address[])) internal pairExchanges;\n\n  // Metadata implementation\n  IERC1155Metadata internal metadataContract; // address of the ERC-1155 Metadata contract\n\n  /**\n   * @notice Will set the initial Niftyswap admin\n   * @param _admin Address of the initial niftyswap admin to set as Owner\n   */\n  constructor(address _admin) Ownable(_admin) { }\n\n  /***********************************|\n  |             Functions             |\n  |__________________________________*/\n  /**\n   * @notice Creates a NiftySwap Exchange for given token contract\n   * @param _token    The address of the ERC-1155 token contract\n   * @param _currency The address of the ERC-20 token contract\n   * @param _lpFee    Fee that will go to LPs.\n   *                  Number between 0 and 1000, where 10 is 1.0% and 100 is 10%.\n   * @param _instance Instance # that allows to deploy new instances of an exchange.\n   *                  This is mainly meant to be used for tokens that change their ERC-2981 support.\n   */\n  function createExchange(address _token, address _currency, uint256 _lpFee, uint256 _instance) public override {\n    require(tokensToExchange[_token][_currency][_lpFee][_instance] == address(0x0), "NF20#1"); // NiftyswapFactory20#createExchange: EXCHANGE_ALREADY_CREATED\n\n    // Create new exchange contract\n    NiftyswapExchange20 exchange = new NiftyswapExchange20(_token, _currency, _lpFee);\n\n    // Store exchange and token addresses\n    tokensToExchange[_token][_currency][_lpFee][_instance] = address(exchange);\n    pairExchanges[_token][_currency].push(address(exchange));\n\n    // Emit event\n    emit NewExchange(_token, _currency, _instance, _lpFee, address(exchange));\n  }\n\n  /**\n   * @notice Returns array of exchange instances for a given pair\n   * @param _token    The address of the ERC-1155 token contract\n   * @param _currency The address of the ERC-20 token contract\n   */\n  function getPairExchanges(address _token, address _currency) public override view returns (address[] memory) {\n    return pairExchanges[_token][_currency];\n  }\n\n  /***********************************|\n  |        Metadata Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Changes the implementation of the ERC-1155 Metadata contract\n   * @dev This function changes the implementation for all child exchanges of the factory\n   * @param _contract The address of the ERC-1155 Metadata contract\n   */\n  function setMetadataContract(IERC1155Metadata _contract) onlyOwner external {\n    emit MetadataContractChanged(address(_contract));\n    metadataContract = _contract;\n  }\n\n  /**\n   * @notice Returns the address of the ERC-1155 Metadata contract\n   */\n  function metadataProvider() external override view returns (IERC1155Metadata) {\n    return metadataContract;\n  }\n}\n'
      },
      'contracts/utils/Ownable.sol': {
        content:
          'pragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of "user permissions".\n */\ncontract Ownable {\n  address internal owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the specied address\n   * @param _firstOwner Address of the first owner\n   */\n  constructor (address _firstOwner) {\n    owner = _firstOwner;\n    emit OwnershipTransferred(address(0), _firstOwner);\n  }\n\n  /**\n   * @dev Throws if called by any account other than the master owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, "Ownable#onlyOwner: SENDER_IS_NOT_OWNER");\n    _;\n  }\n\n  /**\n   * @notice Transfers the ownership of the contract to new address\n   * @param _newOwner Address of the new owner\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    require(_newOwner != address(0), "Ownable#transferOwnership: INVALID_ADDRESS");\n    owner = _newOwner;\n    emit OwnershipTransferred(owner, _newOwner);\n  }\n\n  /**\n   * @notice Returns the address of the owner.\n   */\n  function getOwner() public view returns (address) {\n    return owner;\n  }\n}'
      },
      'contracts/interfaces/INiftyswapFactory20.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\ninterface INiftyswapFactory20 {\n\n  /***********************************|\n  |               Events              |\n  |__________________________________*/\n\n  event NewExchange(address indexed token, address indexed currency, uint256 indexed salt, uint256 lpFee, address exchange);\n\n  event MetadataContractChanged(address indexed metadataContract);\n\n  /***********************************|\n  |         Public  Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Creates a NiftySwap Exchange for given token contract\n   * @param _token      The address of the ERC-1155 token contract\n   * @param _currency   The address of the currency token contract\n   * @param _lpFee      Fee that will go to LPs\n   *                    Number between 0 and 1000, where 10 is 1.0% and 100 is 10%.\n   * @param _instance   Instance # that allows to deploy new instances of an exchange.\n   *                    This is mainly meant to be used for tokens that change their ERC-2981 support.\n   */\n  function createExchange(address _token, address _currency, uint256 _lpFee, uint256 _instance) external;\n\n  /**\n   * @notice Return address of exchange for corresponding ERC-1155 token contract\n   * @param _token      The address of the ERC-1155 token contract\n   * @param _currency   The address of the currency token contract\n   * @param _lpFee      Fee that will go to LPs.\n   * @param _instance   Instance # that allows to deploy new instances of an exchange.\n   *                    This is mainly meant to be used for tokens that change their ERC-2981 support.\n   */\n  function tokensToExchange(address _token, address _currency, uint256 _lpFee, uint256 _instance) external view returns (address);\n\n  /**\n   * @notice Returns array of exchange instances for a given pair\n   * @param _token    The address of the ERC-1155 token contract\n   * @param _currency The address of the ERC-20 token contract\n   */\n  function getPairExchanges(address _token, address _currency) external view returns (address[] memory);\n}\n'
      },
      'contracts/exchange/NiftyswapExchange.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport "../interfaces/INiftyswapExchange.sol";\nimport "../utils/ReentrancyGuard.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC165.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol";\nimport "@0xsequence/erc-1155/contracts/tokens/ERC1155/ERC1155MintBurn.sol";\n\n\n/**\n * This Uniswap-like implementation supports ERC-1155 standard tokens\n * with an ERC-1155 based token used as a currency instead of Ether.\n *\n * See https://github.com/0xsequence/erc20-meta-token for a generalized\n * ERC-20 => ERC-1155 token wrapper\n *\n * Liquidity tokens are also ERC-1155 tokens you can find the ERC-1155\n * implementation used here:\n *    https://github.com/horizon-games/multi-token-standard/tree/master/contracts/tokens/ERC1155\n *\n * @dev Like Uniswap, tokens with 0 decimals and low supply are susceptible to significant rounding\n *      errors when it comes to removing liquidity, possibly preventing them to be withdrawn without\n *      some collaboration between liquidity providers.\n */\ncontract NiftyswapExchange is ReentrancyGuard, ERC1155MintBurn, INiftyswapExchange {\n  using SafeMath for uint256;\n\n  /***********************************|\n  |       Variables & Constants       |\n  |__________________________________*/\n\n  // Variables\n  IERC1155 internal token;                        // address of the ERC-1155 token contract\n  IERC1155 internal currency;                     // address of the ERC-1155 currency used for exchange\n  bool internal currencyPoolBanned;               // Whether the currency token ID can have a pool or not\n  address internal factory;                       // address for the factory that created this contract\n  uint256 internal currencyID;                    // ID of currency token in ERC-1155 currency contract\n  uint256 internal constant FEE_MULTIPLIER = 995; // Multiplier that calculates the fee (1.0%)\n\n  // Mapping variables\n  mapping(uint256 => uint256) internal totalSupplies;    // Liquidity pool token supply per Token id\n  mapping(uint256 => uint256) internal currencyReserves; // currency Token reserve per Token id\n\n\n  /***********************************|\n  |            Constructor           |\n  |__________________________________*/\n\n  /**\n   * @notice Create instance of exchange contract with respective token and currency token\n   * @param _tokenAddr     The address of the ERC-1155 Token\n   * @param _currencyAddr  The address of the ERC-1155 currency Token\n   * @param _currencyID    The ID of the ERC-1155 currency Token\n   */\n  constructor(address _tokenAddr, address _currencyAddr, uint256 _currencyID) public {\n    require(\n      address(_tokenAddr) != address(0) && _currencyAddr != address(0),\n      "NiftyswapExchange#constructor:INVALID_INPUT"\n    );\n    factory = msg.sender;\n    token = IERC1155(_tokenAddr);\n    currency = IERC1155(_currencyAddr);\n    currencyID = _currencyID;\n\n    // If token and currency are the same contract,\n    // need to prevent currency/currency pool to be created.\n    currencyPoolBanned = _currencyAddr == _tokenAddr ? true : false;\n  }\n\n  /***********************************|\n  |        Exchange Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\n   * @dev User specifies MAXIMUM inputs (_maxCurrency) and EXACT outputs.\n   * @dev Assumes that all trades will be successful, or revert the whole tx\n   * @dev Exceeding currency tokens sent will be refunded to recipient\n   * @dev Sorting IDs is mandatory for efficient way of preventing duplicated IDs (which would lead to exploit)\n   * @param _tokenIds             Array of Tokens ID that are bought\n   * @param _tokensBoughtAmounts  Amount of Tokens id bought for each corresponding Token id in _tokenIds\n   * @param _maxCurrency          Total maximum amount of currency tokens to spend for all Token ids\n   * @param _deadline             Timestamp after which this transaction will be reverted\n   * @param _recipient            The address that receives output Tokens and refund\n   * @return currencySold How much currency was actually sold.\n   */\n  function _currencyToToken(\n    uint256[] memory _tokenIds,\n    uint256[] memory _tokensBoughtAmounts,\n    uint256 _maxCurrency,\n    uint256 _deadline,\n    address _recipient)\n    internal nonReentrant() returns (uint256[] memory currencySold)\n  {\n    // Input validation\n    require(_deadline >= block.timestamp, "NiftyswapExchange#_currencyToToken: DEADLINE_EXCEEDED");\n\n    // Number of Token IDs to deposit\n    uint256 nTokens = _tokenIds.length;\n    uint256 totalRefundCurrency = _maxCurrency;\n\n    // Initialize variables\n    currencySold = new uint256[](nTokens); // Amount of currency tokens sold per ID\n    uint256[] memory tokenReserves = new uint256[](nTokens);  // Amount of tokens in reserve for each Token id\n\n    // Get token reserves\n    tokenReserves = _getTokenReserves(_tokenIds);\n\n    // Assumes he currency Tokens are already received by contract, but not\n    // the Tokens Ids\n\n    // Remove liquidity for each Token ID in _tokenIds\n    for (uint256 i = 0; i < nTokens; i++) {\n      // Store current id and amount from argument arrays\n      uint256 idBought = _tokenIds[i];\n      uint256 amountBought = _tokensBoughtAmounts[i];\n      uint256 tokenReserve = tokenReserves[i];\n\n      require(amountBought > 0, "NiftyswapExchange#_currencyToToken: NULL_TOKENS_BOUGHT");\n\n      // Load currency token and Token _id reserves\n      uint256 currencyReserve = currencyReserves[idBought];\n\n      // Get amount of currency tokens to send for purchase\n      // Neither reserves amount have been changed so far in this transaction, so\n      // no adjustment to the inputs is needed\n      uint256 currencyAmount = getBuyPrice(amountBought, currencyReserve, tokenReserve);\n\n      // Calculate currency token amount to refund (if any) where whatever is not used will be returned\n      // Will throw if total cost exceeds _maxCurrency\n      totalRefundCurrency = totalRefundCurrency.sub(currencyAmount);\n\n      // Append Token id, Token id amount and currency token amount to tracking arrays\n      currencySold[i] = currencyAmount;\n\n      // Update individual currency reseve amount\n      currencyReserves[idBought] = currencyReserve.add(currencyAmount);\n    }\n\n    // Refund currency token if any\n    if (totalRefundCurrency > 0) {\n      currency.safeTransferFrom(address(this), _recipient, currencyID, totalRefundCurrency, "");\n    }\n\n    // Send Tokens all tokens purchased\n    token.safeBatchTransferFrom(address(this), _recipient, _tokenIds, _tokensBoughtAmounts, "");\n    return currencySold;\n  }\n\n  /**\n   * @dev Pricing function used for converting between currency token to Tokens.\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\n   * @return price Amount of currency tokens to send to Niftyswap.\n   */\n  function getBuyPrice(\n    uint256 _assetBoughtAmount,\n    uint256 _assetSoldReserve,\n    uint256 _assetBoughtReserve)\n    override public pure returns (uint256 price)\n  {\n    // Reserves must not be empty\n    require(_assetSoldReserve > 0 && _assetBoughtReserve > 0, "NiftyswapExchange#getBuyPrice: EMPTY_RESERVE");\n\n    // Calculate price with fee\n    uint256 numerator = _assetSoldReserve.mul(_assetBoughtAmount).mul(1000);\n    uint256 denominator = (_assetBoughtReserve.sub(_assetBoughtAmount)).mul(FEE_MULTIPLIER);\n    (price, ) = divRound(numerator, denominator);\n    return price; // Will add 1 if rounding error\n  }\n\n  /**\n   * @notice Convert Tokens _id to currency tokens and transfers Tokens to recipient.\n   * @dev User specifies EXACT Tokens _id sold and MINIMUM currency tokens received.\n   * @dev Assumes that all trades will be valid, or the whole tx will fail\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\n   * @param _tokenIds          Array of Token IDs that are sold\n   * @param _tokensSoldAmounts Array of Amount of Tokens sold for each id in _tokenIds.\n   * @param _minCurrency       Minimum amount of currency tokens to receive\n   * @param _deadline          Timestamp after which this transaction will be reverted\n   * @param _recipient         The address that receives output currency tokens.\n   * @return currencyBought How much currency was actually purchased.\n   */\n  function _tokenToCurrency(\n    uint256[] memory _tokenIds,\n    uint256[] memory _tokensSoldAmounts,\n    uint256 _minCurrency,\n    uint256 _deadline,\n    address _recipient)\n    internal nonReentrant() returns (uint256[] memory currencyBought)\n  {\n    // Number of Token IDs to deposit\n    uint256 nTokens = _tokenIds.length;\n\n    // Input validation\n    require(_deadline >= block.timestamp, "NiftyswapExchange#_tokenToCurrency: DEADLINE_EXCEEDED");\n\n    // Initialize variables\n    uint256 totalCurrency = 0; // Total amount of currency tokens to transfer\n    currencyBought = new uint256[](nTokens);\n    uint256[] memory tokenReserves = new uint256[](nTokens);\n\n    // Get token reserves\n    tokenReserves = _getTokenReserves(_tokenIds);\n\n    // Assumes the Tokens ids are already received by contract, but not\n    // the Tokens Ids. Will return cards not sold if invalid price.\n\n    // Remove liquidity for each Token ID in _tokenIds\n    for (uint256 i = 0; i < nTokens; i++) {\n      // Store current id and amount from argument arrays\n      uint256 idSold = _tokenIds[i];\n      uint256 amountSold = _tokensSoldAmounts[i];\n      uint256 tokenReserve = tokenReserves[i];\n\n      // If 0 tokens send for this ID, revert\n      require(amountSold > 0, "NiftyswapExchange#_tokenToCurrency: NULL_TOKENS_SOLD");\n\n      // Load currency token and Token _id reserves\n      uint256 currencyReserve = currencyReserves[idSold];\n\n      // Get amount of currency that will be received\n      // Need to sub amountSold because tokens already added in reserve, which would bias the calculation\n      // Don\'t need to add it for currencyReserve because the amount is added after this calculation\n      uint256 currencyAmount = getSellPrice(amountSold, tokenReserve.sub(amountSold), currencyReserve);\n\n      // Increase cost of transaction\n      totalCurrency = totalCurrency.add(currencyAmount);\n\n      // Update individual currency reseve amount\n      currencyReserves[idSold] = currencyReserve.sub(currencyAmount);\n\n      // Append Token id, Token id amount and currency token amount to tracking arrays\n      currencyBought[i] = currencyAmount;\n    }\n\n    // If minCurrency is not met\n    require(totalCurrency >= _minCurrency, "NiftyswapExchange#_tokenToCurrency: INSUFFICIENT_CURRENCY_AMOUNT");\n\n    // Transfer currency here\n    currency.safeTransferFrom(address(this), _recipient, currencyID, totalCurrency, "");\n\n    return currencyBought;\n  }\n\n  /**\n   * @dev Pricing function used for converting Tokens to currency token.\n   * @param _assetSoldAmount    Amount of Tokens being sold.\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\n   * @return price Amount of currency tokens to receive from Niftyswap.\n   */\n  function getSellPrice(\n    uint256 _assetSoldAmount,\n    uint256 _assetSoldReserve,\n    uint256 _assetBoughtReserve)\n    override public pure returns (uint256 price)\n  {\n    //Reserves must not be empty\n    require(_assetSoldReserve > 0 && _assetBoughtReserve > 0, "NiftyswapExchange#getSellPrice: EMPTY_RESERVE");\n\n    // Calculate amount to receive (with fee)\n    uint256 _assetSoldAmount_withFee = _assetSoldAmount.mul(FEE_MULTIPLIER);\n    uint256 numerator = _assetSoldAmount_withFee.mul(_assetBoughtReserve);\n    uint256 denominator = _assetSoldReserve.mul(1000).add(_assetSoldAmount_withFee);\n    return numerator / denominator; //Rounding errors will favor Niftyswap, so nothing to do\n  }\n\n  /***********************************|\n  |        Liquidity Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Deposit less than max currency tokens && exact Tokens (token ID) at current ratio to mint liquidity pool tokens.\n   * @dev min_liquidity does nothing when total liquidity pool token supply is 0.\n   * @dev Assumes that sender approved this contract on the currency\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\n   * @param _provider      Address that provides liquidity to the reserve\n   * @param _tokenIds      Array of Token IDs where liquidity is added\n   * @param _tokenAmounts  Array of amount of Tokens deposited corresponding to each ID provided in _tokenIds\n   * @param _maxCurrency   Array of maximum number of tokens deposited for each ID provided in _tokenIds.\n   *                       Deposits max amount if total liquidity pool token supply is 0.\n   * @param _deadline      Timestamp after which this transaction will be reverted\n   */\n  function _addLiquidity(\n    address _provider,\n    uint256[] memory _tokenIds,\n    uint256[] memory _tokenAmounts,\n    uint256[] memory _maxCurrency,\n    uint256 _deadline)\n    internal nonReentrant()\n  {\n    // Requirements\n    require(_deadline >= block.timestamp, "NiftyswapExchange#_addLiquidity: DEADLINE_EXCEEDED");\n\n    // Initialize variables\n    uint256 nTokens = _tokenIds.length; // Number of Token IDs to deposit\n    uint256 totalCurrency = 0;          // Total amount of currency tokens to transfer\n\n    // Initialize arrays\n    uint256[] memory liquiditiesToMint = new uint256[](nTokens);\n    uint256[] memory currencyAmounts = new uint256[](nTokens);\n    uint256[] memory tokenReserves = new uint256[](nTokens);\n\n    // Get token reserves\n    tokenReserves = _getTokenReserves(_tokenIds);\n\n    // Assumes tokens _ids are deposited already, but not currency tokens\n    // as this is calculated and executed below.\n\n    // Loop over all Token IDs to deposit\n    for (uint256 i = 0; i < nTokens; i ++) {\n      // Store current id and amount from argument arrays\n      uint256 tokenId = _tokenIds[i];\n      uint256 amount = _tokenAmounts[i];\n\n      // Check if input values are acceptable\n      require(_maxCurrency[i] > 0, "NiftyswapExchange#_addLiquidity: NULL_MAX_CURRENCY");\n      require(amount > 0, "NiftyswapExchange#_addLiquidity: NULL_TOKENS_AMOUNT");\n\n      // If the token contract and currency contract are the same, prevent the creation\n      // of a currency pool.\n      if (currencyPoolBanned) {\n        require(tokenId != currencyID, "NiftyswapExchange#_addLiquidity: CURRENCY_POOL_FORBIDDEN");\n      }\n\n      // Current total liquidity calculated in currency token\n      uint256 totalLiquidity = totalSupplies[tokenId];\n\n      // When reserve for this token already exists\n      if (totalLiquidity > 0) {\n\n        // Load currency token and Token reserve\'s supply of Token id\n        uint256 currencyReserve = currencyReserves[tokenId]; // Amount not yet in reserve\n        uint256 tokenReserve = tokenReserves[i];\n\n        /**\n        * Amount of currency tokens to send to token id reserve:\n        * X/Y = dx/dy\n        * dx = X*dy/Y\n        * where\n        *   X:  currency total liquidity\n        *   Y:  Token _id total liquidity (before tokens were received)\n        *   dy: Amount of token _id deposited\n        *   dx: Amount of currency to deposit\n        *\n        * Adding .add(1) if rounding errors so to not favor users incorrectly\n        */\n        (uint256 currencyAmount, bool rounded) = divRound(amount.mul(currencyReserve), tokenReserve.sub(amount));\n        require(_maxCurrency[i] >= currencyAmount, "NiftyswapExchange#_addLiquidity: MAX_CURRENCY_AMOUNT_EXCEEDED");\n\n        // Update currency reserve size for Token id before transfer\n        currencyReserves[tokenId] = currencyReserve.add(currencyAmount);\n\n        // Update totalCurrency\n        totalCurrency = totalCurrency.add(currencyAmount);\n\n        // Proportion of the liquidity pool to give to current liquidity provider\n        // If rounding error occured, round down to favor previous liquidity providers\n        // See https://github.com/0xsequence/niftyswap/issues/19\n        liquiditiesToMint[i] = (currencyAmount.sub(rounded ? 1 : 0)).mul(totalLiquidity) / currencyReserve;\n        currencyAmounts[i] = currencyAmount;\n\n        // Mint liquidity ownership tokens and increase liquidity supply accordingly\n        totalSupplies[tokenId] = totalLiquidity.add(liquiditiesToMint[i]);\n\n      } else {\n        uint256 maxCurrency = _maxCurrency[i];\n\n        // Otherwise rounding error could end up being significant on second deposit\n        require(maxCurrency >= 1000000000, "NiftyswapExchange#_addLiquidity: INVALID_CURRENCY_AMOUNT");\n\n        // Update currency  reserve size for Token id before transfer\n        currencyReserves[tokenId] = maxCurrency;\n\n        // Update totalCurrency\n        totalCurrency = totalCurrency.add(maxCurrency);\n\n        // Initial liquidity is amount deposited (Incorrect pricing will be arbitraged)\n        // uint256 initialLiquidity = _maxCurrency;\n        totalSupplies[tokenId] = maxCurrency;\n\n        // Liquidity to mints\n        liquiditiesToMint[i] = maxCurrency;\n        currencyAmounts[i] = maxCurrency;\n      }\n    }\n\n    // Mint liquidity pool tokens\n    _batchMint(_provider, _tokenIds, liquiditiesToMint, "");\n\n    // Transfer all currency to this contract\n    currency.safeTransferFrom(_provider, address(this), currencyID, totalCurrency, abi.encode(DEPOSIT_SIG));\n\n    // Emit event\n    emit LiquidityAdded(_provider, _tokenIds, _tokenAmounts, currencyAmounts);\n  }\n\n  /**\n   * @dev Convert pool participation into amounts of token and currency.\n   * @dev Rounding error of the asset with lower resolution is traded for the other asset.\n   * @param _amountPool       Participation to be converted to tokens and currency.\n   * @param _tokenReserve     Amount of tokens on the AMM reserve.\n   * @param _currencyReserve  Amount of currency on the AMM reserve.\n   * @param _totalLiquidity   Total liquidity on the pool.\n   *\n   * @return currencyAmount Currency corresponding to pool amount plus rounded tokens.\n   * @return tokenAmount    Token corresponding to pool amount plus rounded currency.\n   */\n  function _toRoundedLiquidity(\n    uint256 _amountPool,\n    uint256 _tokenReserve,\n    uint256 _currencyReserve,\n    uint256 _totalLiquidity\n  ) internal pure returns (\n    uint256 currencyAmount,\n    uint256 tokenAmount,\n    uint256 soldTokenNumerator,\n    uint256 boughtCurrencyNumerator\n  ) {\n    uint256 currencyNumerator = _amountPool.mul(_currencyReserve);\n    uint256 tokenNumerator = _amountPool.mul(_tokenReserve);\n\n    // Convert all tokenProduct rest to currency\n    soldTokenNumerator = tokenNumerator % _totalLiquidity;\n    if (soldTokenNumerator != 0) {\n      // The trade happens "after" funds are out of the pool\n      // so we need to remove these funds before computing the rate\n      uint256 virtualTokenReserve = _tokenReserve.sub(tokenNumerator / _totalLiquidity).mul(_totalLiquidity);\n      uint256 virtualCurrencyReserve = _currencyReserve.sub(currencyNumerator / _totalLiquidity).mul(_totalLiquidity);\n\n      // Skip process if any of the two reserves is left empty\n      // this step is important to avoid an error withdrawing all left liquidity\n      if (virtualCurrencyReserve != 0 && virtualTokenReserve != 0) {\n        boughtCurrencyNumerator = getSellPrice(soldTokenNumerator, virtualTokenReserve, virtualCurrencyReserve);\n        currencyNumerator = currencyNumerator.add(boughtCurrencyNumerator);\n      }\n    }\n\n    // Calculate amounts\n    currencyAmount = currencyNumerator / _totalLiquidity;\n    tokenAmount = tokenNumerator / _totalLiquidity;\n  }\n\n  /**\n   * @dev Burn liquidity pool tokens to withdraw currency  && Tokens at current ratio.\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\n   * @param _provider         Address that removes liquidity to the reserve\n   * @param _tokenIds         Array of Token IDs where liquidity is removed\n   * @param _poolTokenAmounts Array of Amount of liquidity pool tokens burned for each Token id in _tokenIds.\n   * @param _minCurrency      Minimum currency withdrawn for each Token id in _tokenIds.\n   * @param _minTokens        Minimum Tokens id withdrawn for each Token id in _tokenIds.\n   * @param _deadline         Timestamp after which this transaction will be reverted\n   */\n  function _removeLiquidity(\n    address _provider,\n    uint256[] memory _tokenIds,\n    uint256[] memory _poolTokenAmounts,\n    uint256[] memory _minCurrency,\n    uint256[] memory _minTokens,\n    uint256 _deadline)\n    internal nonReentrant()\n  {\n    // Input validation\n    require(_deadline > block.timestamp, "NiftyswapExchange#_removeLiquidity: DEADLINE_EXCEEDED");\n\n    // Initialize variables\n    uint256 nTokens = _tokenIds.length;                       // Number of Token IDs to deposit\n    uint256 totalCurrency = 0;                                 // Total amount of currency  to transfer\n\n    uint256[] memory tokenAmounts = new uint256[](nTokens);    // Amount of Tokens to transfer for each id\n\n    // Structs contain most information for the event\n    // notice: tokenAmounts and tokenIds are absent because we already\n    // either have those arrays constructed or we need to construct them for other reasons\n    LiquidityRemovedEventObj[] memory eventObjs = new LiquidityRemovedEventObj[](nTokens);\n\n    // Get token reserves\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\n\n    // Assumes NIFTY liquidity tokens are already received by contract, but not\n    // the currency  nor the Tokens Ids\n\n    // Remove liquidity for each Token ID in _tokenIds\n    for (uint256 i = 0; i < nTokens; i++) {\n      // Store current id and amount from argument arrays\n      uint256 id = _tokenIds[i];\n      uint256 amountPool = _poolTokenAmounts[i];\n\n      // Load total liquidity pool token supply for Token _id\n      uint256 totalLiquidity = totalSupplies[id];\n      require(totalLiquidity > 0, "NiftyswapExchange#_removeLiquidity: NULL_TOTAL_LIQUIDITY");\n\n      // Load currency and Token reserve\'s supply of Token id\n      uint256 currencyReserve = currencyReserves[id];\n\n      // Calculate amount to withdraw for currency  and Token _id\n      uint256 currencyAmount;\n      uint256 tokenAmount;\n\n      {\n        uint256 tokenReserve = tokenReserves[i];\n        uint256 soldTokenNumerator;\n        uint256 boughtCurrencyNumerator;\n\n        (\n          currencyAmount,\n          tokenAmount,\n          soldTokenNumerator,\n          boughtCurrencyNumerator\n        ) = _toRoundedLiquidity(amountPool, tokenReserve, currencyReserve, totalLiquidity);\n\n        // Add trade info to event\n        eventObjs[i].soldTokenNumerator = soldTokenNumerator;\n        eventObjs[i].boughtCurrencyNumerator = boughtCurrencyNumerator;\n        eventObjs[i].totalSupply = totalLiquidity;\n      }\n\n      // Verify if amounts to withdraw respect minimums specified\n      require(currencyAmount >= _minCurrency[i], "NiftyswapExchange#_removeLiquidity: INSUFFICIENT_CURRENCY_AMOUNT");\n      require(tokenAmount >= _minTokens[i], "NiftyswapExchange#_removeLiquidity: INSUFFICIENT_TOKENS");\n\n      // Update total liquidity pool token supply of Token _id\n      totalSupplies[id] = totalLiquidity.sub(amountPool);\n\n      // Update currency reserve size for Token id\n      currencyReserves[id] = currencyReserve.sub(currencyAmount);\n\n      // Update totalCurrency and tokenAmounts\n      totalCurrency = totalCurrency.add(currencyAmount);\n      tokenAmounts[i] = tokenAmount;\n\n      eventObjs[i].currencyAmount = currencyAmount;\n    }\n\n    // Burn liquidity pool tokens for offchain supplies\n    _batchBurn(address(this), _tokenIds, _poolTokenAmounts);\n\n    // Transfer total currency  and all Tokens ids\n    currency.safeTransferFrom(address(this), _provider, currencyID, totalCurrency, "");\n    token.safeBatchTransferFrom(address(this), _provider, _tokenIds, tokenAmounts, "");\n\n    // Emit event\n    emit LiquidityRemoved(_provider, _tokenIds, tokenAmounts, eventObjs);\n  }\n\n  /***********************************|\n  |     Receiver Methods Handler      |\n  |__________________________________*/\n\n  // Method signatures for onReceive control logic\n\n  // bytes4(keccak256(\n  //   "_currencyToToken(uint256[],uint256[],uint256,uint256,address)"\n  // ));\n  bytes4 internal constant BUYTOKENS_SIG = 0xb2d81047;\n\n  // bytes4(keccak256(\n  //   "_tokenToCurrency(uint256[],uint256[],uint256,uint256,address)"\n  // ));\n  bytes4 internal constant SELLTOKENS_SIG = 0xdb08ec97;\n\n  //  bytes4(keccak256(\n  //   "_addLiquidity(address,uint256[],uint256[],uint256[],uint256)"\n  // ));\n  bytes4 internal constant ADDLIQUIDITY_SIG = 0x82da2b73;\n\n  // bytes4(keccak256(\n  //    "_removeLiquidity(address,uint256[],uint256[],uint256[],uint256[],uint256)"\n  // ));\n  bytes4 internal constant REMOVELIQUIDITY_SIG = 0x5c0bf259;\n\n  // bytes4(keccak256(\n  //   "DepositTokens()"\n  // ));\n  bytes4 internal constant DEPOSIT_SIG = 0xc8c323f9;\n\n  /**\n   * @notice Handle which method is being called on transfer\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\n   *   where bytes4 argument is the MethodObj object signature passed as defined\n   *   in the `Signatures for onReceive control logic` section above\n   * @param _from     The address which previously owned the Token\n   * @param _ids      An array containing ids of each Token being transferred\n   * @param _amounts  An array containing amounts of each Token being transferred\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\n   * @return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")\n   */\n  function onERC1155BatchReceived(\n    address, // _operator,\n    address _from,\n    uint256[] memory _ids,\n    uint256[] memory _amounts,\n    bytes memory _data)\n    override public returns(bytes4)\n  {\n    // This function assumes that the ERC-1155 token contract can\n    // only call `onERC1155BatchReceived()` via a valid token transfer.\n    // Users must be responsible and only use this Niftyswap exchange\n    // contract with ERC-1155 compliant token contracts.\n\n    // Obtain method to call via object signature\n    bytes4 functionSignature = abi.decode(_data, (bytes4));\n\n    /***********************************|\n    |           Buying Tokens           |\n    |__________________________________*/\n\n    if (functionSignature == BUYTOKENS_SIG) {\n      // Tokens received need to be currency contract\n      require(msg.sender == address(currency), "NiftyswapExchange#onERC1155BatchReceived: INVALID_CURRENCY_TRANSFERRED");\n      require(_ids.length == 1, "NiftyswapExchange#onERC1155BatchReceived: INVALID_CURRENCY_IDS_AMOUNT");\n      require(_ids[0] == currencyID, "NiftyswapExchange#onERC1155BatchReceived: INVALID_CURRENCY_ID");\n\n      // Decode BuyTokensObj from _data to call _currencyToToken()\n      BuyTokensObj memory obj;\n      (, obj) = abi.decode(_data, (bytes4, BuyTokensObj));\n      address recipient = obj.recipient == address(0x0) ? _from : obj.recipient;\n\n      // Execute trade and retrieve amount of currency spent\n      uint256[] memory currencySold = _currencyToToken(obj.tokensBoughtIDs, obj.tokensBoughtAmounts, _amounts[0], obj.deadline, recipient);\n      emit TokensPurchase(_from, recipient, obj.tokensBoughtIDs, obj.tokensBoughtAmounts, currencySold);\n\n    /***********************************|\n    |           Selling Tokens          |\n    |__________________________________*/\n\n    } else if (functionSignature == SELLTOKENS_SIG) {\n\n      // Tokens received need to be Token contract\n      require(msg.sender == address(token), "NiftyswapExchange#onERC1155BatchReceived: INVALID_TOKENS_TRANSFERRED");\n\n      // Decode SellTokensObj from _data to call _tokenToCurrency()\n      SellTokensObj memory obj;\n      (, obj) = abi.decode(_data, (bytes4, SellTokensObj));\n      address recipient = obj.recipient == address(0x0) ? _from : obj.recipient;\n\n      // Execute trade and retrieve amount of currency received\n      uint256[] memory currencyBought = _tokenToCurrency(_ids, _amounts, obj.minCurrency, obj.deadline, recipient);\n      emit CurrencyPurchase(_from, recipient, _ids, _amounts, currencyBought);\n\n    /***********************************|\n    |      Adding Liquidity Tokens      |\n    |__________________________________*/\n\n    } else if (functionSignature == ADDLIQUIDITY_SIG) {\n      // Only allow to receive ERC-1155 tokens from `token` contract\n      require(msg.sender == address(token), "NiftyswapExchange#onERC1155BatchReceived: INVALID_TOKEN_TRANSFERRED");\n\n      // Decode AddLiquidityObj from _data to call _addLiquidity()\n      AddLiquidityObj memory obj;\n      (, obj) = abi.decode(_data, (bytes4, AddLiquidityObj));\n      _addLiquidity(_from, _ids, _amounts, obj.maxCurrency, obj.deadline);\n\n    /***********************************|\n    |      Removing iquidity Tokens     |\n    |__________________________________*/\n\n    } else if (functionSignature == REMOVELIQUIDITY_SIG) {\n      // Tokens received need to be NIFTY-1155 tokens\n      require(msg.sender == address(this), "NiftyswapExchange#onERC1155BatchReceived: INVALID_NIFTY_TOKENS_TRANSFERRED");\n\n      // Decode RemoveLiquidityObj from _data to call _removeLiquidity()\n      RemoveLiquidityObj memory obj;\n      (, obj) = abi.decode(_data, (bytes4, RemoveLiquidityObj));\n      _removeLiquidity(_from, _ids, _amounts, obj.minCurrency, obj.minTokens, obj.deadline);\n\n    /***********************************|\n    |      Deposits & Invalid Calls     |\n    |__________________________________*/\n\n    } else if (functionSignature == DEPOSIT_SIG) {\n      // Do nothing for when contract is self depositing\n      // This could be use to deposit currency "by accident", which would be locked\n      require(msg.sender == address(currency), "NiftyswapExchange#onERC1155BatchReceived: INVALID_TOKENS_DEPOSITED");\n      require(_ids[0] == currencyID, "NiftyswapExchange#onERC1155BatchReceived: INVALID_CURRENCY_ID");\n\n    } else {\n      revert("NiftyswapExchange#onERC1155BatchReceived: INVALID_METHOD");\n    }\n\n    return ERC1155_BATCH_RECEIVED_VALUE;\n  }\n\n  /**\n   * @dev Will pass to onERC115Batch5Received\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes memory _data)\n    override public returns(bytes4)\n  {\n    uint256[] memory ids = new uint256[](1);\n    uint256[] memory amounts = new uint256[](1);\n\n    ids[0] = _id;\n    amounts[0] = _amount;\n\n    require(\n      ERC1155_BATCH_RECEIVED_VALUE == onERC1155BatchReceived(_operator, _from, ids, amounts, _data),\n      "NiftyswapExchange#onERC1155Received: INVALID_ONRECEIVED_MESSAGE"\n    );\n\n    return ERC1155_RECEIVED_VALUE;\n  }\n\n  /**\n   * @notice Prevents receiving Ether or calls to unsuported methods\n   */\n  fallback () external {\n    revert("NiftyswapExchange:UNSUPPORTED_METHOD");\n  }\n\n  /***********************************|\n  |         Getter Functions          |\n  |__________________________________*/\n\n  /**\n   * @notice Get amount of currency in reserve for each Token _id in _ids\n   * @param _ids Array of ID sto query currency reserve of\n   * @return amount of currency in reserve for each Token _id\n   */\n  function getCurrencyReserves(\n    uint256[] calldata _ids)\n    override external view returns (uint256[] memory)\n  {\n    uint256 nIds = _ids.length;\n    uint256[] memory currencyReservesReturn = new uint256[](nIds);\n    for (uint256 i = 0; i < nIds; i++) {\n      currencyReservesReturn[i] = currencyReserves[_ids[i]];\n    }\n    return currencyReservesReturn;\n  }\n\n  /**\n   * @notice Return price for `currency => Token _id` trades with an exact token amount.\n   * @param _ids           Array of ID of tokens bought.\n   * @param _tokensBought Amount of Tokens bought.\n   * @return Amount of currency needed to buy Tokens in _ids for amounts in _tokensBought\n   */\n  function getPrice_currencyToToken(\n    uint256[] calldata _ids,\n    uint256[] calldata _tokensBought)\n    override external view returns (uint256[] memory)\n  {\n    uint256 nIds = _ids.length;\n    uint256[] memory prices = new uint256[](nIds);\n\n    for (uint256 i = 0; i < nIds; i++) {\n      // Load Token id reserve\n      uint256 tokenReserve = token.balanceOf(address(this), _ids[i]);\n      prices[i] = getBuyPrice(_tokensBought[i], currencyReserves[_ids[i]], tokenReserve);\n    }\n\n    // Return prices\n    return prices;\n  }\n\n  /**\n   * @notice Return price for `Token _id => currency` trades with an exact token amount.\n   * @param _ids        Array of IDs  token sold.\n   * @param _tokensSold Array of amount of each Token sold.\n   * @return Amount of currency that can be bought for Tokens in _ids for amounts in _tokensSold\n   */\n  function getPrice_tokenToCurrency(\n    uint256[] calldata _ids,\n    uint256[] calldata _tokensSold)\n    override external view returns (uint256[] memory)\n  {\n    uint256 nIds = _ids.length;\n    uint256[] memory prices = new uint256[](nIds);\n\n    for (uint256 i = 0; i < nIds; i++) {\n      // Load Token id reserve\n      uint256 tokenReserve = token.balanceOf(address(this), _ids[i]);\n      prices[i] = getSellPrice(_tokensSold[i], tokenReserve, currencyReserves[_ids[i]]);\n    }\n\n    // Return price\n    return prices;\n  }\n\n  /**\n   * @return Address of Token that is sold on this exchange.\n   */\n  function getTokenAddress() override external view returns (address) {\n    return address(token);\n  }\n\n  /**\n   * @return Address of the currency contract that is used as currency and its corresponding id\n   */\n  function getCurrencyInfo() override external view returns (address, uint256) {\n    return (address(currency), currencyID);\n  }\n\n  /**\n   * @notice Get total supply of liquidity tokens\n   * @param _ids ID of the Tokens\n   * @return The total supply of each liquidity token id provided in _ids\n   */\n  function getTotalSupply(uint256[] calldata _ids)\n    override external view returns (uint256[] memory)\n  {\n    // Number of ids\n    uint256 nIds = _ids.length;\n\n    // Variables\n    uint256[] memory batchTotalSupplies = new uint256[](nIds);\n\n    // Iterate over each owner and token ID\n    for (uint256 i = 0; i < nIds; i++) {\n      batchTotalSupplies[i] = totalSupplies[_ids[i]];\n    }\n\n    return batchTotalSupplies;\n  }\n\n  /**\n   * @return Address of factory that created this exchange.\n   */\n  function getFactoryAddress() override external view returns (address) {\n    return factory;\n  }\n\n  /***********************************|\n  |         Utility Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Divides two numbers and add 1 if there is a rounding error\n   * @param a Numerator\n   * @param b Denominator\n   */\n  function divRound(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n    return a % b == 0 ? (a/b, false) : ((a/b).add(1), true);\n  }\n\n  /**\n   * @notice Return Token reserves for given Token ids\n   * @dev Assumes that ids are sorted from lowest to highest with no duplicates.\n   *      This assumption allows for checking the token reserves only once, otherwise\n   *      token reserves need to be re-checked individually or would have to do more expensive\n   *      duplication checks.\n   * @param _tokenIds Array of IDs to query their Reserve balance.\n   * @return Array of Token ids\' reserves\n   */\n  function _getTokenReserves(\n    uint256[] memory _tokenIds)\n    internal view returns (uint256[] memory)\n  {\n    uint256 nTokens = _tokenIds.length;\n\n    // Regular balance query if only 1 token, otherwise batch query\n    if (nTokens == 1) {\n      uint256[] memory tokenReserves = new uint256[](1);\n      tokenReserves[0] = token.balanceOf(address(this), _tokenIds[0]);\n      return tokenReserves;\n\n    } else {\n      // Lazy check preventing duplicates & build address array for query\n      address[] memory thisAddressArray = new address[](nTokens);\n      thisAddressArray[0] = address(this);\n\n      for (uint256 i = 1; i < nTokens; i++) {\n        require(_tokenIds[i-1] < _tokenIds[i], "NiftyswapExchange#_getTokenReserves: UNSORTED_OR_DUPLICATE_TOKEN_IDS");\n        thisAddressArray[i] = address(this);\n      }\n      return token.balanceOfBatch(thisAddressArray, _tokenIds);\n    }\n  }\n\n  /**\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n   *      This function MUST NOT consume more thsan 5,000 gas.\n   * @return Whether a given interface is supported\n   */\n  function supportsInterface(bytes4 interfaceID) public override pure returns (bool) {\n    return  interfaceID == type(IERC165).interfaceId ||\n      interfaceID == type(IERC1155).interfaceId || \n      interfaceID == type(IERC1155TokenReceiver).interfaceId;        \n  }\n\n}\n'
      },
      'contracts/interfaces/INiftyswapExchange.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\ninterface INiftyswapExchange {\n\n  /***********************************|\n  |               Events              |\n  |__________________________________*/\n\n  event TokensPurchase(\n    address indexed buyer,\n    address indexed recipient,\n    uint256[] tokensBoughtIds,\n    uint256[] tokensBoughtAmounts,\n    uint256[] currencySoldAmounts\n  );\n\n  event CurrencyPurchase(\n    address indexed buyer,\n    address indexed recipient,\n    uint256[] tokensSoldIds,\n    uint256[] tokensSoldAmounts,\n    uint256[] currencyBoughtAmounts\n  );\n\n  event LiquidityAdded(\n    address indexed provider,\n    uint256[] tokenIds,\n    uint256[] tokenAmounts,\n    uint256[] currencyAmounts\n  );\n\n  struct LiquidityRemovedEventObj {\n    uint256 currencyAmount;\n    uint256 soldTokenNumerator;\n    uint256 boughtCurrencyNumerator;\n    uint256 totalSupply;\n  }\n\n  event LiquidityRemoved(\n    address indexed provider,\n    uint256[] tokenIds,\n    uint256[] tokenAmounts,\n    LiquidityRemovedEventObj[] details\n  );\n\n    // OnReceive Objects\n  struct BuyTokensObj {\n    address recipient;             // Who receives the tokens\n    uint256[] tokensBoughtIDs;     // Token IDs to buy\n    uint256[] tokensBoughtAmounts; // Amount of token to buy for each ID\n    uint256 deadline;              // Timestamp after which the tx isn\'t valid anymore\n  }\n\n  struct SellTokensObj {\n    address recipient;   // Who receives the currency\n    uint256 minCurrency; // Total minimum number of currency  expected for all tokens sold\n    uint256 deadline;    // Timestamp after which the tx isn\'t valid anymore\n  }\n\n  struct AddLiquidityObj {\n    uint256[] maxCurrency; // Maximum number of currency to deposit with tokens\n    uint256 deadline;      // Timestamp after which the tx isn\'t valid anymore\n  }\n\n  struct RemoveLiquidityObj {\n    uint256[] minCurrency; // Minimum number of currency to withdraw\n    uint256[] minTokens;   // Minimum number of tokens to withdraw\n    uint256 deadline;      // Timestamp after which the tx isn\'t valid anymore\n  }\n\n  /***********************************|\n  |        OnReceive Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Handle which method is being called on Token transfer\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\n   *   where bytes4 argument is the MethodObj object signature passed as defined\n   *   in the `Signatures for onReceive control logic` section above\n   * @param _operator The address which called the `safeTransferFrom` function\n   * @param _from     The address which previously owned the token\n   * @param _id       The id of the token being transferred\n   * @param _amount   The amount of tokens being transferred\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\n   * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Handle which method is being called on transfer\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\n   *   where bytes4 argument is the MethodObj object signature passed as defined\n   *   in the `Signatures for onReceive control logic` section above\n   * @param _from     The address which previously owned the Token\n   * @param _ids      An array containing ids of each Token being transferred\n   * @param _amounts  An array containing amounts of each Token being transferred\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\n   * @return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")\n   */\n  function onERC1155BatchReceived(address, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n\n\n  /***********************************|\n  |         Getter Functions          |\n  |__________________________________*/\n\n  /**\n   * @dev Pricing function used for converting between currency token to Tokens.\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\n   * @return Amount of currency tokens to send to Niftyswap.\n   */\n  function getBuyPrice(uint256 _assetBoughtAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external pure returns (uint256);\n\n  /**\n   * @dev Pricing function used for converting Tokens to currency token.\n   * @param _assetSoldAmount    Amount of Tokens being sold.\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\n   * @return Amount of currency tokens to receive from Niftyswap.\n   */\n  function getSellPrice(uint256 _assetSoldAmount,uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external pure returns (uint256);\n\n  /**\n   * @notice Get amount of currency in reserve for each Token _id in _ids\n   * @param _ids Array of ID sto query currency reserve of\n   * @return amount of currency in reserve for each Token _id\n   */\n  function getCurrencyReserves(uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Return price for `currency => Token _id` trades with an exact token amount.\n   * @param _ids          Array of ID of tokens bought.\n   * @param _tokensBought Amount of Tokens bought.\n   * @return Amount of currency needed to buy Tokens in _ids for amounts in _tokensBought\n   */\n  function getPrice_currencyToToken(uint256[] calldata _ids, uint256[] calldata _tokensBought) external view returns (uint256[] memory);\n\n  /**\n   * @notice Return price for `Token _id => currency` trades with an exact token amount.\n   * @param _ids        Array of IDs  token sold.\n   * @param _tokensSold Array of amount of each Token sold.\n   * @return Amount of currency that can be bought for Tokens in _ids for amounts in _tokensSold\n   */\n  function getPrice_tokenToCurrency(uint256[] calldata _ids, uint256[] calldata _tokensSold) external view returns (uint256[] memory);\n\n  /**\n   * @notice Get total supply of liquidity tokens\n   * @param _ids ID of the Tokens\n   * @return The total supply of each liquidity token id provided in _ids\n   */\n  function getTotalSupply(uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @return Address of Token that is sold on this exchange.\n   */\n  function getTokenAddress() external view returns (address);\n\n  /**\n   * @return Address of the currency contract that is used as currency and its corresponding id\n   */\n  function getCurrencyInfo() external view returns (address, uint256);\n\n  /**\n   * @return Address of factory that created this exchange.\n   */\n  function getFactoryAddress() external view returns (address);\n\n}'
      },
      'contracts/utils/ReentrancyGuard.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity 0.7.4;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
      },
      '@0xsequence/erc-1155/contracts/interfaces/IERC165.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\n\n/**\n * @title ERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n    /**\n     * @notice Query if a contract implements an interface\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas\n     * @param _interfaceId The interface identifier, as specified in ERC-165\n     */\n    function supportsInterface(bytes4 _interfaceId)\n    external\n    view\n    returns (bool);\n}\n'
      },
      '@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\nimport \'./IERC165.sol\';\n\n\ninterface IERC1155 is IERC165 {\n\n  /****************************************|\n  |                 Events                 |\n  |_______________________________________*/\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n\n  /**\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n   *   Operator MUST be msg.sender\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n   */\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n\n  /**\n   * @dev MUST emit when an approval is updated\n   */\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\n  /****************************************|\n  |                Functions               |\n  |_______________________________________*/\n\n  /**\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\n    * @dev MUST emit TransferSingle event on success\n    * Caller must be approved to manage the _from account\'s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n    * @param _from    Source address\n    * @param _to      Target address\n    * @param _id      ID of the token type\n    * @param _amount  Transfered amount\n    * @param _data    Additional data with no specified format, sent in call to `_to`\n    */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n\n  /**\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n    * @dev MUST emit TransferBatch event on success\n    * Caller must be approved to manage the _from account\'s tokens (see isApprovedForAll)\n    * MUST throw if `_to` is the zero address\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n    * MUST throw on any other error\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n    * @param _from     Source addresses\n    * @param _to       Target addresses\n    * @param _ids      IDs of each token type\n    * @param _amounts  Transfer amounts per token type\n    * @param _data     Additional data with no specified format, sent in call to `_to`\n  */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n\n  /**\n   * @notice Get the balance of an account\'s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return        The _owner\'s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders\n   * @param _ids    ID of the Tokens\n   * @return        The _owner\'s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n   */\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n   * @dev MUST emit the ApprovalForAll event on success\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /**\n   * @notice Queries the approval status of an operator for a given owner\n   * @param _owner     The owner of the Tokens\n   * @param _operator  Address of authorized operator\n   * @return isOperator True if the operator is approved, false if not\n   */\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n}\n'
      },
      '@0xsequence/erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\n/**\n * @dev ERC-1155 interface for accepting safe transfers.\n */\ninterface IERC1155TokenReceiver {\n\n  /**\n   * @notice Handle the receipt of a single ERC1155 token type\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value MUST result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _id        The id of the token being transferred\n   * @param _amount    The amount of tokens being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Handle the receipt of multiple ERC1155 token types\n   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n   * This function MAY throw to revert and reject the transfer\n   * Return of other amount than the magic value WILL result in the transaction being reverted\n   * Note: The token contract address is always the message sender\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _ids       An array containing ids of each token being transferred\n   * @param _amounts   An array containing amounts of each token being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n   */\n  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n}\n'
      },
      '@0xsequence/erc-1155/contracts/tokens/ERC1155/ERC1155MintBurn.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\nimport "./ERC1155.sol";\n\n\n/**\n * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\n *      a parent contract to be executed as they are `internal` functions\n */\ncontract ERC1155MintBurn is ERC1155 {\n  using SafeMath for uint256;\n\n  /****************************************|\n  |            Minting Functions           |\n  |_______________________________________*/\n\n  /**\n   * @notice Mint _amount of tokens of a given id\n   * @param _to      The address to mint tokens to\n   * @param _id      Token id to mint\n   * @param _amount  The amount to be minted\n   * @param _data    Data to pass if receiver is contract\n   */\n  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\n    internal\n  {\n    // Add _amount\n    balances[_to][_id] = balances[_to][_id].add(_amount);\n\n    // Emit event\n    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\n\n    // Calling onReceive method if recipient is contract\n    _callonERC1155Received(address(0x0), _to, _id, _amount, gasleft(), _data);\n  }\n\n  /**\n   * @notice Mint tokens for each ids in _ids\n   * @param _to       The address to mint tokens to\n   * @param _ids      Array of ids to mint\n   * @param _amounts  Array of amount of tokens to mint per id\n   * @param _data    Data to pass if receiver is contract\n   */\n  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    internal\n  {\n    require(_ids.length == _amounts.length, "ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH");\n\n    // Number of mints to execute\n    uint256 nMint = _ids.length;\n\n     // Executing all minting\n    for (uint256 i = 0; i < nMint; i++) {\n      // Update storage balance\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\n    }\n\n    // Emit batch mint event\n    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\n\n    // Calling onReceive method if recipient is contract\n    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, gasleft(), _data);\n  }\n\n\n  /****************************************|\n  |            Burning Functions           |\n  |_______________________________________*/\n\n  /**\n   * @notice Burn _amount of tokens of a given token id\n   * @param _from    The address to burn tokens from\n   * @param _id      Token id to burn\n   * @param _amount  The amount to be burned\n   */\n  function _burn(address _from, uint256 _id, uint256 _amount)\n    internal\n  {\n    //Substract _amount\n    balances[_from][_id] = balances[_from][_id].sub(_amount);\n\n    // Emit event\n    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\n  }\n\n  /**\n   * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\n   * @param _from     The address to burn tokens from\n   * @param _ids      Array of token ids to burn\n   * @param _amounts  Array of the amount to be burned\n   */\n  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\n    internal\n  {\n    // Number of mints to execute\n    uint256 nBurn = _ids.length;\n    require(nBurn == _amounts.length, "ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH");\n\n    // Executing all minting\n    for (uint256 i = 0; i < nBurn; i++) {\n      // Update storage balance\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\n    }\n\n    // Emit batch mint event\n    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\n  }\n}\n'
      },
      '@0xsequence/erc-1155/contracts/tokens/ERC1155/ERC1155.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\nimport "../../utils/SafeMath.sol";\nimport "../../interfaces/IERC1155TokenReceiver.sol";\nimport "../../interfaces/IERC1155.sol";\nimport "../../utils/Address.sol";\nimport "../../utils/ERC165.sol";\n\n\n/**\n * @dev Implementation of Multi-Token Standard contract\n */\ncontract ERC1155 is IERC1155, ERC165 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  /***********************************|\n  |        Variables and Events       |\n  |__________________________________*/\n\n  // onReceive function signatures\n  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n\n  // Objects balances\n  mapping (address => mapping(uint256 => uint256)) internal balances;\n\n  // Operator Functions\n  mapping (address => mapping(address => bool)) internal operators;\n\n\n  /***********************************|\n  |     Public Transfer Functions     |\n  |__________________________________*/\n\n  /**\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n   * @param _from    Source address\n   * @param _to      Target address\n   * @param _id      ID of the token type\n   * @param _amount  Transfered amount\n   * @param _data    Additional data with no specified format, sent in call to `_to`\n   */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n    public override\n  {\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155#safeTransferFrom: INVALID_OPERATOR");\n    require(_to != address(0),"ERC1155#safeTransferFrom: INVALID_RECIPIENT");\n    // require(_amount <= balances[_from][_id]) is not necessary since checked with safemath operations\n\n    _safeTransferFrom(_from, _to, _id, _amount);\n    _callonERC1155Received(_from, _to, _id, _amount, gasleft(), _data);\n  }\n\n  /**\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n   * @param _from     Source addresses\n   * @param _to       Target addresses\n   * @param _ids      IDs of each token type\n   * @param _amounts  Transfer amounts per token type\n   * @param _data     Additional data with no specified format, sent in call to `_to`\n   */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    public override\n  {\n    // Requirements\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155#safeBatchTransferFrom: INVALID_OPERATOR");\n    require(_to != address(0), "ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT");\n\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasleft(), _data);\n  }\n\n\n  /***********************************|\n  |    Internal Transfer Functions    |\n  |__________________________________*/\n\n  /**\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n   * @param _from    Source address\n   * @param _to      Target address\n   * @param _id      ID of the token type\n   * @param _amount  Transfered amount\n   */\n  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\n    internal\n  {\n    // Update balances\n    balances[_from][_id] = balances[_from][_id].sub(_amount); // Subtract amount\n    balances[_to][_id] = balances[_to][_id].add(_amount);     // Add amount\n\n    // Emit event\n    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n  }\n\n  /**\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\n   */\n  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, uint256 _gasLimit, bytes memory _data)\n    internal\n  {\n    // Check if recipient is contract\n    if (_to.isContract()) {\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received{gas: _gasLimit}(msg.sender, _from, _id, _amount, _data);\n      require(retval == ERC1155_RECEIVED_VALUE, "ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE");\n    }\n  }\n\n  /**\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n   * @param _from     Source addresses\n   * @param _to       Target addresses\n   * @param _ids      IDs of each token type\n   * @param _amounts  Transfer amounts per token type\n   */\n  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\n    internal\n  {\n    require(_ids.length == _amounts.length, "ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH");\n\n    // Number of transfer to execute\n    uint256 nTransfer = _ids.length;\n\n    // Executing all transfers\n    for (uint256 i = 0; i < nTransfer; i++) {\n      // Update storage balance of previous bin\n      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\n      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\n    }\n\n    // Emit event\n    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n  }\n\n  /**\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\n   */\n  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, uint256 _gasLimit, bytes memory _data)\n    internal\n  {\n    // Pass data if recipient is contract\n    if (_to.isContract()) {\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived{gas: _gasLimit}(msg.sender, _from, _ids, _amounts, _data);\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, "ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE");\n    }\n  }\n\n\n  /***********************************|\n  |         Operator Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved)\n    external override\n  {\n    // Update operator status\n    operators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }\n\n  /**\n   * @notice Queries the approval status of an operator for a given owner\n   * @param _owner     The owner of the Tokens\n   * @param _operator  Address of authorized operator\n   * @return isOperator True if the operator is approved, false if not\n   */\n  function isApprovedForAll(address _owner, address _operator)\n    public override view returns (bool isOperator)\n  {\n    return operators[_owner][_operator];\n  }\n\n\n  /***********************************|\n  |         Balance Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Get the balance of an account\'s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return The _owner\'s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id)\n    public override view returns (uint256)\n  {\n    return balances[_owner][_id];\n  }\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders\n   * @param _ids    ID of the Tokens\n   * @return        The _owner\'s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n   */\n  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\n    public override view returns (uint256[] memory)\n  {\n    require(_owners.length == _ids.length, "ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH");\n\n    // Variables\n    uint256[] memory batchBalances = new uint256[](_owners.length);\n\n    // Iterate over each owner and token ID\n    for (uint256 i = 0; i < _owners.length; i++) {\n      batchBalances[i] = balances[_owners[i]][_ids[i]];\n    }\n\n    return batchBalances;\n  }\n\n\n  /***********************************|\n  |          ERC165 Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID` and\n   */\n  function supportsInterface(bytes4 _interfaceID) public override(ERC165, IERC165) virtual pure returns (bool) {\n    if (_interfaceID == type(IERC1155).interfaceId) {\n      return true;\n    }\n    return super.supportsInterface(_interfaceID);\n  }\n}\n'
      },
      '@0xsequence/erc-1155/contracts/utils/SafeMath.sol': {
        content:
          'pragma solidity 0.7.4;\n\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n   * @dev Multiplies two unsigned integers, reverts on overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n    // benefit is lost if \'b\' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, "SafeMath#mul: OVERFLOW");\n\n    return c;\n  }\n\n  /**\n   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, "SafeMath#div: DIVISION_BY_ZERO");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\'t hold\n\n    return c;\n  }\n\n  /**\n   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, "SafeMath#sub: UNDERFLOW");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Adds two unsigned integers, reverts on overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, "SafeMath#add: OVERFLOW");\n\n    return c; \n  }\n\n  /**\n   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n   * reverts when dividing by zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, "SafeMath#mod: DIVISION_BY_ZERO");\n    return a % b;\n  }\n}'
      },
      '@0xsequence/erc-1155/contracts/utils/Address.sol': {
        content:
          'pragma solidity 0.7.4;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n\n  // Default hash for EOA accounts returned by extcodehash\n  bytes32 constant internal ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract.\n   * @param _address address of the account to check\n   * @return Whether the target address is a contract\n   */\n  function isContract(address _address) internal view returns (bool) {\n    bytes32 codehash;\n\n    // Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address or if it has a non-zero code hash or account hash\n    assembly { codehash := extcodehash(_address) }\n    return (codehash != 0x0 && codehash != ACCOUNT_HASH);\n  }\n}'
      },
      '@0xsequence/erc-1155/contracts/utils/ERC165.sol': {
        content:
          'pragma solidity 0.7.4;\nimport "../interfaces/IERC165.sol";\n\nabstract contract ERC165 is IERC165 {\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(bytes4 _interfaceID) virtual override public pure returns (bool) {\n    return _interfaceID == this.supportsInterface.selector;\n  }\n}'
      },
      'contracts/exchange/NiftyswapFactory.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\nimport "./NiftyswapExchange.sol";\nimport "../interfaces/INiftyswapFactory.sol";\n\n\ncontract NiftyswapFactory is INiftyswapFactory {\n\n  /***********************************|\n  |       Events And Variables        |\n  |__________________________________*/\n\n  // tokensToExchange[erc1155_token_address][currency_address][currency_token_id]\n  mapping(address => mapping(address => mapping(uint256 => address))) public override tokensToExchange;\n\n  /***********************************|\n  |             Functions             |\n  |__________________________________*/\n\n  /**\n   * @notice Creates a NiftySwap Exchange for given token contract\n   * @param _token      The address of the ERC-1155 token contract\n   * @param _currency   The address of the currency token contract\n   * @param _currencyID The id of the currency token\n   */\n  function createExchange(address _token, address _currency, uint256 _currencyID) public override {\n    require(tokensToExchange[_token][_currency][_currencyID] == address(0x0), "NiftyswapFactory#createExchange: EXCHANGE_ALREADY_CREATED");\n\n    // Create new exchange contract\n    NiftyswapExchange exchange = new NiftyswapExchange(_token, _currency, _currencyID);\n\n    // Store exchange and token addresses\n    tokensToExchange[_token][_currency][_currencyID] = address(exchange);\n\n    // Emit event\n    emit NewExchange(_token, _currency, _currencyID, address(exchange));\n  }\n\n}\n'
      },
      'contracts/interfaces/INiftyswapFactory.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\ninterface INiftyswapFactory {\n\n  /***********************************|\n  |               Events              |\n  |__________________________________*/\n\n  event NewExchange(address indexed token, address indexed currency, uint256 indexed currencyID, address exchange);\n\n\n  /***********************************|\n  |         Public  Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Creates a NiftySwap Exchange for given token contract\n   * @param _token      The address of the ERC-1155 token contract\n   * @param _currency   The address of the currency token contract\n   * @param _currencyID The id of the currency token\n   */\n  function createExchange(address _token, address _currency, uint256 _currencyID) external;\n\n  /**\n   * @notice Return address of exchange for corresponding ERC-1155 token contract\n   * @param _token      The address of the ERC-1155 token contract\n   * @param _currency   The address of the currency token contract\n   * @param _currencyID The id of the currency token\n   */\n  function tokensToExchange(address _token, address _currency, uint256 _currencyID) external view returns (address);\n\n}'
      },
      '@0xsequence/erc20-meta-token/contracts/wrapper/MetaERC20Wrapper.sol': {
        content:
          'pragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC20.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC165.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol";\nimport "@0xsequence/erc-1155/contracts/tokens/ERC1155/ERC1155Meta.sol";\nimport "@0xsequence/erc-1155/contracts/tokens/ERC1155/ERC1155MintBurn.sol";\n\n\n/**\n * @notice Allows users to wrap any amount of any ERC-20 token with a 1:1 ratio\n *   of corresponding ERC-1155 tokens with native metaTransaction methods. Each\n *   ERC-20 is assigned an ERC-1155 id for more efficient CALLDATA usage when\n *   doing transfers.\n */\ncontract MetaERC20Wrapper is ERC1155Meta, ERC1155MintBurn {\n\n  // Variables\n  uint256 internal nTokens = 1;                         // Number of ERC-20 tokens registered\n  uint256 constant internal ETH_ID = 0x1;               // ID fo tokens representing Ether is 1\n  address constant internal ETH_ADDRESS = address(0x1); // Address for tokens representing Ether is 0x00...01\n  mapping (address => uint256) internal addressToID;    // Maps the ERC-20 addresses to their metaERC20 id\n  mapping (uint256 => address) internal IDtoAddress;    // Maps the metaERC20 ids to their ERC-20 address\n\n\n  /***********************************|\n  |               Events              |\n  |__________________________________*/\n\n  event TokenRegistration(address token_address, uint256 token_id);\n\n  /***********************************|\n  |            Constructor            |\n  |__________________________________*/\n\n  // Register ETH as ID #1 and address 0x1\n  constructor() public {\n    addressToID[ETH_ADDRESS] = ETH_ID;\n    IDtoAddress[ETH_ID] = ETH_ADDRESS;\n  }\n\n  /***********************************|\n  |         Deposit Functions         |\n  |__________________________________*/\n\n  /**\n   * Fallback function\n   * @dev Deposit ETH in this contract to receive wrapped ETH\n   * No parameters provided\n   */\n  receive () external payable {\n    // Deposit ETH sent with transaction\n    deposit(ETH_ADDRESS, msg.sender, msg.value);\n  }\n\n  /**\n   * @dev Deposit ERC20 tokens or ETH in this contract to receive wrapped ERC20s\n   * @param _token     The addess of the token to deposit in this contract\n   * @param _recipient Address that will receive the ERC-1155 tokens\n   * @param _value     The amount of token to deposit in this contract\n   * Note: Users must first approve this contract addres on the contract of the ERC20 to be deposited\n   */\n  function deposit(address _token, address _recipient, uint256 _value)\n    public payable\n  {\n    require(_recipient != address(0x0), "MetaERC20Wrapper#deposit: INVALID_RECIPIENT");\n\n    // Internal ID of ERC-20 token deposited\n    uint256 id;\n\n    // Deposit ERC-20 tokens or ETH\n    if (_token != ETH_ADDRESS) {\n\n      // Check if transfer passes\n      require(msg.value == 0, "MetaERC20Wrapper#deposit: NON_NULL_MSG_VALUE");\n      IERC20(_token).transferFrom(msg.sender, address(this), _value);\n      require(checkSuccess(), "MetaERC20Wrapper#deposit: TRANSFER_FAILED");\n\n      // Load address token ID\n      uint256 addressId = addressToID[_token];\n\n      // Register ID if not already done\n      if (addressId == 0) {\n        nTokens += 1;             // Increment number of tokens registered\n        id = nTokens;             // id of token is the current # of tokens\n        IDtoAddress[id] = _token; // Map id to token address\n        addressToID[_token] = id; // Register token\n\n        // Emit registration event\n        emit TokenRegistration(_token, id);\n\n      } else {\n        id = addressId;\n      }\n\n    } else {\n      require(_value == msg.value, "MetaERC20Wrapper#deposit: INCORRECT_MSG_VALUE");\n      id = ETH_ID;\n    }\n\n    // Mint meta tokens\n    _mint(_recipient, id, _value, "");\n  }\n\n\n  /***********************************|\n  |         Withdraw Functions        |\n  |__________________________________*/\n\n  /**\n   * @dev Withdraw wrapped ERC20 tokens in this contract to receive the original ERC20s or ETH\n   * @param _token The addess of the token to withdrww from this contract\n   * @param _to The address where the withdrawn tokens will go to\n   * @param _value The amount of tokens to withdraw\n   */\n  function withdraw(address _token, address payable _to, uint256 _value) public {\n    uint256 tokenID = getTokenID(_token);\n    _withdraw(msg.sender, _to, tokenID, _value);\n  }\n\n  /**\n   * @dev Withdraw wrapped ERC20 tokens in this contract to receive the original ERC20s or ETH\n   * @param _from    Address of users sending the Meta tokens\n   * @param _to      The address where the withdrawn tokens will go to\n   * @param _tokenID The token ID of the ERC-20 token to withdraw from this contract\n   * @param _value   The amount of tokens to withdraw\n   */\n  function _withdraw(\n    address _from,\n    address payable _to,\n    uint256 _tokenID,\n    uint256 _value)\n    internal\n  {\n    // Burn meta tokens\n    _burn(_from, _tokenID, _value);\n\n     // Withdraw ERC-20 tokens or ETH\n    if (_tokenID != ETH_ID) {\n      address token = IDtoAddress[_tokenID];\n      IERC20(token).transfer(_to, _value);\n      require(checkSuccess(), "MetaERC20Wrapper#withdraw: TRANSFER_FAILED");\n\n    } else {\n      require(_to != address(0), "MetaERC20Wrapper#withdraw: INVALID_RECIPIENT");\n      (bool success, ) = _to.call{value: _value}("");\n      require(success, "MetaERC20Wrapper#withdraw: TRANSFER_FAILED");\n    }\n\n\n  }\n  /**\n   * @notice Withdraw ERC-20 tokens when receiving their ERC-1155 counterpart\n   * @param _from      The address which previously owned the token\n   * @param _id        The id of the token being transferred\n   * @param _value     The amount of tokens being transferred\n   * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n   */\n  function onERC1155Received(address, address payable _from, uint256 _id, uint256 _value, bytes memory)\n    public returns(bytes4)\n  {\n    // Only ERC-1155 from this contract are valid\n    require(msg.sender == address(this), "MetaERC20Wrapper#onERC1155Received: INVALID_ERC1155_RECEIVED");\n    getIdAddress(_id); // Checks if id is registered\n\n    // Tokens are received, hence need to burn them here\n    _withdraw(address(this), _from, _id, _value);\n\n    return ERC1155_RECEIVED_VALUE;\n  }\n\n  /**\n   * @notice Withdraw ERC-20 tokens when receiving their ERC-1155 counterpart\n   * @param _from      The address which previously owned the token\n   * @param _ids       An array containing ids of each token being transferred\n   * @param _values    An array containing amounts of each token being transferred\n   * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n   */\n  function onERC1155BatchReceived(address, address payable _from, uint256[] memory _ids, uint256[] memory _values, bytes memory)\n    public returns(bytes4)\n  {\n    // Only ERC-1155 from this contract are valid\n    require(msg.sender == address(this), "MetaERC20Wrapper#onERC1155BatchReceived: INVALID_ERC1155_RECEIVED");\n\n    // Withdraw all tokens\n    for ( uint256 i = 0; i < _ids.length; i++) {\n      // Checks if id is registered\n      getIdAddress(_ids[i]);\n\n      // Tokens are received, hence need to burn them here\n      _withdraw(address(this), _from, _ids[i], _values[i]);\n    }\n\n    return ERC1155_BATCH_RECEIVED_VALUE;\n  }\n\n  /**\n   * @notice Return the Meta-ERC20 token ID for the given ERC-20 token address\n   * @param _token ERC-20 token address to get the corresponding Meta-ERC20 token ID\n   * @return tokenID Meta-ERC20 token ID\n   */\n  function getTokenID(address _token) public view returns (uint256 tokenID) {\n    tokenID = addressToID[_token];\n    require(tokenID != 0, "MetaERC20Wrapper#getTokenID: UNREGISTERED_TOKEN");\n    return tokenID;\n  }\n\n  /**\n   * @notice Return the ERC-20 token address for the given Meta-ERC20 token ID\n   * @param _id Meta-ERC20 token ID to get the corresponding ERC-20 token address\n   * @return token ERC-20 token address\n   */\n  function getIdAddress(uint256 _id) public view returns (address token) {\n    token = IDtoAddress[_id];\n    require(token != address(0x0), "MetaERC20Wrapper#getIdAddress: UNREGISTERED_TOKEN");\n    return token;\n  }\n\n  /**\n   * @notice Returns number of tokens currently registered\n   */\n  function getNTokens() external view returns (uint256) {\n    return nTokens;\n  }\n\n\n\n  /***********************************|\n  |          Helper Functions         |\n  |__________________________________*/\n\n  /**\n    * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\n    * function returned 0 bytes or 32 bytes that are not all-zero.\n    * Code taken from: https://github.com/dydxprotocol/solo/blob/10baf8e4c3fb9db4d0919043d3e6fdd6ba834046/contracts/protocol/lib/Token.sol\n    */\n  function checkSuccess()\n    private pure\n    returns (bool)\n  {\n    uint256 returnValue = 0;\n\n    /* solium-disable-next-line security/no-inline-assembly */\n    assembly {\n      // check number of bytes returned from last function call\n      switch returndatasize()\n\n        // no bytes returned: assume success\n        case 0x0 {\n          returnValue := 1\n        }\n\n        // 32 bytes returned: check if non-zero\n        case 0x20 {\n          // copy 32 bytes into scratch space\n          returndatacopy(0x0, 0x0, 0x20)\n\n          // load those bytes into returnValue\n          returnValue := mload(0x0)\n        }\n\n        // not sure what was returned: dont mark as success\n        default { }\n      \n    }\n\n    return returnValue != 0;\n  }\n\n  /**\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n   *      This function MUST NOT consume more than 5,000 gas.\n   * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\n   */\n  function supportsInterface(bytes4 interfaceID) public override pure returns (bool) {\n    return  interfaceID == type(IERC165).interfaceId ||\n      interfaceID == type(IERC1155).interfaceId || \n      interfaceID == type(IERC1155TokenReceiver).interfaceId;        \n  }\n\n}'
      },
      '@0xsequence/erc-1155/contracts/interfaces/IERC20.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n  function transfer(address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function allowance(address owner, address spender) external view returns (uint256);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n'
      },
      '@0xsequence/erc-1155/contracts/tokens/ERC1155/ERC1155Meta.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport "./ERC1155.sol";\nimport "../../interfaces/IERC20.sol";\nimport "../../interfaces/IERC1155.sol";\nimport "../../utils/LibBytes.sol";\nimport "../../utils/SignatureValidator.sol";\n\n\n/**\n * @dev ERC-1155 with native metatransaction methods. These additional functions allow users\n *      to presign function calls and allow third parties to execute these on their behalf\n */\ncontract ERC1155Meta is ERC1155, SignatureValidator {\n  using LibBytes for bytes;\n\n  /***********************************|\n  |       Variables and Structs       |\n  |__________________________________*/\n\n  /**\n   * Gas Receipt\n   *   feeTokenData : (bool, address, ?unit256)\n   *     1st element should be the address of the token\n   *     2nd argument (if ERC-1155) should be the ID of the token\n   *     Last element should be a 0x0 if ERC-20 and 0x1 for ERC-1155\n   */\n  struct GasReceipt {\n    uint256 gasFee;           // Fixed cost for the tx\n    uint256 gasLimitCallback; // Maximum amount of gas the callback in transfer functions can use\n    address feeRecipient;     // Address to send payment to\n    bytes feeTokenData;       // Data for token to pay for gas\n  }\n\n  // Which token standard is used to pay gas fee\n  enum FeeTokenType {\n    ERC1155,    // 0x00, ERC-1155 token - DEFAULT\n    ERC20,      // 0x01, ERC-20 token\n    NTypes      // 0x02, number of signature types. Always leave at end.\n  }\n\n  // Signature nonce per address\n  mapping (address => uint256) internal nonces;\n\n\n  /***********************************|\n  |               Events              |\n  |__________________________________*/\n\n  event NonceChange(address indexed signer, uint256 newNonce);\n\n\n  /****************************************|\n  |     Public Meta Transfer Functions     |\n  |_______________________________________*/\n\n  /**\n   * @notice Allows anyone with a valid signature to transfer _amount amount of a token _id on the bahalf of _from\n   * @param _from     Source address\n   * @param _to       Target address\n   * @param _id       ID of the token type\n   * @param _amount   Transfered amount\n   * @param _isGasFee Whether gas is reimbursed to executor or not\n   * @param _data     Encodes a meta transfer indicator, signature, gas payment receipt and extra transfer data\n   *   _data should be encoded as (\n   *   (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType),\n   *   (GasReceipt g, ?bytes transferData)\n   * )\n   *   i.e. high level encoding should be (bytes, bytes), where the latter bytes array is a nested bytes array\n   */\n  function metaSafeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _id,\n    uint256 _amount,\n    bool _isGasFee,\n    bytes memory _data)\n    public\n  {\n    require(_to != address(0), "ERC1155Meta#metaSafeTransferFrom: INVALID_RECIPIENT");\n\n    // Initializing\n    bytes memory transferData;\n    GasReceipt memory gasReceipt;\n\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _from,\n      _data,\n      abi.encode(\n        META_TX_TYPEHASH,\n        _from, // Address as uint256\n        _to,   // Address as uint256\n        _id,\n        _amount,\n        _isGasFee ? uint256(1) : uint256(0)  // Boolean as uint256\n      )\n    );\n\n    // Transfer asset\n    _safeTransferFrom(_from, _to, _id, _amount);\n\n    // If Gas is being reimbursed\n    if (_isGasFee) {\n      (gasReceipt, transferData) = abi.decode(signedData, (GasReceipt, bytes));\n\n      // We need to somewhat protect relayers against gas griefing attacks in recipient contract.\n      // Hence we only pass the gasLimit to the recipient such that the relayer knows the griefing\n      // limit. Nothing can prevent the receiver to revert the transaction as close to the gasLimit as\n      // possible, but the relayer can now only accept meta-transaction gasLimit within a certain range.\n      _callonERC1155Received(_from, _to, _id, _amount, gasReceipt.gasLimitCallback, transferData);\n\n      // Transfer gas cost\n      _transferGasFee(_from, gasReceipt);\n\n    } else {\n      _callonERC1155Received(_from, _to, _id, _amount, gasleft(), signedData);\n    }\n  }\n\n  /**\n   * @notice Allows anyone with a valid signature to transfer multiple types of tokens on the bahalf of _from\n   * @param _from     Source addresses\n   * @param _to       Target addresses\n   * @param _ids      IDs of each token type\n   * @param _amounts  Transfer amounts per token type\n   * @param _isGasFee Whether gas is reimbursed to executor or not\n   * @param _data     Encodes a meta transfer indicator, signature, gas payment receipt and extra transfer data\n   *   _data should be encoded as (\n   *   (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType),\n   *   (GasReceipt g, ?bytes transferData)\n   * )\n   *   i.e. high level encoding should be (bytes, bytes), where the latter bytes array is a nested bytes array\n   */\n  function metaSafeBatchTransferFrom(\n    address _from,\n    address _to,\n    uint256[] memory _ids,\n    uint256[] memory _amounts,\n    bool _isGasFee,\n    bytes memory _data)\n    public\n  {\n    require(_to != address(0), "ERC1155Meta#metaSafeBatchTransferFrom: INVALID_RECIPIENT");\n\n    // Initializing\n    bytes memory transferData;\n    GasReceipt memory gasReceipt;\n\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _from,\n      _data,\n      abi.encode(\n        META_BATCH_TX_TYPEHASH,\n        _from, // Address as uint256\n        _to,   // Address as uint256\n        keccak256(abi.encodePacked(_ids)),\n        keccak256(abi.encodePacked(_amounts)),\n        _isGasFee ? uint256(1) : uint256(0)  // Boolean as uint256\n      )\n    );\n\n    // Transfer assets\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n\n    // If gas fee being reimbursed\n    if (_isGasFee) {\n      (gasReceipt, transferData) = abi.decode(signedData, (GasReceipt, bytes));\n\n      // We need to somewhat protect relayers against gas griefing attacks in recipient contract.\n      // Hence we only pass the gasLimit to the recipient such that the relayer knows the griefing\n      // limit. Nothing can prevent the receiver to revert the transaction as close to the gasLimit as\n      // possible, but the relayer can now only accept meta-transaction gasLimit within a certain range.\n      _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasReceipt.gasLimitCallback, transferData);\n\n      // Handle gas reimbursement\n      _transferGasFee(_from, gasReceipt);\n\n    } else {\n      _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasleft(), signedData);\n    }\n  }\n\n\n  /***********************************|\n  |         Operator Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Approve the passed address to spend on behalf of _from if valid signature is provided\n   * @param _owner     Address that wants to set operator status  _spender\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   * @param _isGasFee  Whether gas will be reimbursed or not, with vlid signature\n   * @param _data      Encodes signature and gas payment receipt\n   *   _data should be encoded as (\n   *     (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType),\n   *     (GasReceipt g)\n   *   )\n   *   i.e. high level encoding should be (bytes, bytes), where the latter bytes array is a nested bytes array\n   */\n  function metaSetApprovalForAll(\n    address _owner,\n    address _operator,\n    bool _approved,\n    bool _isGasFee,\n    bytes memory _data)\n    public\n  {\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _owner,\n      _data,\n      abi.encode(\n        META_APPROVAL_TYPEHASH,\n        _owner,                              // Address as uint256\n        _operator,                           // Address as uint256\n        _approved ? uint256(1) : uint256(0), // Boolean as uint256\n        _isGasFee ? uint256(1) : uint256(0)  // Boolean as uint256\n      )\n    );\n\n    // Update operator status\n    operators[_owner][_operator] = _approved;\n\n    // Emit event\n    emit ApprovalForAll(_owner, _operator, _approved);\n\n    // Handle gas reimbursement\n    if (_isGasFee) {\n      GasReceipt memory gasReceipt = abi.decode(signedData, (GasReceipt));\n      _transferGasFee(_owner, gasReceipt);\n    }\n  }\n\n\n  /****************************************|\n  |      Signature Validation Functions     |\n  |_______________________________________*/\n\n  // keccak256(\n  //   "metaSafeTransferFrom(address,address,uint256,uint256,bool,bytes)"\n  // );\n  bytes32 internal constant META_TX_TYPEHASH = 0xce0b514b3931bdbe4d5d44e4f035afe7113767b7db71949271f6a62d9c60f558;\n\n  // keccak256(\n  //   "metaSafeBatchTransferFrom(address,address,uint256[],uint256[],bool,bytes)"\n  // );\n  bytes32 internal constant META_BATCH_TX_TYPEHASH = 0xa3d4926e8cf8fe8e020cd29f514c256bc2eec62aa2337e415f1a33a4828af5a0;\n\n  // keccak256(\n  //   "metaSetApprovalForAll(address,address,bool,bool,bytes)"\n  // );\n  bytes32 internal constant META_APPROVAL_TYPEHASH = 0xf5d4c820494c8595de274c7ff619bead38aac4fbc3d143b5bf956aa4b84fa524;\n\n  /**\n   * @notice Verifies signatures for this contract\n   * @param _signer     Address of signer\n   * @param _sigData    Encodes signature, gas payment receipt and transfer data (if any)\n   * @param _encMembers Encoded EIP-712 type members (except nonce and _data), all need to be 32 bytes size\n   * @dev _data should be encoded as (\n   *   (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType),\n   *   (GasReceipt g, ?bytes transferData)\n   * )\n   *   i.e. high level encoding should be (bytes, bytes), where the latter bytes array is a nested bytes array\n   * @dev A valid nonce is a nonce that is within 100 value from the current nonce\n   */\n  function _signatureValidation(\n    address _signer,\n    bytes memory _sigData,\n    bytes memory _encMembers)\n    internal returns (bytes memory signedData)\n  {\n    bytes memory sig;\n\n    // Get signature and data to sign\n    (sig, signedData) = abi.decode(_sigData, (bytes, bytes));\n\n    // Get current nonce and nonce used for signature\n    uint256 currentNonce = nonces[_signer];        // Lowest valid nonce for signer\n    uint256 nonce = uint256(sig.readBytes32(65));  // Nonce passed in the signature object\n\n    // Verify if nonce is valid\n    require(\n      (nonce >= currentNonce) && (nonce < (currentNonce + 100)),\n      "ERC1155Meta#_signatureValidation: INVALID_NONCE"\n    );\n\n    // Take hash of bytes arrays\n    bytes32 hash = hashEIP712Message(keccak256(abi.encodePacked(_encMembers, nonce, keccak256(signedData))));\n\n    // Complete data to pass to signer verifier\n    bytes memory fullData = abi.encodePacked(_encMembers, nonce, signedData);\n\n    //Update signature nonce\n    nonces[_signer] = nonce + 1;\n    emit NonceChange(_signer, nonce + 1);\n\n    // Verify if _from is the signer\n    require(isValidSignature(_signer, hash, fullData, sig), "ERC1155Meta#_signatureValidation: INVALID_SIGNATURE");\n    return signedData;\n  }\n\n  /**\n   * @notice Returns the current nonce associated with a given address\n   * @param _signer Address to query signature nonce for\n   */\n  function getNonce(address _signer)\n    public view returns (uint256 nonce)\n  {\n    return nonces[_signer];\n  }\n\n\n  /***********************************|\n  |    Gas Reimbursement Functions    |\n  |__________________________________*/\n\n  /**\n   * @notice Will reimburse tx.origin or fee recipient for the gas spent execution a transaction\n   *         Can reimbuse in any ERC-20 or ERC-1155 token\n   * @param _from  Address from which the payment will be made from\n   * @param _g     GasReceipt object that contains gas reimbursement information\n   */\n  function _transferGasFee(address _from, GasReceipt memory _g)\n      internal\n  {\n    // Pop last byte to get token fee type\n    uint8 feeTokenTypeRaw = uint8(_g.feeTokenData.popLastByte());\n\n    // Ensure valid fee token type\n    require(\n      feeTokenTypeRaw < uint8(FeeTokenType.NTypes),\n      "ERC1155Meta#_transferGasFee: UNSUPPORTED_TOKEN"\n    );\n\n    // Convert to FeeTokenType corresponding value\n    FeeTokenType feeTokenType = FeeTokenType(feeTokenTypeRaw);\n\n    // Declarations\n    address tokenAddress;\n    address feeRecipient;\n    uint256 tokenID;\n    uint256 fee = _g.gasFee;\n\n    // If receiver is 0x0, then anyone can claim, otherwise, refund addresse provided\n    feeRecipient = _g.feeRecipient == address(0) ? msg.sender : _g.feeRecipient;\n\n    // Fee token is ERC1155\n    if (feeTokenType == FeeTokenType.ERC1155) {\n      (tokenAddress, tokenID) = abi.decode(_g.feeTokenData, (address, uint256));\n\n      // Fee is paid from this ERC1155 contract\n      if (tokenAddress == address(this)) {\n        _safeTransferFrom(_from, feeRecipient, tokenID, fee);\n\n        // No need to protect against griefing since recipient (if contract) is most likely owned by the relayer\n        _callonERC1155Received(_from, feeRecipient, tokenID, gasleft(), fee, "");\n\n      // Fee is paid from another ERC-1155 contract\n      } else {\n        IERC1155(tokenAddress).safeTransferFrom(_from, feeRecipient, tokenID, fee, "");\n      }\n\n    // Fee token is ERC20\n    } else {\n      tokenAddress = abi.decode(_g.feeTokenData, (address));\n      require(\n        IERC20(tokenAddress).transferFrom(_from, feeRecipient, fee),\n        "ERC1155Meta#_transferGasFee: ERC20_TRANSFER_FAILED"\n      );\n    }\n  }\n}\n'
      },
      '@0xsequence/erc-1155/contracts/utils/LibBytes.sol': {
        content:
          '/*\n  Copyright 2018 ZeroEx Intl.\n  Licensed under the Apache License, Version 2.0 (the "License");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n  http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an "AS IS" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n  This is a truncated version of the original LibBytes.sol library from ZeroEx.\n*/\n\npragma solidity 0.7.4;\n\n\nlibrary LibBytes {\n  using LibBytes for bytes;\n\n  /***********************************|\n  |        Pop Bytes Functions        |\n  |__________________________________*/\n\n  /**\n   * @dev Pops the last byte off of a byte array by modifying its length.\n   * @param b Byte array that will be modified.\n   * @return result The byte that was popped off.\n   */\n  function popLastByte(bytes memory b)\n    internal\n    pure\n    returns (bytes1 result)\n  {\n    require(\n      b.length > 0,\n      "LibBytes#popLastByte: GREATER_THAN_ZERO_LENGTH_REQUIRED"\n    );\n\n    // Store last byte.\n    result = b[b.length - 1];\n\n    assembly {\n      // Decrement length of byte array.\n      let newLen := sub(mload(b), 1)\n      mstore(b, newLen)\n    }\n    return result;\n  }\n\n\n  /***********************************|\n  |        Read Bytes Functions       |\n  |__________________________________*/\n\n  /**\n   * @dev Reads a bytes32 value from a position in a byte array.\n   * @param b Byte array containing a bytes32 value.\n   * @param index Index in byte array of bytes32 value.\n   * @return result bytes32 value from byte array.\n   */\n  function readBytes32(\n    bytes memory b,\n    uint256 index\n  )\n    internal\n    pure\n    returns (bytes32 result)\n  {\n    require(\n      b.length >= index + 32,\n      "LibBytes#readBytes32: GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED"\n    );\n\n    // Arrays are prefixed by a 256 bit length parameter\n    index += 32;\n\n    // Read the bytes32 from array memory\n    assembly {\n      result := mload(add(b, index))\n    }\n    return result;\n  }\n}'
      },
      '@0xsequence/erc-1155/contracts/utils/SignatureValidator.sol': {
        content:
          'pragma solidity 0.7.4;\n\nimport "../interfaces/IERC1271Wallet.sol";\nimport "./LibBytes.sol";\nimport "./LibEIP712.sol";\n\n\n/**\n * @dev Contains logic for signature validation.\n * Signatures from wallet contracts assume ERC-1271 support (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md)\n * Notes: Methods are strongly inspired by contracts in https://github.com/0xProject/0x-monorepo/blob/development/\n */\ncontract SignatureValidator is LibEIP712 {\n  using LibBytes for bytes;\n\n  /***********************************|\n  |             Variables             |\n  |__________________________________*/\n\n  // bytes4(keccak256("isValidSignature(bytes,bytes)"))\n  bytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\n\n  // bytes4(keccak256("isValidSignature(bytes32,bytes)"))\n  bytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\n\n  // Allowed signature types.\n  enum SignatureType {\n    Illegal,         // 0x00, default value\n    EIP712,          // 0x01\n    EthSign,         // 0x02\n    WalletBytes,     // 0x03 To call isValidSignature(bytes, bytes) on wallet contract\n    WalletBytes32,   // 0x04 To call isValidSignature(bytes32, bytes) on wallet contract\n    NSignatureTypes  // 0x05, number of signature types. Always leave at end.\n  }\n\n\n  /***********************************|\n  |        Signature Functions        |\n  |__________________________________*/\n\n  /**\n   * @dev Verifies that a hash has been signed by the given signer.\n   * @param _signerAddress  Address that should have signed the given hash.\n   * @param _hash           Hash of the EIP-712 encoded data\n   * @param _data           Full EIP-712 data structure that was hashed and signed\n   * @param _sig            Proof that the hash has been signed by signer.\n   *      For non wallet signatures, _sig is expected to be an array tightly encoded as\n   *      (bytes32 r, bytes32 s, uint8 v, uint256 nonce, SignatureType sigType)\n   * @return isValid True if the address recovered from the provided signature matches the input signer address.\n   */\n  function isValidSignature(\n    address _signerAddress,\n    bytes32 _hash,\n    bytes memory _data,\n    bytes memory _sig\n  )\n    public\n    view\n    returns (bool isValid)\n  {\n    require(\n      _sig.length > 0,\n      "SignatureValidator#isValidSignature: LENGTH_GREATER_THAN_0_REQUIRED"\n    );\n\n    require(\n      _signerAddress != address(0x0),\n      "SignatureValidator#isValidSignature: INVALID_SIGNER"\n    );\n\n    // Pop last byte off of signature byte array.\n    uint8 signatureTypeRaw = uint8(_sig.popLastByte());\n\n    // Ensure signature is supported\n    require(\n      signatureTypeRaw < uint8(SignatureType.NSignatureTypes),\n      "SignatureValidator#isValidSignature: UNSUPPORTED_SIGNATURE"\n    );\n\n    // Extract signature type\n    SignatureType signatureType = SignatureType(signatureTypeRaw);\n\n    // Variables are not scoped in Solidity.\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n    address recovered;\n\n    // Always illegal signature.\n    // This is always an implicit option since a signer can create a\n    // signature array with invalid type or length. We may as well make\n    // it an explicit option. This aids testing and analysis. It is\n    // also the initialization value for the enum type.\n    if (signatureType == SignatureType.Illegal) {\n      revert("SignatureValidator#isValidSignature: ILLEGAL_SIGNATURE");\n\n\n    // Signature using EIP712\n    } else if (signatureType == SignatureType.EIP712) {\n      require(\n        _sig.length == 97,\n        "SignatureValidator#isValidSignature: LENGTH_97_REQUIRED"\n      );\n      r = _sig.readBytes32(0);\n      s = _sig.readBytes32(32);\n      v = uint8(_sig[64]);\n      recovered = ecrecover(_hash, v, r, s);\n      isValid = _signerAddress == recovered;\n      return isValid;\n\n\n    // Signed using web3.eth_sign() or Ethers wallet.signMessage()\n    } else if (signatureType == SignatureType.EthSign) {\n      require(\n        _sig.length == 97,\n        "SignatureValidator#isValidSignature: LENGTH_97_REQUIRED"\n      );\n      r = _sig.readBytes32(0);\n      s = _sig.readBytes32(32);\n      v = uint8(_sig[64]);\n      recovered = ecrecover(\n        keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _hash)),\n        v,\n        r,\n        s\n      );\n      isValid = _signerAddress == recovered;\n      return isValid;\n\n\n    // Signature verified by wallet contract with data validation.\n    } else if (signatureType == SignatureType.WalletBytes) {\n      isValid = ERC1271_MAGICVALUE == IERC1271Wallet(_signerAddress).isValidSignature(_data, _sig);\n      return isValid;\n\n\n    // Signature verified by wallet contract without data validation.\n    } else if (signatureType == SignatureType.WalletBytes32) {\n      isValid = ERC1271_MAGICVALUE_BYTES32 == IERC1271Wallet(_signerAddress).isValidSignature(_hash, _sig);\n      return isValid;\n    }\n\n    // Anything else is illegal (We do not return false because\n    // the signature may actually be valid, just not in a format\n    // that we currently support. In this case returning false\n    // may lead the caller to incorrectly believe that the\n    // signature was invalid.)\n    revert("SignatureValidator#isValidSignature: UNSUPPORTED_SIGNATURE");\n  }\n}\n'
      },
      '@0xsequence/erc-1155/contracts/interfaces/IERC1271Wallet.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\n\ninterface  IERC1271Wallet {\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided data\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided data\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256("isValidSignature(bytes,bytes)")\n   *   > This function MAY modify Ethereum\'s state\n   * @param _data       Arbitrary length data signed on the behalf of address(this)\n   * @param _signature  Signature byte array associated with _data\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   *\n   */\n  function isValidSignature(\n    bytes calldata _data,\n    bytes calldata _signature)\n    external\n    view\n    returns (bytes4 magicValue);\n\n  /**\n   * @notice Verifies whether the provided signature is valid with respect to the provided hash\n   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash\n   *   > The bytes4 magic value to return when signature is valid is 0x20c13b0b : bytes4(keccak256("isValidSignature(bytes,bytes)")\n   *   > This function MAY modify Ethereum\'s state\n   * @param _hash       keccak256 hash that was signed\n   * @param _signature  Signature byte array associated with _data\n   * @return magicValue Magic value 0x20c13b0b if the signature is valid and 0x0 otherwise\n   */\n  function isValidSignature(\n    bytes32 _hash,\n    bytes calldata _signature)\n    external\n    view\n    returns (bytes4 magicValue);\n}\n'
      },
      '@0xsequence/erc-1155/contracts/utils/LibEIP712.sol': {
        content:
          '/**\n * Copyright 2018 ZeroEx Intl.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *   http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.7.4;\n\n\ncontract LibEIP712 {\n\n  /***********************************|\n  |             Constants             |\n  |__________________________________*/\n\n  // keccak256(\n  //   "EIP712Domain(address verifyingContract)"\n  // );\n  bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d4749;\n\n  // EIP-191 Header\n  string constant internal EIP191_HEADER = "\\x19\\x01";\n\n  /***********************************|\n  |          Hashing Function         |\n  |__________________________________*/\n\n  /**\n   * @dev Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\n   * @param hashStruct The EIP712 hash struct.\n   * @return result EIP712 hash applied to this EIP712 Domain.\n   */\n  function hashEIP712Message(bytes32 hashStruct)\n      internal\n      view\n      returns (bytes32 result)\n  {\n    return keccak256(\n      abi.encodePacked(\n        EIP191_HEADER,\n        keccak256(\n          abi.encode(\n            DOMAIN_SEPARATOR_TYPEHASH,\n            address(this)\n          )\n        ),\n        hashStruct\n    ));\n  }\n}\n'
      },
      '@0xsequence/erc20-meta-token/contracts/interfaces/IERC20Wrapper.sol': {
        content:
          'pragma solidity 0.7.4;\n\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol";\n\ninterface IERC20Wrapper is IERC1155 {\n\n  /***********************************|\n  |         Deposit Functions         |\n  |__________________________________*/\n\n  /**\n   * Fallback function\n   * @dev Deposit ETH in this contract to receive wrapped ETH\n   */\n  receive () external payable;\n\n  /**\n   * @dev Deposit ERC20 tokens or ETH in this contract to receive wrapped ERC20s\n   * @param _token     The addess of the token to deposit in this contract\n   * @param _recipient Address that will receive the ERC-1155 tokens\n   * @param _value     The amount of token to deposit in this contract\n   * Note: Users must first approve this contract addres on the contract of the ERC20 to be deposited\n   */\n  function deposit(address _token, address _recipient, uint256 _value) external payable;\n\n\n  /***********************************|\n  |         Withdraw Functions        |\n  |__________________________________*/\n\n  /**\n   * @dev Withdraw wrapped ERC20 tokens in this contract to receive the original ERC20s or ETH\n   * @param _token The addess of the token to withdrww from this contract\n   * @param _to The address where the withdrawn tokens will go to\n   * @param _value The amount of tokens to withdraw\n   */\n  function withdraw(address _token, address payable _to, uint256 _value) external;\n\n\n  /***********************************|\n  |         Getter Functions          |\n  |__________________________________*/\n\n  /**\n   * @notice Return the Meta-ERC20 token ID for the given ERC-20 token address\n   * @param _token ERC-20 token address to get the corresponding Meta-ERC20 token ID\n   * @return tokenID Meta-ERC20 token ID\n   */\n  function getTokenID(address _token) external view returns (uint256 tokenID);\n\n  /**\n   * @notice Return the ERC-20 token address for the given Meta-ERC20 token ID\n   * @param _id Meta-ERC20 token ID to get the corresponding ERC-20 token address\n   * @return token ERC-20 token address\n   */\n  function getIdAddress(uint256 _id) external view returns (address token) ;\n\n  /**\n   * @notice Returns number of tokens currently registered\n   */\n  function getNTokens() external view;\n\n\n  /***********************************|\n  |        OnReceive Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Withdraw ERC-20 tokens when receiving their ERC-1155 counterpart\n   * @param _operator  The address which called the `safeTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _id        The id of the token being transferred\n   * @param _value     The amount of tokens being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n   */\n  function onERC1155Received(address _operator, address payable _from, uint256 _id, uint256 _value, bytes calldata _data ) external returns(bytes4);\n\n  /**\n   * @notice Withdraw ERC-20 tokens when receiving their ERC-1155 counterpart\n   * @param _operator  The address which called the `safeBatchTransferFrom` function\n   * @param _from      The address which previously owned the token\n   * @param _ids       An array containing ids of each token being transferred\n   * @param _values    An array containing amounts of each token being transferred\n   * @param _data      Additional data with no specified format\n   * @return           `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n   */\n  function onERC1155BatchReceived(address _operator, address payable _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);\n}'
      },
      'contracts/utils/WrapAndNiftyswap.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport "../interfaces/INiftyswapExchange.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC20.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol";\nimport "@0xsequence/erc20-meta-token/contracts/interfaces/IERC20Wrapper.sol";\n\n/**\n * @notice Will allow users to wrap their  ERC-20 into ERC-1155 tokens\n *         and pass their order to niftyswap. All funds will be returned\n *         to original owner and this contact should never hold any funds\n *         outside of a given wrap transaction.\n * @dev Hardcoding addresses for simplicity, easy to generalize if arguments\n *      are passed in functions, but adds a bit of complexity.\n */\ncontract WrapAndNiftyswap {\n\n  IERC20Wrapper immutable public tokenWrapper; // ERC-20 to ERC-1155 token wrapper contract\n  address immutable public exchange;           // Niftyswap exchange to use\n  address immutable public erc20;              // ERC-20 used in niftyswap exchange\n  address immutable public erc1155;            // ERC-1155 used in niftyswap exchange\n\n  uint256 immutable internal wrappedTokenID; // ID of the wrapped token\n  bool internal isInNiftyswap;               // Whether niftyswap is being called\n\n  /**\n   * @notice Registers contract addresses\n   */\n  constructor(\n    address payable _tokenWrapper,\n    address _exchange,\n    address _erc20,\n    address _erc1155\n  ) public {\n    require(\n      _tokenWrapper != address(0x0) &&\n      _exchange != address(0x0) &&\n      _erc20 != address(0x0) &&\n      _erc1155 != address(0x0),\n      "INVALID CONSTRUCTOR ARGUMENT"\n    );\n\n    tokenWrapper = IERC20Wrapper(_tokenWrapper);\n    exchange = _exchange;\n    erc20 = _erc20;\n    erc1155 = _erc1155;\n\n    // Approve wrapper contract for ERC-20\n    // NOTE: This could potentially fail in some extreme usage as it\'s only\n    // set once, but can easily redeploy this contract if that\'s the case.\n    IERC20(_erc20).approve(_tokenWrapper, 2**256-1);\n\n    // Store wrapped token ID\n    wrappedTokenID = IERC20Wrapper(_tokenWrapper).getTokenID(_erc20);\n  }\n\n  /**\n   * @notice Wrap ERC-20 to ERC-1155 and swap them\n   * @dev User must approve this contract for ERC-20 first\n   * @param _maxAmount       Maximum amount of ERC-20 user wants to spend\n   * @param _recipient       Address where to send tokens\n   * @param _niftyswapOrder  Encoded Niftyswap order passed in data field of safeTransferFrom()\n   */\n  function wrapAndSwap(\n    uint256 _maxAmount,\n    address _recipient,\n    bytes calldata _niftyswapOrder\n  ) external\n  {\n    // Decode niftyswap order\n    INiftyswapExchange.BuyTokensObj memory obj;\n    (, obj) = abi.decode(_niftyswapOrder, (bytes4, INiftyswapExchange.BuyTokensObj));\n    \n    // Force the recipient to not be set, otherwise wrapped token refunded will be \n    // sent to the user and we won\'t be able to unwrap it.\n    require(\n      obj.recipient == address(0x0) || obj.recipient == address(this), \n      "WrapAndNiftyswap#wrapAndSwap: ORDER RECIPIENT MUST BE THIS CONTRACT"\n    );\n\n    // Pull ERC-20 amount specified in order\n    IERC20(erc20).transferFrom(msg.sender, address(this), _maxAmount);\n\n    // Wrap ERC-20s\n    tokenWrapper.deposit(erc20, address(this), _maxAmount);\n\n    // Swap on Niftyswap\n    isInNiftyswap = true;\n    tokenWrapper.safeTransferFrom(address(this), exchange, wrappedTokenID, _maxAmount, _niftyswapOrder);\n    isInNiftyswap = false;\n\n    // Unwrap ERC-20 and send to receiver, if any received\n    uint256 wrapped_token_amount = tokenWrapper.balanceOf(address(this), wrappedTokenID);\n    if (wrapped_token_amount > 0) {\n      tokenWrapper.withdraw(erc20, payable(_recipient), wrapped_token_amount);\n    }\n\n    // Transfer tokens purchased\n    IERC1155(erc1155).safeBatchTransferFrom(address(this), _recipient, obj.tokensBoughtIDs, obj.tokensBoughtAmounts, "");\n  }\n\n  /**\n   * @notice Accepts only tokenWrapper tokens \n   * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n   */\n  function onERC1155Received(address, address, uint256, uint256, bytes calldata)\n    external returns(bytes4)\n  {\n    if (msg.sender != address(tokenWrapper)) {\n      revert("WrapAndNiftyswap#onERC1155Received: INVALID_ERC1155_RECEIVED");\n    }\n    return IERC1155TokenReceiver.onERC1155Received.selector;\n  }\n\n  /**\n   * @notice If receives tracked ERC-1155, it will send a sell order to niftyswap and unwrap received\n   *         wrapped token. The unwrapped tokens will be sent to the sender.\n   * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n   */\n  function onERC1155BatchReceived(\n    address, \n    address _from, \n    uint256[] calldata _ids, \n    uint256[] calldata _amounts, \n    bytes calldata _niftyswapOrder\n  )\n    external returns(bytes4)\n  { \n    // If coming from niftyswap or wrapped token, ignore\n    if (isInNiftyswap || msg.sender == address(tokenWrapper)){\n      return IERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    } else if (msg.sender != erc1155) {\n      revert("WrapAndNiftyswap#onERC1155BatchReceived: INVALID_ERC1155_RECEIVED");\n    }\n\n    // Decode transfer data\n    INiftyswapExchange.SellTokensObj memory obj;\n    (,obj) = abi.decode(_niftyswapOrder, (bytes4, INiftyswapExchange.SellTokensObj));\n\n    require(\n      obj.recipient == address(0x0) || obj.recipient == address(this), \n      "WrapAndNiftyswap#onERC1155BatchReceived: ORDER RECIPIENT MUST BE THIS CONTRACT"\n    );\n\n    // Swap on Niftyswap\n    isInNiftyswap = true;\n    IERC1155(msg.sender).safeBatchTransferFrom(address(this), exchange, _ids, _amounts, _niftyswapOrder);\n    isInNiftyswap = false;\n\n    // Send to recipient the unwrapped ERC-20, if any\n    uint256 wrapped_token_amount = tokenWrapper.balanceOf(address(this), wrappedTokenID);\n    if (wrapped_token_amount > 0) {\n      // Doing it in 2 calls so tx history is more consistent\n      tokenWrapper.withdraw(erc20, payable(address(this)), wrapped_token_amount);\n      IERC20(erc20).transfer(_from, wrapped_token_amount);\n    }\n\n    return IERC1155TokenReceiver.onERC1155BatchReceived.selector;\n  }\n}\n'
      },
      '@0xsequence/erc-1155/contracts/tokens/ERC1155PackedBalance/ERC1155PackedBalance.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\nimport "../../utils/SafeMath.sol";\nimport "../../interfaces/IERC1155TokenReceiver.sol";\nimport "../../interfaces/IERC1155.sol";\nimport "../../utils/Address.sol";\nimport "../../utils/ERC165.sol";\n\n\n/**\n * @dev Implementation of Multi-Token Standard contract. This implementation of the ERC-1155 standard\n *      utilizes the fact that balances of different token ids can be concatenated within individual\n *      uint256 storage slots. This allows the contract to batch transfer tokens more efficiently at\n *      the cost of limiting the maximum token balance each address can hold. This limit is\n *      2^IDS_BITS_SIZE, which can be adjusted below. In practice, using IDS_BITS_SIZE smaller than 16\n *      did not lead to major efficiency gains.\n */\ncontract ERC1155PackedBalance is IERC1155, ERC165 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  /***********************************|\n  |        Variables and Events       |\n  |__________________________________*/\n\n  // onReceive function signatures\n  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n\n  // Constants regarding bin sizes for balance packing\n  // IDS_BITS_SIZE **MUST** be a power of 2 (e.g. 2, 4, 8, 16, 32, 64, 128)\n  uint256 internal constant IDS_BITS_SIZE   = 32;                  // Max balance amount in bits per token ID\n  uint256 internal constant IDS_PER_UINT256 = 256 / IDS_BITS_SIZE; // Number of ids per uint256\n\n  // Operations for _updateIDBalance\n  enum Operations { Add, Sub }\n\n  // Token IDs balances ; balances[address][id] => balance (using array instead of mapping for efficiency)\n  mapping (address => mapping(uint256 => uint256)) internal balances;\n\n  // Operators\n  mapping (address => mapping(address => bool)) internal operators;\n\n\n  /***********************************|\n  |     Public Transfer Functions     |\n  |__________________________________*/\n\n  /**\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n   * @param _from    Source address\n   * @param _to      Target address\n   * @param _id      ID of the token type\n   * @param _amount  Transfered amount\n   * @param _data    Additional data with no specified format, sent in call to `_to`\n   */\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n    public override\n  {\n    // Requirements\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155PackedBalance#safeTransferFrom: INVALID_OPERATOR");\n    require(_to != address(0),"ERC1155PackedBalance#safeTransferFrom: INVALID_RECIPIENT");\n    // require(_amount <= balances);  Not necessary since checked with _viewUpdateBinValue() checks\n\n    _safeTransferFrom(_from, _to, _id, _amount);\n    _callonERC1155Received(_from, _to, _id, _amount, gasleft(), _data);\n  }\n\n  /**\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n   * @dev Arrays should be sorted so that all ids in a same storage slot are adjacent (more efficient)\n   * @param _from     Source addresses\n   * @param _to       Target addresses\n   * @param _ids      IDs of each token type\n   * @param _amounts  Transfer amounts per token type\n   * @param _data     Additional data with no specified format, sent in call to `_to`\n   */\n  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    public override\n  {\n    // Requirements\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155PackedBalance#safeBatchTransferFrom: INVALID_OPERATOR");\n    require(_to != address(0),"ERC1155PackedBalance#safeBatchTransferFrom: INVALID_RECIPIENT");\n\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, gasleft(), _data);\n  }\n\n\n  /***********************************|\n  |    Internal Transfer Functions    |\n  |__________________________________*/\n\n  /**\n   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n   * @param _from    Source address\n   * @param _to      Target address\n   * @param _id      ID of the token type\n   * @param _amount  Transfered amount\n   */\n  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\n    internal\n  {\n    //Update balances\n    _updateIDBalance(_from, _id, _amount, Operations.Sub); // Subtract amount from sender\n    _updateIDBalance(_to,   _id, _amount, Operations.Add); // Add amount to recipient\n\n    // Emit event\n    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n  }\n\n  /**\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\n   */\n  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, uint256 _gasLimit, bytes memory _data)\n    internal\n  {\n    // Check if recipient is contract\n    if (_to.isContract()) {\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received{gas:_gasLimit}(msg.sender, _from, _id, _amount, _data);\n      require(retval == ERC1155_RECEIVED_VALUE, "ERC1155PackedBalance#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE");\n    }\n  }\n\n  /**\n   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n   * @dev Arrays should be sorted so that all ids in a same storage slot are adjacent (more efficient)\n   * @param _from     Source addresses\n   * @param _to       Target addresses\n   * @param _ids      IDs of each token type\n   * @param _amounts  Transfer amounts per token type\n   */\n  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\n    internal\n  {\n    uint256 nTransfer = _ids.length; // Number of transfer to execute\n    require(nTransfer == _amounts.length, "ERC1155PackedBalance#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH");\n\n    if (_from != _to && nTransfer > 0) {\n      // Load first bin and index where the token ID balance exists\n      (uint256 bin, uint256 index) = getIDBinIndex(_ids[0]);\n\n      // Balance for current bin in memory (initialized with first transfer)\n      uint256 balFrom = _viewUpdateBinValue(balances[_from][bin], index, _amounts[0], Operations.Sub);\n      uint256 balTo = _viewUpdateBinValue(balances[_to][bin], index, _amounts[0], Operations.Add);\n\n      // Last bin updated\n      uint256 lastBin = bin;\n\n      for (uint256 i = 1; i < nTransfer; i++) {\n        (bin, index) = getIDBinIndex(_ids[i]);\n\n        // If new bin\n        if (bin != lastBin) {\n          // Update storage balance of previous bin\n          balances[_from][lastBin] = balFrom;\n          balances[_to][lastBin] = balTo;\n\n          balFrom = balances[_from][bin];\n          balTo = balances[_to][bin];\n\n          // Bin will be the most recent bin\n          lastBin = bin;\n        }\n\n        // Update memory balance\n        balFrom = _viewUpdateBinValue(balFrom, index, _amounts[i], Operations.Sub);\n        balTo = _viewUpdateBinValue(balTo, index, _amounts[i], Operations.Add);\n      }\n\n      // Update storage of the last bin visited\n      balances[_from][bin] = balFrom;\n      balances[_to][bin] = balTo;\n\n    // If transfer to self, just make sure all amounts are valid\n    } else {\n      for (uint256 i = 0; i < nTransfer; i++) {\n        require(balanceOf(_from, _ids[i]) >= _amounts[i], "ERC1155PackedBalance#_safeBatchTransferFrom: UNDERFLOW");\n      }\n    }\n\n    // Emit event\n    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n  }\n\n  /**\n   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\n   */\n  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, uint256 _gasLimit, bytes memory _data)\n    internal\n  {\n    // Pass data if recipient is contract\n    if (_to.isContract()) {\n      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived{gas: _gasLimit}(msg.sender, _from, _ids, _amounts, _data);\n      require(retval == ERC1155_BATCH_RECEIVED_VALUE, "ERC1155PackedBalance#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE");\n    }\n  }\n\n\n  /***********************************|\n  |         Operator Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n   * @param _operator  Address to add to the set of authorized operators\n   * @param _approved  True if the operator is approved, false to revoke approval\n   */\n  function setApprovalForAll(address _operator, bool _approved)\n    external override\n  {\n    // Update operator status\n    operators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }\n\n  /**\n   * @notice Queries the approval status of an operator for a given owner\n   * @param _owner     The owner of the Tokens\n   * @param _operator  Address of authorized operator\n   * @return isOperator True if the operator is approved, false if not\n   */\n  function isApprovedForAll(address _owner, address _operator)\n    public override view returns (bool isOperator)\n  {\n    return operators[_owner][_operator];\n  }\n\n\n  /***********************************|\n  |     Public Balance Functions      |\n  |__________________________________*/\n\n  /**\n   * @notice Get the balance of an account\'s Tokens\n   * @param _owner  The address of the token holder\n   * @param _id     ID of the Token\n   * @return The _owner\'s balance of the Token type requested\n   */\n  function balanceOf(address _owner, uint256 _id)\n    public override view returns (uint256)\n  {\n    uint256 bin;\n    uint256 index;\n\n    //Get bin and index of _id\n    (bin, index) = getIDBinIndex(_id);\n    return getValueInBin(balances[_owner][bin], index);\n  }\n\n  /**\n   * @notice Get the balance of multiple account/token pairs\n   * @param _owners The addresses of the token holders (sorted owners will lead to less gas usage)\n   * @param _ids    ID of the Tokens (sorted ids will lead to less gas usage\n   * @return The _owner\'s balance of the Token types requested (i.e. balance for each (owner, id) pair)\n    */\n  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\n    public override view returns (uint256[] memory)\n  {\n    uint256 n_owners = _owners.length;\n    require(n_owners == _ids.length, "ERC1155PackedBalance#balanceOfBatch: INVALID_ARRAY_LENGTH");\n\n    // First values\n    (uint256 bin, uint256 index) = getIDBinIndex(_ids[0]);\n    uint256 balance_bin = balances[_owners[0]][bin];\n    uint256 last_bin = bin;\n\n    // Initialization\n    uint256[] memory batchBalances = new uint256[](n_owners);\n    batchBalances[0] = getValueInBin(balance_bin, index);\n\n    // Iterate over each owner and token ID\n    for (uint256 i = 1; i < n_owners; i++) {\n      (bin, index) = getIDBinIndex(_ids[i]);\n\n      // SLOAD if bin changed for the same owner or if owner changed\n      if (bin != last_bin || _owners[i-1] != _owners[i]) {\n        balance_bin = balances[_owners[i]][bin];\n        last_bin = bin;\n      }\n\n      batchBalances[i] = getValueInBin(balance_bin, index);\n    }\n\n    return batchBalances;\n  }\n\n\n  /***********************************|\n  |      Packed Balance Functions     |\n  |__________________________________*/\n\n  /**\n   * @notice Update the balance of a id for a given address\n   * @param _address    Address to update id balance\n   * @param _id         Id to update balance of\n   * @param _amount     Amount to update the id balance\n   * @param _operation  Which operation to conduct :\n   *   Operations.Add: Add _amount to id balance\n   *   Operations.Sub: Substract _amount from id balance\n   */\n  function _updateIDBalance(address _address, uint256 _id, uint256 _amount, Operations _operation)\n    internal\n  {\n    uint256 bin;\n    uint256 index;\n\n    // Get bin and index of _id\n    (bin, index) = getIDBinIndex(_id);\n\n    // Update balance\n    balances[_address][bin] = _viewUpdateBinValue(balances[_address][bin], index, _amount, _operation);\n  }\n\n  /**\n   * @notice Update a value in _binValues\n   * @param _binValues  Uint256 containing values of size IDS_BITS_SIZE (the token balances)\n   * @param _index      Index of the value in the provided bin\n   * @param _amount     Amount to update the id balance\n   * @param _operation  Which operation to conduct :\n   *   Operations.Add: Add _amount to value in _binValues at _index\n   *   Operations.Sub: Substract _amount from value in _binValues at _index\n   */\n  function _viewUpdateBinValue(uint256 _binValues, uint256 _index, uint256 _amount, Operations _operation)\n    internal pure returns (uint256 newBinValues)\n  {\n    uint256 shift = IDS_BITS_SIZE * _index;\n    uint256 mask = (uint256(1) << IDS_BITS_SIZE) - 1;\n\n    if (_operation == Operations.Add) {\n      newBinValues = _binValues + (_amount << shift);\n      require(newBinValues >= _binValues, "ERC1155PackedBalance#_viewUpdateBinValue: OVERFLOW");\n      require(\n        ((_binValues >> shift) & mask) + _amount < 2**IDS_BITS_SIZE, // Checks that no other id changed\n        "ERC1155PackedBalance#_viewUpdateBinValue: OVERFLOW"\n      );\n\n    } else if (_operation == Operations.Sub) {\n      newBinValues = _binValues - (_amount << shift);\n      require(newBinValues <= _binValues, "ERC1155PackedBalance#_viewUpdateBinValue: UNDERFLOW");\n      require(\n        ((_binValues >> shift) & mask) >= _amount, // Checks that no other id changed\n        "ERC1155PackedBalance#_viewUpdateBinValue: UNDERFLOW"\n      );\n\n    } else {\n      revert("ERC1155PackedBalance#_viewUpdateBinValue: INVALID_BIN_WRITE_OPERATION"); // Bad operation\n    }\n\n    return newBinValues;\n  }\n\n  /**\n  * @notice Return the bin number and index within that bin where ID is\n  * @param _id  Token id\n  * @return bin index (Bin number, ID"s index within that bin)\n  */\n  function getIDBinIndex(uint256 _id)\n    public pure returns (uint256 bin, uint256 index)\n  {\n    bin = _id / IDS_PER_UINT256;\n    index = _id % IDS_PER_UINT256;\n    return (bin, index);\n  }\n\n  /**\n   * @notice Return amount in _binValues at position _index\n   * @param _binValues  uint256 containing the balances of IDS_PER_UINT256 ids\n   * @param _index      Index at which to retrieve amount\n   * @return amount at given _index in _bin\n   */\n  function getValueInBin(uint256 _binValues, uint256 _index)\n    public pure returns (uint256)\n  {\n    // require(_index < IDS_PER_UINT256) is not required since getIDBinIndex ensures `_index < IDS_PER_UINT256`\n\n    // Mask to retrieve data for a given binData\n    uint256 mask = (uint256(1) << IDS_BITS_SIZE) - 1;\n\n    // Shift amount\n    uint256 rightShift = IDS_BITS_SIZE * _index;\n    return (_binValues >> rightShift) & mask;\n  }\n\n\n  /***********************************|\n  |          ERC165 Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID` and\n   */\n  function supportsInterface(bytes4 _interfaceID) public override(ERC165, IERC165) virtual pure returns (bool) {\n    if (_interfaceID == type(IERC1155).interfaceId) {\n      return true;\n    }\n    return super.supportsInterface(_interfaceID);\n  }\n}\n'
      },
      '@0xsequence/erc-1155/contracts/tokens/ERC1155/ERC1155Metadata.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\nimport "../../interfaces/IERC1155Metadata.sol";\nimport "../../utils/ERC165.sol";\n\n\n/**\n * @notice Contract that handles metadata related methods.\n * @dev Methods assume a deterministic generation of URI based on token IDs.\n *      Methods also assume that URI uses hex representation of token IDs.\n */\ncontract ERC1155Metadata is IERC1155Metadata, ERC165 {\n  // URI\'s default URI prefix\n  string public baseURI;\n  string public name;\n\n  // set the initial name and base URI\n  constructor(string memory _name, string memory _baseURI) {\n    name = _name;\n    baseURI = _baseURI;\n  }\n\n  /***********************************|\n  |     Metadata Public Functions     |\n  |__________________________________*/\n\n  /**\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n   * @dev URIs are defined in RFC 3986.\n   *      URIs are assumed to be deterministically generated based on token ID\n   * @return URI string\n   */\n  function uri(uint256 _id) public override view returns (string memory) {\n    return string(abi.encodePacked(baseURI, _uint2str(_id), ".json"));\n  }\n\n\n  /***********************************|\n  |    Metadata Internal Functions    |\n  |__________________________________*/\n\n  /**\n   * @notice Will emit default URI log event for corresponding token _id\n   * @param _tokenIDs Array of IDs of tokens to log default URI\n   */\n  function _logURIs(uint256[] memory _tokenIDs) internal {\n    string memory baseURL = baseURI;\n    string memory tokenURI;\n\n    for (uint256 i = 0; i < _tokenIDs.length; i++) {\n      tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), ".json"));\n      emit URI(tokenURI, _tokenIDs[i]);\n    }\n  }\n\n  /**\n   * @notice Will update the base URL of token\'s URI\n   * @param _newBaseMetadataURI New base URL of token\'s URI\n   */\n  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\n    baseURI = _newBaseMetadataURI;\n  }\n\n  /**\n   * @notice Will update the name of the contract\n   * @param _newName New contract name\n   */\n  function _setContractName(string memory _newName) internal {\n    name = _newName;\n  }\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID` and\n   */\n  function supportsInterface(bytes4 _interfaceID) public override virtual pure returns (bool) {\n    if (_interfaceID == type(IERC1155Metadata).interfaceId) {\n      return true;\n    }\n    return super.supportsInterface(_interfaceID);\n  }\n\n\n  /***********************************|\n  |    Utility Internal Functions     |\n  |__________________________________*/\n\n  /**\n   * @notice Convert uint256 to string\n   * @param _i Unsigned integer to convert to string\n   */\n  function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return "0";\n    }\n\n    uint256 j = _i;\n    uint256 ii = _i;\n    uint256 len;\n\n    // Get number of bytes\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n\n    bytes memory bstr = new bytes(len);\n    uint256 k = len - 1;\n\n    // Get each individual ASCII\n    while (ii != 0) {\n      bstr[k--] = byte(uint8(48 + ii % 10));\n      ii /= 10;\n    }\n\n    // Convert to string\n    return string(bstr);\n  }\n}\n'
      },
      '@0xsequence/erc-1155/contracts/interfaces/IERC1155Metadata.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\n\ninterface IERC1155Metadata {\n\n  event URI(string _uri, uint256 indexed _id);\n\n  /****************************************|\n  |                Functions               |\n  |_______________________________________*/\n\n  /**\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n   * @dev URIs are defined in RFC 3986.\n   *      URIs are assumed to be deterministically generated based on token ID\n   *      Token IDs are assumed to be represented in their hex format in URIs\n   * @return URI string\n   */\n  function uri(uint256 _id) external view returns (string memory);\n}\n'
      },
      '@0xsequence/erc-1155/contracts/mocks/ERC1155MintBurnPackedBalanceMock.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport "../tokens/ERC1155PackedBalance/ERC1155MintBurnPackedBalance.sol";\nimport "../tokens/ERC1155/ERC1155Metadata.sol";\n\n\ncontract ERC1155MintBurnPackedBalanceMock is ERC1155MintBurnPackedBalance, ERC1155Metadata {\n\n  // set the initial name and base URI\n  constructor(string memory _name, string memory _baseURI) ERC1155Metadata(_name, _baseURI) {}\n\n  /***********************************|\n  |               ERC165              |\n  |__________________________________*/\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @dev Parent contract inheriting multiple contracts with supportsInterface()\n   *      need to implement an overriding supportsInterface() function specifying\n   *      all inheriting contracts that have a supportsInterface() function.\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(\n    bytes4 _interfaceID\n  ) public override(\n    ERC1155PackedBalance,\n    ERC1155Metadata\n  ) pure virtual returns (bool) {\n    return super.supportsInterface(_interfaceID);\n  }\n\n  /***********************************|\n  |         Minting Functions         |\n  |__________________________________*/\n\n  /**\n   * @dev Mint _value of tokens of a given id\n   * @param _to The address to mint tokens to.\n   * @param _id token id to mint\n   * @param _value The amount to be minted\n   * @param _data Data to be passed if receiver is contract\n   */\n  function mintMock(address _to, uint256 _id, uint256 _value, bytes memory _data)\n    public\n  {\n    _mint(_to, _id, _value, _data);\n  }\n\n  /**\n   * @dev Mint tokens for each ids in _ids\n   * @param _to The address to mint tokens to.\n   * @param _ids Array of ids to mint\n   * @param _values Array of amount of tokens to mint per id\n   * @param _data Data to be passed if receiver is contract\n   */\n  function batchMintMock(address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data)\n    public\n  {\n    _batchMint(_to, _ids, _values, _data);\n  }\n\n\n  /***********************************|\n  |         Burning Functions         |\n  |__________________________________*/\n\n  /**\n   * @dev burn _value of tokens of a given token id\n   * @param _from The address to burn tokens from.\n   * @param _id token id to burn\n   * @param _value The amount to be burned\n   */\n  function burnMock(address _from, uint256 _id, uint256 _value)\n    public\n  {\n    _burn(_from, _id, _value);\n  }\n\n  /**\n   * @dev burn _value of tokens of a given token id\n   * @param _from The address to burn tokens from.\n   * @param _ids Array of token ids to burn\n   * @param _values Array of the amount to be burned\n   */\n  function batchBurnMock(address _from, uint256[] memory _ids, uint256[] memory _values)\n    public\n  {\n    _batchBurn(_from, _ids, _values);\n  }\n\n\n  /***********************************|\n  |       Unsupported Functions       |\n  |__________________________________*/\n\n  fallback () external {\n    revert("ERC1155MetaMintBurnPackedBalanceMock: INVALID_METHOD");\n  }\n}\n'
      },
      '@0xsequence/erc-1155/contracts/tokens/ERC1155PackedBalance/ERC1155MintBurnPackedBalance.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\nimport "./ERC1155PackedBalance.sol";\n\n\n/**\n * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\n *      a parent contract to be executed as they are `internal` functions.\n */\ncontract ERC1155MintBurnPackedBalance is ERC1155PackedBalance {\n\n  /****************************************|\n  |            Minting Functions           |\n  |_______________________________________*/\n\n  /**\n   * @notice Mint _amount of tokens of a given id\n   * @param _to      The address to mint tokens to\n   * @param _id      Token id to mint\n   * @param _amount  The amount to be minted\n   * @param _data    Data to pass if receiver is contract\n   */\n  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\n    internal\n  {\n    //Add _amount\n    _updateIDBalance(_to,   _id, _amount, Operations.Add); // Add amount to recipient\n\n    // Emit event\n    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\n\n    // Calling onReceive method if recipient is contract\n    _callonERC1155Received(address(0x0), _to, _id, _amount, gasleft(), _data);\n  }\n\n  /**\n   * @notice Mint tokens for each (_ids[i], _amounts[i]) pair\n   * @param _to       The address to mint tokens to\n   * @param _ids      Array of ids to mint\n   * @param _amounts  Array of amount of tokens to mint per id\n   * @param _data    Data to pass if receiver is contract\n   */\n  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    internal\n  {\n    require(_ids.length == _amounts.length, "ERC1155MintBurnPackedBalance#_batchMint: INVALID_ARRAYS_LENGTH");\n\n    if (_ids.length > 0) {\n      // Load first bin and index where the token ID balance exists\n      (uint256 bin, uint256 index) = getIDBinIndex(_ids[0]);\n\n      // Balance for current bin in memory (initialized with first transfer)\n      uint256 balTo = _viewUpdateBinValue(balances[_to][bin], index, _amounts[0], Operations.Add);\n\n      // Number of transfer to execute\n      uint256 nTransfer = _ids.length;\n\n      // Last bin updated\n      uint256 lastBin = bin;\n\n      for (uint256 i = 1; i < nTransfer; i++) {\n        (bin, index) = getIDBinIndex(_ids[i]);\n\n        // If new bin\n        if (bin != lastBin) {\n          // Update storage balance of previous bin\n          balances[_to][lastBin] = balTo;\n          balTo = balances[_to][bin];\n\n          // Bin will be the most recent bin\n          lastBin = bin;\n        }\n\n        // Update memory balance\n        balTo = _viewUpdateBinValue(balTo, index, _amounts[i], Operations.Add);\n      }\n\n      // Update storage of the last bin visited\n      balances[_to][bin] = balTo;\n    }\n\n    // //Emit event\n    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\n\n    // Calling onReceive method if recipient is contract\n    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, gasleft(), _data);\n  }\n\n\n  /****************************************|\n  |            Burning Functions           |\n  |_______________________________________*/\n\n  /**\n   * @notice Burn _amount of tokens of a given token id\n   * @param _from    The address to burn tokens from\n   * @param _id      Token id to burn\n   * @param _amount  The amount to be burned\n   */\n  function _burn(address _from, uint256 _id, uint256 _amount)\n    internal\n  {\n    // Substract _amount\n    _updateIDBalance(_from, _id, _amount, Operations.Sub);\n\n    // Emit event\n    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\n  }\n\n  /**\n   * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\n   * @dev This batchBurn method does not implement the most efficient way of updating\n   *      balances to reduce the potential bug surface as this function is expected to\n   *      be less common than transfers. EIP-2200 makes this method significantly\n   *      more efficient already for packed balances.\n   * @param _from     The address to burn tokens from\n   * @param _ids      Array of token ids to burn\n   * @param _amounts  Array of the amount to be burned\n   */\n  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\n    internal\n  {\n    // Number of burning to execute\n    uint256 nBurn = _ids.length;\n    require(nBurn == _amounts.length, "ERC1155MintBurnPackedBalance#batchBurn: INVALID_ARRAYS_LENGTH");\n\n    // Executing all burning\n    for (uint256 i = 0; i < nBurn; i++) {\n      // Update storage balance\n      _updateIDBalance(_from,   _ids[i], _amounts[i], Operations.Sub); // Add amount to recipient\n    }\n\n    // Emit batch burn event\n    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\n  }\n}\n'
      },
      'contracts/mocks/ERC1155PackedBalanceMock.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport "@0xsequence/erc-1155/contracts/mocks/ERC1155MintBurnPackedBalanceMock.sol";\n\n\ncontract ERC1155PackedBalanceMock is ERC1155MintBurnPackedBalanceMock {\n  constructor() ERC1155MintBurnPackedBalanceMock("TestERC1155", "") {}\n}'
      },
      '@0xsequence/erc-1155/contracts/mocks/ERC1155MintBurnMock.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport "../tokens/ERC1155/ERC1155MintBurn.sol";\nimport "../tokens/ERC1155/ERC1155Metadata.sol";\n\n\ncontract ERC1155MintBurnMock is ERC1155MintBurn, ERC1155Metadata {\n\n  // set the initial name and base URI\n  constructor(string memory _name, string memory _baseURI) ERC1155Metadata(_name, _baseURI) {}\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @dev Parent contract inheriting multiple contracts with supportsInterface()\n   *      need to implement an overriding supportsInterface() function specifying\n   *      all inheriting contracts that have a supportsInterface() function.\n   * @param _interfaceID The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID`\n   */\n  function supportsInterface(\n    bytes4 _interfaceID\n  ) public override(\n    ERC1155,\n    ERC1155Metadata\n  ) pure virtual returns (bool) {\n    return super.supportsInterface(_interfaceID);\n  }\n\n  /***********************************|\n  |         Minting Functions         |\n  |__________________________________*/\n\n  /**\n   * @dev Mint _value of tokens of a given id\n   * @param _to The address to mint tokens to.\n   * @param _id token id to mint\n   * @param _value The amount to be minted\n   * @param _data Data to be passed if receiver is contract\n   */\n  function mintMock(address _to, uint256 _id, uint256 _value, bytes memory _data)\n    public\n  {\n    super._mint(_to, _id, _value, _data);\n  }\n\n  /**\n   * @dev Mint tokens for each ids in _ids\n   * @param _to The address to mint tokens to.\n   * @param _ids Array of ids to mint\n   * @param _values Array of amount of tokens to mint per id\n   * @param _data Data to be passed if receiver is contract\n   */\n  function batchMintMock(address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data)\n    public\n  {\n    super._batchMint(_to, _ids, _values, _data);\n  }\n\n\n  /***********************************|\n  |         Burning Functions         |\n  |__________________________________*/\n\n  /**\n   * @dev burn _value of tokens of a given token id\n   * @param _from The address to burn tokens from.\n   * @param _id token id to burn\n   * @param _value The amount to be burned\n   */\n  function burnMock(address _from, uint256 _id, uint256 _value)\n    public\n  {\n    super._burn(_from, _id, _value);\n  }\n\n  /**\n   * @dev burn _value of tokens of a given token id\n   * @param _from The address to burn tokens from.\n   * @param _ids Array of token ids to burn\n   * @param _values Array of the amount to be burned\n   */\n  function batchBurnMock(address _from, uint256[] memory _ids, uint256[] memory _values)\n    public\n  {\n    super._batchBurn(_from, _ids, _values);\n  }\n  \n  /***********************************|\n  |       Unsupported Functions       |\n  |__________________________________*/\n\n  fallback () virtual external {\n    revert("ERC1155MetaMintBurnMock: INVALID_METHOD");\n  }\n}\n'
      },
      'contracts/mocks/ERC1155RoyaltyMock.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport "@0xsequence/erc-1155/contracts/mocks/ERC1155MintBurnMock.sol";\nimport "../interfaces/IERC2981.sol";\n\n\ncontract ERC1155RoyaltyMock is ERC1155MintBurnMock {\n  constructor() ERC1155MintBurnMock("TestERC1155", "") {}\n\n  using SafeMath for uint256;\n  uint256 public royaltyFee;\n  address public royaltyRecipient;\n  uint256 public royaltyFee666;\n  address public royaltyRecipient666;\n\n\n  /** \n   * @notice Called with the sale price to determine how much royalty\n   *         is owed and to whom.\n   * @param _tokenId - the NFT asset queried for royalty information\n   * @param _salePrice - the sale price of the NFT asset specified by _tokenId\n   * @return receiver - address of who should be sent the royalty payment\n   * @return royaltyAmount - the royalty payment amount for _salePrice\n   */\n  function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount) {\n    if (_tokenId == 666) {\n      uint256 fee = _salePrice.mul(royaltyFee666).div(10000);\n      return (royaltyRecipient666, fee);\n    } else {\n      uint256 fee = _salePrice.mul(royaltyFee).div(10000);\n      return (royaltyRecipient, fee);\n    }\n  }\n\n  function setFee(uint256 _fee) public {\n    require(_fee < 10000, "FEE IS TOO HIGH");\n    royaltyFee = _fee;\n  }\n\n  function set666Fee(uint256 _fee) public {\n    require(_fee < 10000, "FEE IS TOO HIGH");\n    royaltyFee666 = _fee;\n  }\n\n  function setFeeRecipient(address _recipient) public {\n    royaltyRecipient = _recipient;\n  }\n\n  function set666FeeRecipient(address _recipient) public {\n    royaltyRecipient666 = _recipient;\n  }\n\n  bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param _interfaceID  The interface identifier, as specified in ERC-165\n   * @return `true` if the contract implements `_interfaceID` and\n   */\n  function supportsInterface(bytes4 _interfaceID) public override(ERC1155MintBurnMock) virtual pure returns (bool) {\n    // Should be 0x2a55205a\n    if (_interfaceID == _INTERFACE_ID_ERC2981) {\n      return true;\n    }\n    return super.supportsInterface(_interfaceID);\n  }\n}'
      },
      'contracts/interfaces/IERC2981.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC165.sol";\n\n/** \n * @dev Interface for the NFT Royalty Standard\n */\ninterface IERC2981 is IERC165 {\n  /** \n   * @notice Called with the sale price to determine how much royalty\n   *         is owed and to whom.\n   * @param _tokenId - the NFT asset queried for royalty information\n   * @param _salePrice - the sale price of the NFT asset specified by _tokenId\n   * @return receiver - address of who should be sent the royalty payment\n   * @return royaltyAmount - the royalty payment amount for _salePrice\n   */\n  function royaltyInfo(\n      uint256 _tokenId,\n      uint256 _salePrice\n  ) external view returns (\n      address receiver,\n      uint256 royaltyAmount\n  );\n}'
      },
      'contracts/exchange/NiftyswapExchange20.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport "../interfaces/INiftyswapExchange20.sol";\nimport "../utils/ReentrancyGuard.sol";\nimport "../utils/DelegatedOwnable.sol";\nimport "../interfaces/IERC2981.sol";\nimport "../interfaces/IERC1155Metadata.sol";\nimport "../interfaces/IDelegatedERC1155Metadata.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC20.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC165.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155.sol";\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC1155TokenReceiver.sol";\nimport "@0xsequence/erc-1155/contracts/tokens/ERC1155/ERC1155MintBurn.sol";\nimport "@uniswap/lib/contracts/libraries/TransferHelper.sol";\n\n/**\n * This Uniswap-like implementation supports ERC-1155 standard tokens\n * with an ERC-20 based token used as a currency instead of Ether.\n *\n * Liquidity tokens are also ERC-1155 tokens you can find the ERC-1155\n * implementation used here:\n *    https://github.com/horizon-games/multi-token-standard/tree/master/contracts/tokens/ERC1155\n *\n * @dev Like Uniswap, tokens with 0 decimals and low supply are susceptible to significant rounding\n *      errors when it comes to removing liquidity, possibly preventing them to be withdrawn without\n *      some collaboration between liquidity providers.\n * \n * @dev ERC-777 tokens may be vulnerable if used as currency in Niftyswap. Please review the code \n *      carefully before using it with ERC-777 tokens.\n */\ncontract NiftyswapExchange20 is ReentrancyGuard, ERC1155MintBurn, INiftyswapExchange20, IERC1155Metadata, DelegatedOwnable {\n  using SafeMath for uint256;\n\n  /***********************************|\n  |       Variables & Constants       |\n  |__________________________________*/\n\n  // Variables\n  IERC1155 internal immutable token;         // address of the ERC-1155 token contract\n  address internal immutable currency;       // address of the ERC-20 currency used for exchange\n  address internal immutable factory;        // address for the factory that created this contract\n  uint256 internal immutable FEE_MULTIPLIER; // multiplier that calculates the LP fee (1.0%)\n\n  // Royalty variables\n  bool internal immutable IS_ERC2981; // whether token contract supports ERC-2981\n  uint256 internal globalRoyaltyFee;        // global royalty fee multiplier if ERC2981 is not used\n  address internal globalRoyaltyRecipient;  // global royalty fee recipient if ERC2981 is not used\n\n  // Mapping variables\n  mapping(uint256 => uint256) internal totalSupplies;      // Liquidity pool token supply per Token id\n  mapping(uint256 => uint256) internal currencyReserves;   // currency Token reserve per Token id\n  mapping(address => uint256) internal royaltiesNumerator; // Mapping tracking how much royalties can be claimed per address\n\n  uint256 internal constant ROYALTIES_DENOMINATOR = 10000;\n  uint256 internal constant MAX_ROYALTY = ROYALTIES_DENOMINATOR / 4;\n\n  /***********************************|\n  |            Constructor           |\n  |__________________________________*/\n\n  /**\n   * @notice Create instance of exchange contract with respective token and currency token\n   * @dev If token supports ERC-2981, then royalty fee will be queried per token on the \n   *      token contract. Else royalty fee will need to be manually set by admin.\n   * @param _tokenAddr     The address of the ERC-1155 Token\n   * @param _currencyAddr  The address of the ERC-20 currency Token\n   * @param _currencyAddr  Address of the admin, which should be the same as the factory owner\n   * @param _lpFee    Fee that will go to LPs.\n   *                  Number between 0 and 1000, where 10 is 1.0% and 100 is 10%.\n   */\n  constructor(address _tokenAddr, address _currencyAddr, uint256 _lpFee) DelegatedOwnable(msg.sender) {\n    require(\n      _tokenAddr != address(0) && _currencyAddr != address(0),\n      "NE20#1" // NiftyswapExchange20#constructor:INVALID_INPUT\n    );\n    require(\n      _lpFee >= 0 && _lpFee <= 1000,  \n      "NE20#2" // NiftyswapExchange20#constructor:INVALID_LP_FEE\n    );\n\n    factory = msg.sender;\n    token = IERC1155(_tokenAddr);\n    currency = _currencyAddr;\n    FEE_MULTIPLIER = 1000 - _lpFee;\n\n    // If global royalty, lets check for ERC-2981 support\n    try IERC1155(_tokenAddr).supportsInterface(type(IERC2981).interfaceId) returns (bool supported) {\n      IS_ERC2981 = supported;\n    } catch {}\n  }\n\n  /***********************************|\n  |        Metadata Functions         |\n  |__________________________________*/\n\n  /**\n      @notice A distinct Uniform Resource Identifier (URI) for a given token.\n      @dev URIs are defined in RFC 3986.\n      The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".        \n      @return URI string\n  */\n  function uri(uint256 _id) external override view returns (string memory) {\n    return IDelegatedERC1155Metadata(factory).metadataProvider().uri(_id);\n  }\n\n  /***********************************|\n  |        Exchange Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\n   */\n  function _currencyToToken(\n    uint256[] memory _tokenIds,\n    uint256[] memory _tokensBoughtAmounts,\n    uint256 _maxCurrency,\n    uint256 _deadline,\n    address _recipient\n  )\n    internal nonReentrant() returns (uint256[] memory currencySold)\n  {\n    // Input validation\n    require(_deadline >= block.timestamp, "NE20#3"); // NiftyswapExchange20#_currencyToToken: DEADLINE_EXCEEDED\n\n    // Number of Token IDs to deposit\n    uint256 nTokens = _tokenIds.length;\n    uint256 totalRefundCurrency = _maxCurrency;\n\n    // Initialize variables\n    currencySold = new uint256[](nTokens); // Amount of currency tokens sold per ID\n\n    // Get token reserves\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\n\n    // Assumes the currency Tokens are already received by contract, but not\n    // the Tokens Ids\n\n    // Remove liquidity for each Token ID in _tokenIds\n    for (uint256 i = 0; i < nTokens; i++) {\n      // Store current id and amount from argument arrays\n      uint256 idBought = _tokenIds[i];\n      uint256 amountBought = _tokensBoughtAmounts[i];\n      uint256 tokenReserve = tokenReserves[i];\n\n      require(amountBought > 0, "NE20#4"); // NiftyswapExchange20#_currencyToToken: NULL_TOKENS_BOUGHT\n\n      // Load currency token and Token _id reserves\n      uint256 currencyReserve = currencyReserves[idBought];\n\n      // Get amount of currency tokens to send for purchase\n      // Neither reserves amount have been changed so far in this transaction, so\n      // no adjustment to the inputs is needed\n      uint256 currencyAmount = getBuyPrice(amountBought, currencyReserve, tokenReserve);\n\n      // If royalty, increase amount buyer will need to pay after LP fees were calculated\n      // Note: Royalty will be a bit higher since LF fees are added first\n      (address royaltyRecipient, uint256 royaltyAmount) = getRoyaltyInfo(idBought, currencyAmount);\n      if (royaltyAmount > 0) {\n        royaltiesNumerator[royaltyRecipient] = royaltiesNumerator[royaltyRecipient].add(royaltyAmount.mul(ROYALTIES_DENOMINATOR));\n      }\n\n      // Calculate currency token amount to refund (if any) where whatever is not used will be returned\n      // Will throw if total cost exceeds _maxCurrency\n      totalRefundCurrency = totalRefundCurrency.sub(currencyAmount).sub(royaltyAmount);\n\n      // Append Token id, Token id amount and currency token amount to tracking arrays\n      currencySold[i] = currencyAmount.add(royaltyAmount);\n\n      // Update individual currency reseve amount (royalty is not added to liquidity)\n      currencyReserves[idBought] = currencyReserve.add(currencyAmount);\n    }\n\n    // Send Tokens all tokens purchased\n    token.safeBatchTransferFrom(address(this), _recipient, _tokenIds, _tokensBoughtAmounts, "");\n    \n    // Refund currency token if any\n    if (totalRefundCurrency > 0) {\n      TransferHelper.safeTransfer(currency, _recipient, totalRefundCurrency);\n    }\n\n    return currencySold;\n  }\n\n  /**\n   * @dev Pricing function used for converting between currency token to Tokens.\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\n   * @return price Amount of currency tokens to send to Niftyswap.\n   */\n  function getBuyPrice(\n    uint256 _assetBoughtAmount,\n    uint256 _assetSoldReserve,\n    uint256 _assetBoughtReserve)\n    override public view returns (uint256 price)\n  {\n    // Reserves must not be empty\n    require(_assetSoldReserve > 0 && _assetBoughtReserve > 0, "NE20#5"); // NiftyswapExchange20#getBuyPrice: EMPTY_RESERVE\n\n    // Calculate price with fee\n    uint256 numerator = _assetSoldReserve.mul(_assetBoughtAmount).mul(1000);\n    uint256 denominator = (_assetBoughtReserve.sub(_assetBoughtAmount)).mul(FEE_MULTIPLIER);\n    (price, ) = divRound(numerator, denominator);\n    return price; // Will add 1 if rounding error\n  }\n\n  /**\n   * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\n   * @param _tokenId            Id ot token being sold\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\n   * @return price Amount of currency tokens to send to Niftyswap.\n   */\n  function getBuyPriceWithRoyalty(\n    uint256 _tokenId,\n    uint256 _assetBoughtAmount,\n    uint256 _assetSoldReserve,\n    uint256 _assetBoughtReserve)\n    override public view returns (uint256 price)\n  {\n    uint256 cost = getBuyPrice(_assetBoughtAmount, _assetSoldReserve, _assetBoughtReserve);\n    (, uint256 royaltyAmount) = getRoyaltyInfo(_tokenId, cost);\n    return cost.add(royaltyAmount);\n  }\n\n  /**\n   * @notice Convert Tokens _id to currency tokens and transfers Tokens to recipient.\n   * @dev User specifies EXACT Tokens _id sold and MINIMUM currency tokens received.\n   * @dev Assumes that all trades will be valid, or the whole tx will fail\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\n   * @param _tokenIds           Array of Token IDs that are sold\n   * @param _tokensSoldAmounts  Array of Amount of Tokens sold for each id in _tokenIds.\n   * @param _minCurrency        Minimum amount of currency tokens to receive\n   * @param _deadline           Timestamp after which this transaction will be reverted\n   * @param _recipient          The address that receives output currency tokens.\n   * @param _extraFeeRecipients  Array of addresses that will receive extra fee\n   * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\n   * @return currencyBought How much currency was actually purchased.\n   */\n  function _tokenToCurrency(\n    uint256[] memory _tokenIds,\n    uint256[] memory _tokensSoldAmounts,\n    uint256 _minCurrency,\n    uint256 _deadline,\n    address _recipient,\n    address[] memory _extraFeeRecipients,\n    uint256[] memory _extraFeeAmounts\n  )\n    internal nonReentrant() returns (uint256[] memory currencyBought)\n  {\n    // Number of Token IDs to deposit\n    uint256 nTokens = _tokenIds.length;\n\n    // Input validation\n    require(_deadline >= block.timestamp, "NE20#6"); // NiftyswapExchange20#_tokenToCurrency: DEADLINE_EXCEEDED\n\n    // Initialize variables\n    uint256 totalCurrency = 0; // Total amount of currency tokens to transfer\n    currencyBought = new uint256[](nTokens);\n\n    // Get token reserves\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\n\n    // Assumes the Tokens ids are already received by contract, but not\n    // the Tokens Ids. Will return cards not sold if invalid price.\n\n    // Remove liquidity for each Token ID in _tokenIds\n    for (uint256 i = 0; i < nTokens; i++) {\n      // Store current id and amount from argument arrays\n      uint256 idSold = _tokenIds[i];\n      uint256 amountSold = _tokensSoldAmounts[i];\n      uint256 tokenReserve = tokenReserves[i];\n\n      // If 0 tokens send for this ID, revert\n      require(amountSold > 0, "NE20#7"); // NiftyswapExchange20#_tokenToCurrency: NULL_TOKENS_SOLD\n\n      // Load currency token and Token _id reserves\n      uint256 currencyReserve = currencyReserves[idSold];\n\n      // Get amount of currency that will be received\n      // Need to sub amountSold because tokens already added in reserve, which would bias the calculation\n      // Don\'t need to add it for currencyReserve because the amount is added after this calculation\n      uint256 currencyAmount = getSellPrice(amountSold, tokenReserve.sub(amountSold), currencyReserve);\n\n      // If royalty, substract amount seller will receive after LP fees were calculated\n      // Note: Royalty will be a bit lower since LF fees are substracted first\n      (address royaltyRecipient, uint256 royaltyAmount) = getRoyaltyInfo(idSold, currencyAmount);\n      if (royaltyAmount > 0) {\n        royaltiesNumerator[royaltyRecipient] = royaltiesNumerator[royaltyRecipient].add(royaltyAmount.mul(ROYALTIES_DENOMINATOR));\n      }\n\n      // Increase total amount of currency to receive (minus royalty to pay)\n      totalCurrency = totalCurrency.add(currencyAmount.sub(royaltyAmount));\n\n      // Update individual currency reseve amount\n      currencyReserves[idSold] = currencyReserve.sub(currencyAmount);\n\n      // Append Token id, Token id amount and currency token amount to tracking arrays\n      currencyBought[i] = currencyAmount.sub(royaltyAmount);\n    }\n\n    // Set the extra fees aside to recipients after sale\n    for (uint256 i = 0; i < _extraFeeAmounts.length; i++) {\n      if (_extraFeeAmounts[i] > 0) {\n        totalCurrency = totalCurrency.sub(_extraFeeAmounts[i]);\n        royaltiesNumerator[_extraFeeRecipients[i]] = royaltiesNumerator[_extraFeeRecipients[i]].add(_extraFeeAmounts[i].mul(ROYALTIES_DENOMINATOR));\n      }\n    }\n\n    // If minCurrency is not met\n    require(totalCurrency >= _minCurrency, "NE20#8"); // NiftyswapExchange20#_tokenToCurrency: INSUFFICIENT_CURRENCY_AMOUNT\n\n    // Transfer currency here\n    TransferHelper.safeTransfer(currency, _recipient, totalCurrency);\n    return currencyBought;\n  }\n\n  /**\n   * @dev Pricing function used for converting Tokens to currency token.\n   * @param _assetSoldAmount    Amount of Tokens being sold.\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\n   * @return price Amount of currency tokens to receive from Niftyswap.\n   */\n  function getSellPrice(\n    uint256 _assetSoldAmount,\n    uint256 _assetSoldReserve,\n    uint256 _assetBoughtReserve)\n    override public view returns (uint256 price)\n  {\n    //Reserves must not be empty\n    require(_assetSoldReserve > 0 && _assetBoughtReserve > 0, "NE20#9"); // NiftyswapExchange20#getSellPrice: EMPTY_RESERVE\n\n    // Calculate amount to receive (with fee) before royalty\n    uint256 _assetSoldAmount_withFee = _assetSoldAmount.mul(FEE_MULTIPLIER);\n    uint256 numerator = _assetSoldAmount_withFee.mul(_assetBoughtReserve);\n    uint256 denominator = _assetSoldReserve.mul(1000).add(_assetSoldAmount_withFee);\n    return numerator / denominator; //Rounding errors will favor Niftyswap, so nothing to do\n  }\n\n  /**\n   * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\n   * @param _tokenId            Id ot token being sold\n   * @param _assetSoldAmount    Amount of Tokens being sold.\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\n   * @return price Amount of currency tokens to receive from Niftyswap.\n   */\n  function getSellPriceWithRoyalty(\n    uint256 _tokenId,\n    uint256 _assetSoldAmount,\n    uint256 _assetSoldReserve,\n    uint256 _assetBoughtReserve)\n    override public view returns (uint256 price)\n  {\n    uint256 sellAmount = getSellPrice(_assetSoldAmount, _assetSoldReserve, _assetBoughtReserve);\n    (, uint256 royaltyAmount) = getRoyaltyInfo(_tokenId, sellAmount);\n    return sellAmount.sub(royaltyAmount);\n  }\n\n  /***********************************|\n  |        Liquidity Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Deposit less than max currency tokens && exact Tokens (token ID) at current ratio to mint liquidity pool tokens.\n   * @dev min_liquidity does nothing when total liquidity pool token supply is 0.\n   * @dev Assumes that sender approved this contract on the currency\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\n   * @param _provider      Address that provides liquidity to the reserve\n   * @param _tokenIds      Array of Token IDs where liquidity is added\n   * @param _tokenAmounts  Array of amount of Tokens deposited corresponding to each ID provided in _tokenIds\n   * @param _maxCurrency   Array of maximum number of tokens deposited for each ID provided in _tokenIds.\n   *                       Deposits max amount if total liquidity pool token supply is 0.\n   * @param _deadline      Timestamp after which this transaction will be reverted\n   */\n  function _addLiquidity(\n    address _provider,\n    uint256[] memory _tokenIds,\n    uint256[] memory _tokenAmounts,\n    uint256[] memory _maxCurrency,\n    uint256 _deadline)\n    internal nonReentrant()\n  {\n    // Requirements\n    require(_deadline >= block.timestamp, "NE20#10"); // NiftyswapExchange20#_addLiquidity: DEADLINE_EXCEEDED\n\n    // Initialize variables\n    uint256 nTokens = _tokenIds.length; // Number of Token IDs to deposit\n    uint256 totalCurrency = 0;          // Total amount of currency tokens to transfer\n\n    // Initialize arrays\n    uint256[] memory liquiditiesToMint = new uint256[](nTokens);\n    uint256[] memory currencyAmounts = new uint256[](nTokens);\n\n    // Get token reserves\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\n\n    // Assumes tokens _ids are deposited already, but not currency tokens\n    // as this is calculated and executed below.\n\n    // Loop over all Token IDs to deposit\n    for (uint256 i = 0; i < nTokens; i ++) {\n      // Store current id and amount from argument arrays\n      uint256 tokenId = _tokenIds[i];\n      uint256 amount = _tokenAmounts[i];\n\n      // Check if input values are acceptable\n      require(_maxCurrency[i] > 0, "NE20#11"); // NiftyswapExchange20#_addLiquidity: NULL_MAX_CURRENCY\n      require(amount > 0, "NE20#12"); // NiftyswapExchange20#_addLiquidity: NULL_TOKENS_AMOUNT\n\n      // Current total liquidity calculated in currency token\n      uint256 totalLiquidity = totalSupplies[tokenId];\n\n      // When reserve for this token already exists\n      if (totalLiquidity > 0) {\n\n        // Load currency token and Token reserve\'s supply of Token id\n        uint256 currencyReserve = currencyReserves[tokenId]; // Amount not yet in reserve\n        uint256 tokenReserve = tokenReserves[i];\n\n        /**\n        * Amount of currency tokens to send to token id reserve:\n        * X/Y = dx/dy\n        * dx = X*dy/Y\n        * where\n        *   X:  currency total liquidity\n        *   Y:  Token _id total liquidity (before tokens were received)\n        *   dy: Amount of token _id deposited\n        *   dx: Amount of currency to deposit\n        *\n        * Adding .add(1) if rounding errors so to not favor users incorrectly\n        */\n        (uint256 currencyAmount, bool rounded) = divRound(amount.mul(currencyReserve), tokenReserve.sub(amount));\n        require(_maxCurrency[i] >= currencyAmount, "NE20#13"); // NiftyswapExchange20#_addLiquidity: MAX_CURRENCY_AMOUNT_EXCEEDED\n\n        // Update currency reserve size for Token id before transfer\n        currencyReserves[tokenId] = currencyReserve.add(currencyAmount);\n\n        // Update totalCurrency\n        totalCurrency = totalCurrency.add(currencyAmount);\n\n        // Proportion of the liquidity pool to give to current liquidity provider\n        // If rounding error occured, round down to favor previous liquidity providers\n        // See https://github.com/0xsequence/niftyswap/issues/19\n        liquiditiesToMint[i] = (currencyAmount.sub(rounded ? 1 : 0)).mul(totalLiquidity) / currencyReserve;\n        currencyAmounts[i] = currencyAmount;\n\n        // Mint liquidity ownership tokens and increase liquidity supply accordingly\n        totalSupplies[tokenId] = totalLiquidity.add(liquiditiesToMint[i]);\n\n      } else {\n        uint256 maxCurrency = _maxCurrency[i];\n\n        // Otherwise rounding error could end up being significant on second deposit\n        require(maxCurrency >= 1000, "NE20#14"); // NiftyswapExchange20#_addLiquidity: INVALID_CURRENCY_AMOUNT\n\n        // Update currency  reserve size for Token id before transfer\n        currencyReserves[tokenId] = maxCurrency;\n\n        // Update totalCurrency\n        totalCurrency = totalCurrency.add(maxCurrency);\n\n        // Initial liquidity is amount deposited (Incorrect pricing will be arbitraged)\n        // uint256 initialLiquidity = _maxCurrency;\n        totalSupplies[tokenId] = maxCurrency;\n\n        // Liquidity to mints\n        liquiditiesToMint[i] = maxCurrency;\n        currencyAmounts[i] = maxCurrency;\n      }\n    }\n\n    // Transfer all currency to this contract\n    TransferHelper.safeTransferFrom(currency, _provider, address(this), totalCurrency);\n\n    // Mint liquidity pool tokens\n    _batchMint(_provider, _tokenIds, liquiditiesToMint, "");\n\n\n    // Emit event\n    emit LiquidityAdded(_provider, _tokenIds, _tokenAmounts, currencyAmounts);\n  }\n\n  /**\n   * @dev Convert pool participation into amounts of token and currency.\n   * @dev Rounding error of the asset with lower resolution is traded for the other asset.\n   * @param _amountPool       Participation to be converted to tokens and currency.\n   * @param _tokenReserve     Amount of tokens on the AMM reserve.\n   * @param _currencyReserve  Amount of currency on the AMM reserve.\n   * @param _totalLiquidity   Total liquidity on the pool.\n   *\n   * @return currencyAmount Currency corresponding to pool amount plus rounded tokens.\n   * @return tokenAmount    Token corresponding to pool amount plus rounded currency.\n   */\n  function _toRoundedLiquidity(\n    uint256 _tokenId,\n    uint256 _amountPool,\n    uint256 _tokenReserve,\n    uint256 _currencyReserve,\n    uint256 _totalLiquidity\n  ) internal view returns (\n    uint256 currencyAmount,\n    uint256 tokenAmount,\n    uint256 soldTokenNumerator,\n    uint256 boughtCurrencyNumerator,\n    address royaltyRecipient,\n    uint256 royaltyNumerator\n  ) {\n    uint256 currencyNumerator = _amountPool.mul(_currencyReserve);\n    uint256 tokenNumerator = _amountPool.mul(_tokenReserve);\n\n    // Convert all tokenProduct rest to currency\n    soldTokenNumerator = tokenNumerator % _totalLiquidity;\n\n    if (soldTokenNumerator != 0) {\n      // The trade happens "after" funds are out of the pool\n      // so we need to remove these funds before computing the rate\n      uint256 virtualTokenReserve = _tokenReserve.sub(tokenNumerator / _totalLiquidity).mul(_totalLiquidity);\n      uint256 virtualCurrencyReserve = _currencyReserve.sub(currencyNumerator / _totalLiquidity).mul(_totalLiquidity);\n\n      // Skip process if any of the two reserves is left empty\n      // this step is important to avoid an error withdrawing all left liquidity\n      if (virtualCurrencyReserve != 0 && virtualTokenReserve != 0) {\n        boughtCurrencyNumerator = getSellPrice(soldTokenNumerator, virtualTokenReserve, virtualCurrencyReserve);\n\n        // Discount royalty currency\n        (royaltyRecipient, royaltyNumerator) = getRoyaltyInfo(_tokenId, boughtCurrencyNumerator);\n        boughtCurrencyNumerator = boughtCurrencyNumerator.sub(royaltyNumerator);\n\n        currencyNumerator = currencyNumerator.add(boughtCurrencyNumerator);\n\n        // Add royalty numerator (needs to be converted to ROYALTIES_DENOMINATOR)\n        royaltyNumerator = royaltyNumerator.mul(ROYALTIES_DENOMINATOR) / _totalLiquidity;\n      }\n    }\n\n    // Calculate amounts\n    currencyAmount = currencyNumerator / _totalLiquidity;\n    tokenAmount = tokenNumerator / _totalLiquidity;\n  }\n\n  /**\n   * @dev Burn liquidity pool tokens to withdraw currency  && Tokens at current ratio.\n   * @dev Sorting _tokenIds is mandatory for efficient way of preventing duplicated IDs (which would lead to errors)\n   * @param _provider         Address that removes liquidity to the reserve\n   * @param _tokenIds         Array of Token IDs where liquidity is removed\n   * @param _poolTokenAmounts Array of Amount of liquidity pool tokens burned for each Token id in _tokenIds.\n   * @param _minCurrency      Minimum currency withdrawn for each Token id in _tokenIds.\n   * @param _minTokens        Minimum Tokens id withdrawn for each Token id in _tokenIds.\n   * @param _deadline         Timestamp after which this transaction will be reverted\n   */\n  function _removeLiquidity(\n    address _provider,\n    uint256[] memory _tokenIds,\n    uint256[] memory _poolTokenAmounts,\n    uint256[] memory _minCurrency,\n    uint256[] memory _minTokens,\n    uint256 _deadline)\n    internal nonReentrant()\n  {\n    // Input validation\n    require(_deadline > block.timestamp, "NE20#15"); // NiftyswapExchange20#_removeLiquidity: DEADLINE_EXCEEDED\n\n    // Initialize variables\n    uint256 nTokens = _tokenIds.length;                        // Number of Token IDs to deposit\n    uint256 totalCurrency = 0;                                 // Total amount of currency  to transfer\n    uint256[] memory tokenAmounts = new uint256[](nTokens);    // Amount of Tokens to transfer for each id\n \n    // Structs contain most information for the event\n    // notice: tokenAmounts and tokenIds are absent because we already\n    // either have those arrays constructed or we need to construct them for other reasons\n    LiquidityRemovedEventObj[] memory eventObjs = new LiquidityRemovedEventObj[](nTokens);\n\n    // Get token reserves\n    uint256[] memory tokenReserves = _getTokenReserves(_tokenIds);\n\n    // Assumes NIFTY liquidity tokens are already received by contract, but not\n    // the currency nor the Tokens Ids\n\n    // Remove liquidity for each Token ID in _tokenIds\n    for (uint256 i = 0; i < nTokens; i++) {\n      // Store current id and amount from argument arrays\n      uint256 id = _tokenIds[i];\n      uint256 amountPool = _poolTokenAmounts[i];\n\n      // Load total liquidity pool token supply for Token _id\n      uint256 totalLiquidity = totalSupplies[id];\n      require(totalLiquidity > 0, "NE20#16"); // NiftyswapExchange20#_removeLiquidity: NULL_TOTAL_LIQUIDITY\n\n      // Load currency and Token reserve\'s supply of Token id\n      uint256 currencyReserve = currencyReserves[id];\n\n      // Calculate amount to withdraw for currency  and Token _id\n      uint256 currencyAmount;\n      uint256 tokenAmount;\n\n      {\n        uint256 tokenReserve = tokenReserves[i];\n        uint256 soldTokenNumerator;\n        uint256 boughtCurrencyNumerator;\n        address royaltyRecipient;\n        uint256 royaltyNumerator;\n\n        (\n          currencyAmount,\n          tokenAmount,\n          soldTokenNumerator,\n          boughtCurrencyNumerator,\n          royaltyRecipient,\n          royaltyNumerator\n        ) = _toRoundedLiquidity(id, amountPool, tokenReserve, currencyReserve, totalLiquidity);\n\n        // Add royalties\n        royaltiesNumerator[royaltyRecipient] = royaltiesNumerator[royaltyRecipient].add(royaltyNumerator);\n\n        // Add trade info to event\n        eventObjs[i].soldTokenNumerator = soldTokenNumerator;\n        eventObjs[i].boughtCurrencyNumerator = boughtCurrencyNumerator;\n        eventObjs[i].totalSupply = totalLiquidity;\n      }\n\n      // Verify if amounts to withdraw respect minimums specified\n      require(currencyAmount >= _minCurrency[i], "NE20#17"); // NiftyswapExchange20#_removeLiquidity: INSUFFICIENT_CURRENCY_AMOUNT\n      require(tokenAmount >= _minTokens[i], "NE20#18"); // NiftyswapExchange20#_removeLiquidity: INSUFFICIENT_TOKENS\n\n      // Update total liquidity pool token supply of Token _id\n      totalSupplies[id] = totalLiquidity.sub(amountPool);\n\n      // Update currency reserve size for Token id\n      currencyReserves[id] = currencyReserve.sub(currencyAmount);\n\n      // Update totalCurrency and tokenAmounts\n      totalCurrency = totalCurrency.add(currencyAmount);\n      tokenAmounts[i] = tokenAmount;\n\n      eventObjs[i].currencyAmount = currencyAmount;\n    }\n\n    // Burn liquidity pool tokens for offchain supplies\n    _batchBurn(address(this), _tokenIds, _poolTokenAmounts);\n\n    // Transfer total currency and all Tokens ids\n    TransferHelper.safeTransfer(currency, _provider, totalCurrency);\n    token.safeBatchTransferFrom(address(this), _provider, _tokenIds, tokenAmounts, "");\n\n    // Emit event\n    emit LiquidityRemoved(_provider, _tokenIds, tokenAmounts, eventObjs);\n  }\n\n  /***********************************|\n  |     Receiver Methods Handler      |\n  |__________________________________*/\n\n  // Method signatures for onReceive control logic\n\n  // bytes4(keccak256(\n  //   "_tokenToCurrency(uint256[],uint256[],uint256,uint256,address,address[],uint256[])"\n  // ));\n  bytes4 internal constant SELLTOKENS_SIG = 0xade79c7a;\n\n  //  bytes4(keccak256(\n  //   "_addLiquidity(address,uint256[],uint256[],uint256[],uint256)"\n  // ));\n  bytes4 internal constant ADDLIQUIDITY_SIG = 0x82da2b73;\n\n  // bytes4(keccak256(\n  //    "_removeLiquidity(address,uint256[],uint256[],uint256[],uint256[],uint256)"\n  // ));\n  bytes4 internal constant REMOVELIQUIDITY_SIG = 0x5c0bf259;\n\n  // bytes4(keccak256(\n  //   "DepositTokens()"\n  // ));\n  bytes4 internal constant DEPOSIT_SIG = 0xc8c323f9;\n\n  /***********************************|\n  |           Buying Tokens           |\n  |__________________________________*/\n\n  /**\n   * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\n   * @dev User specifies MAXIMUM inputs (_maxCurrency) and EXACT outputs.\n   * @dev Assumes that all trades will be successful, or revert the whole tx\n   * @dev Exceeding currency tokens sent will be refunded to recipient\n   * @dev Sorting IDs is mandatory for efficient way of preventing duplicated IDs (which would lead to exploit)\n   * @param _tokenIds            Array of Tokens ID that are bought\n   * @param _tokensBoughtAmounts Amount of Tokens id bought for each corresponding Token id in _tokenIds\n   * @param _maxCurrency         Total maximum amount of currency tokens to spend for all Token ids\n   * @param _deadline            Timestamp after which this transaction will be reverted\n   * @param _recipient           The address that receives output Tokens and refund\n   * @param _extraFeeRecipients  Array of addresses that will receive extra fee\n   * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\n   * @return currencySold How much currency was actually sold.\n   */\n  function buyTokens(\n    uint256[] memory _tokenIds,\n    uint256[] memory _tokensBoughtAmounts,\n    uint256 _maxCurrency,\n    uint256 _deadline,\n    address _recipient,\n    address[] memory _extraFeeRecipients,\n    uint256[] memory _extraFeeAmounts\n  )\n    override external returns (uint256[] memory)\n  {\n    require(_deadline >= block.timestamp, "NE20#19"); // NiftyswapExchange20#buyTokens: DEADLINE_EXCEEDED\n    require(_tokenIds.length > 0, "NE20#20"); // NiftyswapExchange20#buyTokens: INVALID_CURRENCY_IDS_AMOUNT\n\n    // Transfer the tokens for purchase\n    TransferHelper.safeTransferFrom(currency, msg.sender, address(this), _maxCurrency);\n\n    address recipient = _recipient == address(0x0) ? msg.sender : _recipient;\n\n    // Set the extra fee aside to recipients ahead of purchase, if any.\n    uint256 maxCurrency = _maxCurrency;\n    uint256 nExtraFees = _extraFeeRecipients.length;\n    require(nExtraFees == _extraFeeAmounts.length, "NE20#21"); // NiftyswapExchange20#buyTokens: EXTRA_FEES_ARRAYS_ARE_NOT_SAME_LENGTH\n    \n    for (uint256 i = 0; i < nExtraFees; i++) {\n      if (_extraFeeAmounts[i] > 0) {\n        maxCurrency = maxCurrency.sub(_extraFeeAmounts[i]);\n        royaltiesNumerator[_extraFeeRecipients[i]] = royaltiesNumerator[_extraFeeRecipients[i]].add(_extraFeeAmounts[i].mul(ROYALTIES_DENOMINATOR));\n      }\n    }\n\n    // Execute trade and retrieve amount of currency spent\n    uint256[] memory currencySold = _currencyToToken(_tokenIds, _tokensBoughtAmounts, maxCurrency, _deadline, recipient);\n    emit TokensPurchase(msg.sender, recipient, _tokenIds, _tokensBoughtAmounts, currencySold, _extraFeeRecipients, _extraFeeAmounts);\n\n    return currencySold;\n  }\n\n  /**\n   * @notice Handle which method is being called on transfer\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\n   *   where bytes4 argument is the MethodObj object signature passed as defined\n   *   in the `Signatures for onReceive control logic` section above\n   * @param _from     The address which previously owned the Token\n   * @param _ids      An array containing ids of each Token being transferred\n   * @param _amounts  An array containing amounts of each Token being transferred\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\n   * @return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")\n   */\n  function onERC1155BatchReceived(\n    address, // _operator,\n    address _from,\n    uint256[] memory _ids,\n    uint256[] memory _amounts,\n    bytes memory _data)\n    override public returns(bytes4)\n  {\n    // This function assumes that the ERC-1155 token contract can\n    // only call `onERC1155BatchReceived()` via a valid token transfer.\n    // Users must be responsible and only use this Niftyswap exchange\n    // contract with ERC-1155 compliant token contracts.\n\n    // Obtain method to call via object signature\n    bytes4 functionSignature = abi.decode(_data, (bytes4));\n\n    /***********************************|\n    |           Selling Tokens          |\n    |__________________________________*/\n\n    if (functionSignature == SELLTOKENS_SIG) {\n\n      // Tokens received need to be Token contract\n      require(msg.sender == address(token), "NE20#22"); // NiftyswapExchange20#onERC1155BatchReceived: INVALID_TOKENS_TRANSFERRED\n\n      // Decode SellTokensObj from _data to call _tokenToCurrency()\n      SellTokensObj memory obj;\n      (, obj) = abi.decode(_data, (bytes4, SellTokensObj));\n      address recipient = obj.recipient == address(0x0) ? _from : obj.recipient;\n\n      // Validate fee arrays\n      require(obj.extraFeeRecipients.length == obj.extraFeeAmounts.length, "NE20#23"); // NiftyswapExchange20#buyTokens: EXTRA_FEES_ARRAYS_ARE_NOT_SAME_LENGTH\n    \n      // Execute trade and retrieve amount of currency received\n      uint256[] memory currencyBought = _tokenToCurrency(_ids, _amounts, obj.minCurrency, obj.deadline, recipient, obj.extraFeeRecipients, obj.extraFeeAmounts);\n      emit CurrencyPurchase(_from, recipient, _ids, _amounts, currencyBought, obj.extraFeeRecipients, obj.extraFeeAmounts);\n\n    /***********************************|\n    |      Adding Liquidity Tokens      |\n    |__________________________________*/\n\n    } else if (functionSignature == ADDLIQUIDITY_SIG) {\n      // Only allow to receive ERC-1155 tokens from `token` contract\n      require(msg.sender == address(token), "NE20#24"); // NiftyswapExchange20#onERC1155BatchReceived: INVALID_TOKEN_TRANSFERRED\n\n      // Decode AddLiquidityObj from _data to call _addLiquidity()\n      AddLiquidityObj memory obj;\n      (, obj) = abi.decode(_data, (bytes4, AddLiquidityObj));\n      _addLiquidity(_from, _ids, _amounts, obj.maxCurrency, obj.deadline);\n\n    /***********************************|\n    |      Removing iquidity Tokens     |\n    |__________________________________*/\n\n    } else if (functionSignature == REMOVELIQUIDITY_SIG) {\n      // Tokens received need to be NIFTY-1155 tokens\n      require(msg.sender == address(this), "NE20#25"); // NiftyswapExchange20#onERC1155BatchReceived: INVALID_NIFTY_TOKENS_TRANSFERRED\n\n      // Decode RemoveLiquidityObj from _data to call _removeLiquidity()\n      RemoveLiquidityObj memory obj;\n      (, obj) = abi.decode(_data, (bytes4, RemoveLiquidityObj));\n      _removeLiquidity(_from, _ids, _amounts, obj.minCurrency, obj.minTokens, obj.deadline);\n\n    /***********************************|\n    |      Deposits & Invalid Calls     |\n    |__________________________________*/\n\n    } else if (functionSignature == DEPOSIT_SIG) {\n      // Do nothing for when contract is self depositing\n      // This could be use to deposit currency "by accident", which would be locked\n      require(msg.sender == address(currency), "NE20#26"); // NiftyswapExchange20#onERC1155BatchReceived: INVALID_TOKENS_DEPOSITED\n\n    } else {\n      revert("NE20#27"); // NiftyswapExchange20#onERC1155BatchReceived: INVALID_METHOD\n    }\n\n    return ERC1155_BATCH_RECEIVED_VALUE;\n  }\n\n  /**\n   * @dev Will pass to onERC115Batch5Received\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes memory _data)\n    override public returns(bytes4)\n  {\n    uint256[] memory ids = new uint256[](1);\n    uint256[] memory amounts = new uint256[](1);\n\n    ids[0] = _id;\n    amounts[0] = _amount;\n\n    require(\n      ERC1155_BATCH_RECEIVED_VALUE == onERC1155BatchReceived(_operator, _from, ids, amounts, _data),\n      "NE20#28" // NiftyswapExchange20#onERC1155Received: INVALID_ONRECEIVED_MESSAGE\n    );\n\n    return ERC1155_RECEIVED_VALUE;\n  }\n\n  /**\n   * @notice Prevents receiving Ether or calls to unsuported methods\n   */\n  fallback () external {\n    revert("NE20#29"); // NiftyswapExchange20:UNSUPPORTED_METHOD\n  }\n\n  /***********************************|\n  |         Royalty Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Will set the royalties fees and recipient for contracts that don\'t support ERC-2981\n   * @param _fee       Fee pourcentage with a 10000 basis (e.g. 0.3% is 3 and 1% is 10 and 100% is 1000)\n   * @param _recipient Address where to send the fees to\n   */\n  function setRoyaltyInfo(uint256 _fee, address _recipient) onlyOwner public {\n    // Don\'t use IS_ERC2981 in case token contract was updated\n    bool isERC2981 = token.supportsInterface(type(IERC2981).interfaceId);\n    require(!isERC2981, "NE20#30"); // NiftyswapExchange20#setRoyaltyInfo: TOKEN SUPPORTS ERC-2981\n    require(_fee <= MAX_ROYALTY, "NE20#31"); // NiftyswapExchange20#setRoyaltyInfo: ROYALTY_FEE_IS_TOO_HIGH\n\n    globalRoyaltyFee = _fee;\n    globalRoyaltyRecipient = _recipient;\n    emit RoyaltyChanged(_recipient, _fee);\n  }\n\n  /**\n   * @notice Will send the royalties that _royaltyRecipient can claim, if any \n   * @dev Anyone can call this function such that payout could be distributed \n   *      regularly instead of being claimed. \n   * @param _royaltyRecipient Address that is able to claim royalties\n   */\n  function sendRoyalties(address _royaltyRecipient) override external {\n    uint256 royaltyAmount = royaltiesNumerator[_royaltyRecipient] / ROYALTIES_DENOMINATOR;\n    royaltiesNumerator[_royaltyRecipient] = royaltiesNumerator[_royaltyRecipient] % ROYALTIES_DENOMINATOR;\n    TransferHelper.safeTransfer(currency, _royaltyRecipient, royaltyAmount);\n  }\n\n  /**\n   * @notice Will return how much of currency need to be paid for the royalty\n   * @notice Royalty is capped at 25% of the total amount of currency\n   * @param _tokenId ID of the erc-1155 token being traded\n   * @param _cost    Amount of currency sent/received for the trade\n   * @return recipient Address that will be able to claim the royalty\n   * @return royalty Amount of currency that will be sent to royalty recipient\n   */\n  function getRoyaltyInfo(uint256 _tokenId, uint256 _cost) public view returns (address recipient, uint256 royalty) {\n    if (IS_ERC2981) {\n      // Add a try/catch in-case token *removed* ERC-2981 support\n      try IERC2981(address(token)).royaltyInfo(_tokenId, _cost) returns(address _r, uint256 _c) {\n        // Cap to 25% of the total amount of currency\n        uint256 max = _cost.mul(MAX_ROYALTY) / ROYALTIES_DENOMINATOR;\n        return (_r, _c > max ? max : _c);\n      } catch {\n        // Default back to global setting if error occurs\n        return (globalRoyaltyRecipient, (_cost.mul(globalRoyaltyFee)) / ROYALTIES_DENOMINATOR);\n      }\n\n    } else {\n      return (globalRoyaltyRecipient, (_cost.mul(globalRoyaltyFee)) / ROYALTIES_DENOMINATOR);\n    }\n  }\n\n\n  /***********************************|\n  |         Getter Functions          |\n  |__________________________________*/\n\n  /**\n   * @notice Get amount of currency in reserve for each Token _id in _ids\n   * @param _ids Array of ID sto query currency reserve of\n   * @return amount of currency in reserve for each Token _id\n   */\n  function getCurrencyReserves(\n    uint256[] calldata _ids)\n    override external view returns (uint256[] memory)\n  {\n    uint256 nIds = _ids.length;\n    uint256[] memory currencyReservesReturn = new uint256[](nIds);\n    for (uint256 i = 0; i < nIds; i++) {\n      currencyReservesReturn[i] = currencyReserves[_ids[i]];\n    }\n    return currencyReservesReturn;\n  }\n\n  /**\n   * @notice Return price for `currency => Token _id` trades with an exact token amount.\n   * @param _ids           Array of ID of tokens bought.\n   * @param _tokensBought Amount of Tokens bought.\n   * @return Amount of currency needed to buy Tokens in _ids for amounts in _tokensBought\n   */\n  function getPrice_currencyToToken(\n    uint256[] calldata _ids,\n    uint256[] calldata _tokensBought)\n    override external view returns (uint256[] memory)\n  {\n    uint256 nIds = _ids.length;\n    uint256[] memory prices = new uint256[](nIds);\n\n    for (uint256 i = 0; i < nIds; i++) {\n      // Load Token id reserve\n      uint256 tokenReserve = token.balanceOf(address(this), _ids[i]);\n      prices[i] = getBuyPriceWithRoyalty(_ids[i], _tokensBought[i], currencyReserves[_ids[i]], tokenReserve);\n    }\n\n    // Return prices\n    return prices;\n  }\n\n  /**\n   * @notice Return price for `Token _id => currency` trades with an exact token amount.\n   * @param _ids        Array of IDs  token sold.\n   * @param _tokensSold Array of amount of each Token sold.\n   * @return Amount of currency that can be bought for Tokens in _ids for amounts in _tokensSold\n   */\n  function getPrice_tokenToCurrency(\n    uint256[] calldata _ids,\n    uint256[] calldata _tokensSold)\n    override external view returns (uint256[] memory)\n  {\n    uint256 nIds = _ids.length;\n    uint256[] memory prices = new uint256[](nIds);\n\n    for (uint256 i = 0; i < nIds; i++) {\n      // Load Token id reserve\n      uint256 tokenReserve = token.balanceOf(address(this), _ids[i]);\n      prices[i] = getSellPriceWithRoyalty(_ids[i], _tokensSold[i], tokenReserve, currencyReserves[_ids[i]]);\n    }\n\n    // Return price\n    return prices;\n  }\n\n  /**\n   * @return Address of Token that is sold on this exchange.\n   */\n  function getTokenAddress() override external view returns (address) {\n    return address(token);\n  }\n\n  /**\n   * @return LP fee per 1000 units\n   */\n  function getLPFee() override external view returns (uint256) {\n    return 1000-FEE_MULTIPLIER;\n  }\n\n  /**\n   * @return Address of the currency contract that is used as currency\n   */\n  function getCurrencyInfo() override external view returns (address) {\n    return (address(currency));\n  }\n\n  /**\n   * @notice Get total supply of liquidity tokens\n   * @param _ids ID of the Tokens\n   * @return The total supply of each liquidity token id provided in _ids\n   */\n  function getTotalSupply(uint256[] calldata _ids)\n    override external view returns (uint256[] memory)\n  {\n    // Number of ids\n    uint256 nIds = _ids.length;\n\n    // Variables\n    uint256[] memory batchTotalSupplies = new uint256[](nIds);\n\n    // Iterate over each owner and token ID\n    for (uint256 i = 0; i < nIds; i++) {\n      batchTotalSupplies[i] = totalSupplies[_ids[i]];\n    }\n\n    return batchTotalSupplies;\n  }\n\n  /**\n   * @return Address of factory that created this exchange.\n   */\n  function getFactoryAddress() override external view returns (address) {\n    return factory;\n  }\n\n  /**\n   * @return Global royalty fee % if not supporting ERC-2981\n   */\n  function getGlobalRoyaltyFee() override external view returns (uint256) {\n    return globalRoyaltyFee;\n  }\n\n  /**\n   * @return Global royalty recipient if token not supporting ERC-2981\n   */\n  function getGlobalRoyaltyRecipient() override external view returns (address) {\n    return globalRoyaltyRecipient;\n  }\n\n  /**\n   * @return Get amount of currency in royalty an address can claim\n   * @param _royaltyRecipient Address to check the claimable royalties\n   */\n  function getRoyalties(address _royaltyRecipient) override external view returns (uint256) {\n    return royaltiesNumerator[_royaltyRecipient] / ROYALTIES_DENOMINATOR;\n  }\n\n  function getRoyaltiesNumerator(address _royaltyRecipient) override external view returns (uint256) {\n    return royaltiesNumerator[_royaltyRecipient];\n  }\n\n  /***********************************|\n  |         Utility Functions         |\n  |__________________________________*/\n\n  /**\n   * @notice Divides two numbers and add 1 if there is a rounding error\n   * @param a Numerator\n   * @param b Denominator\n   */\n  function divRound(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n    return a % b == 0 ? (a/b, false) : ((a/b).add(1), true);\n  }\n\n  /**\n   * @notice Return Token reserves for given Token ids\n   * @dev Assumes that ids are sorted from lowest to highest with no duplicates.\n   *      This assumption allows for checking the token reserves only once, otherwise\n   *      token reserves need to be re-checked individually or would have to do more expensive\n   *      duplication checks.\n   * @param _tokenIds Array of IDs to query their Reserve balance.\n   * @return Array of Token ids\' reserves\n   */\n  function _getTokenReserves(\n    uint256[] memory _tokenIds)\n    internal view returns (uint256[] memory)\n  {\n    uint256 nTokens = _tokenIds.length;\n\n    // Regular balance query if only 1 token, otherwise batch query\n    if (nTokens == 1) {\n      uint256[] memory tokenReserves = new uint256[](1);\n      tokenReserves[0] = token.balanceOf(address(this), _tokenIds[0]);\n      return tokenReserves;\n\n    } else {\n      // Lazy check preventing duplicates & build address array for query\n      address[] memory thisAddressArray = new address[](nTokens);\n      thisAddressArray[0] = address(this);\n\n      for (uint256 i = 1; i < nTokens; i++) {\n        require(_tokenIds[i-1] < _tokenIds[i], "NE20#32"); // NiftyswapExchange20#_getTokenReserves: UNSORTED_OR_DUPLICATE_TOKEN_IDS\n        thisAddressArray[i] = address(this);\n      }\n      return token.balanceOfBatch(thisAddressArray, _tokenIds);\n    }\n  }\n\n  /**\n   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n   *      This function MUST NOT consume more thsan 5,000 gas.\n   * @return Whether a given interface is supported\n   */\n  function supportsInterface(bytes4 interfaceID) public override pure returns (bool) {\n    return interfaceID == type(IERC20).interfaceId ||\n      interfaceID == type(IERC165).interfaceId || \n      interfaceID == type(IERC1155).interfaceId || \n      interfaceID == type(IERC1155TokenReceiver).interfaceId ||\n      interfaceID == type(IERC1155Metadata).interfaceId;\n  }\n\n}\n'
      },
      'contracts/interfaces/INiftyswapExchange20.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\ninterface INiftyswapExchange20 {\n\n  /***********************************|\n  |               Events              |\n  |__________________________________*/\n\n  event TokensPurchase(\n    address indexed buyer,\n    address indexed recipient,\n    uint256[] tokensBoughtIds,\n    uint256[] tokensBoughtAmounts,\n    uint256[] currencySoldAmounts,\n    address[] extraFeeRecipients,\n    uint256[] extraFeeAmounts\n  );\n\n  event CurrencyPurchase(\n    address indexed buyer,\n    address indexed recipient,\n    uint256[] tokensSoldIds,\n    uint256[] tokensSoldAmounts,\n    uint256[] currencyBoughtAmounts,\n    address[] extraFeeRecipients,\n    uint256[] extraFeeAmounts\n  );\n\n  event LiquidityAdded(\n    address indexed provider,\n    uint256[] tokenIds,\n    uint256[] tokenAmounts,\n    uint256[] currencyAmounts\n  );\n\n  struct LiquidityRemovedEventObj {\n    uint256 currencyAmount;\n    uint256 soldTokenNumerator;\n    uint256 boughtCurrencyNumerator;\n    uint256 totalSupply;\n  }\n\n  event LiquidityRemoved(\n    address indexed provider,\n    uint256[] tokenIds,\n    uint256[] tokenAmounts,\n    LiquidityRemovedEventObj[] details\n  );\n\n  event RoyaltyChanged(\n    address indexed royaltyRecipient,\n    uint256 royaltyFee\n  );\n\n  struct SellTokensObj {\n    address recipient;            // Who receives the currency\n    uint256 minCurrency;          // Total minimum number of currency  expected for all tokens sold\n    address[] extraFeeRecipients; // Array of addresses that will receive extra fee\n    uint256[] extraFeeAmounts;    // Array of amounts of currency that will be sent as extra fee\n    uint256 deadline;             // Timestamp after which the tx isn\'t valid anymore\n  }\n\n  struct AddLiquidityObj {\n    uint256[] maxCurrency; // Maximum number of currency to deposit with tokens\n    uint256 deadline;      // Timestamp after which the tx isn\'t valid anymore\n  }\n\n  struct RemoveLiquidityObj {\n    uint256[] minCurrency; // Minimum number of currency to withdraw\n    uint256[] minTokens;   // Minimum number of tokens to withdraw\n    uint256 deadline;      // Timestamp after which the tx isn\'t valid anymore\n  }\n\n\n  /***********************************|\n  |        Purchasing Functions       |\n  |__________________________________*/\n  \n  /**\n   * @notice Convert currency tokens to Tokens _id and transfers Tokens to recipient.\n   * @dev User specifies MAXIMUM inputs (_maxCurrency) and EXACT outputs.\n   * @dev Assumes that all trades will be successful, or revert the whole tx\n   * @dev Exceeding currency tokens sent will be refunded to recipient\n   * @dev Sorting IDs is mandatory for efficient way of preventing duplicated IDs (which would lead to exploit)\n   * @param _tokenIds            Array of Tokens ID that are bought\n   * @param _tokensBoughtAmounts Amount of Tokens id bought for each corresponding Token id in _tokenIds\n   * @param _maxCurrency         Total maximum amount of currency tokens to spend for all Token ids\n   * @param _deadline            Timestamp after which this transaction will be reverted\n   * @param _recipient           The address that receives output Tokens and refund\n   * @param _extraFeeRecipients  Array of addresses that will receive extra fee\n   * @param _extraFeeAmounts     Array of amounts of currency that will be sent as extra fee\n   * @return currencySold How much currency was actually sold.\n   */\n  function buyTokens(\n    uint256[] memory _tokenIds,\n    uint256[] memory _tokensBoughtAmounts,\n    uint256 _maxCurrency,\n    uint256 _deadline,\n    address _recipient,\n    address[] memory _extraFeeRecipients,\n    uint256[] memory _extraFeeAmounts\n  ) external returns (uint256[] memory);\n\n  /***********************************|\n  |         Royalties Functions       |\n  |__________________________________*/\n\n  /**\n   * @notice Will send the royalties that _royaltyRecipient can claim, if any \n   * @dev Anyone can call this function such that payout could be distributed \n   *      regularly instead of being claimed. \n   * @param _royaltyRecipient Address that is able to claim royalties\n   */\n  function sendRoyalties(address _royaltyRecipient) external;\n\n  /***********************************|\n  |        OnReceive Functions        |\n  |__________________________________*/\n\n  /**\n   * @notice Handle which method is being called on Token transfer\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\n   *   where bytes4 argument is the MethodObj object signature passed as defined\n   *   in the `Signatures for onReceive control logic` section above\n   * @param _operator The address which called the `safeTransferFrom` function\n   * @param _from     The address which previously owned the token\n   * @param _id       The id of the token being transferred\n   * @param _amount   The amount of tokens being transferred\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\n   * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n   */\n  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n\n  /**\n   * @notice Handle which method is being called on transfer\n   * @dev `_data` must be encoded as follow: abi.encode(bytes4, MethodObj)\n   *   where bytes4 argument is the MethodObj object signature passed as defined\n   *   in the `Signatures for onReceive control logic` section above\n   * @param _from     The address which previously owned the Token\n   * @param _ids      An array containing ids of each Token being transferred\n   * @param _amounts  An array containing amounts of each Token being transferred\n   * @param _data     Method signature and corresponding encoded arguments for method to call on *this* contract\n   * @return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")\n   */\n  function onERC1155BatchReceived(address, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n\n\n  /***********************************|\n  |         Getter Functions          |\n  |__________________________________*/\n\n  /**\n   * @dev Pricing function used for converting between currency token to Tokens.\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\n   * @return Amount of currency tokens to send to Niftyswap.\n   */\n  function getBuyPrice(uint256 _assetBoughtAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external view returns (uint256);\n\n  /**\n   * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\n   * @param _tokenId            Id ot token being sold\n   * @param _assetBoughtAmount  Amount of Tokens being bought.\n   * @param _assetSoldReserve   Amount of currency tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of Tokens (output type) in exchange reserves.\n   * @return price Amount of currency tokens to send to Niftyswap.\n   */\n  function getBuyPriceWithRoyalty(uint256 _tokenId, uint256 _assetBoughtAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external view returns (uint256 price);\n\n  /**\n   * @dev Pricing function used for converting Tokens to currency token.\n   * @param _assetSoldAmount    Amount of Tokens being sold.\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\n   * @return Amount of currency tokens to receive from Niftyswap.\n   */\n  function getSellPrice(uint256 _assetSoldAmount,uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external view returns (uint256);\n\n  /**\n   * @dev Pricing function used for converting Tokens to currency token (including royalty fee)\n   * @param _tokenId            Id ot token being sold\n   * @param _assetSoldAmount    Amount of Tokens being sold.\n   * @param _assetSoldReserve   Amount of Tokens in exchange reserves.\n   * @param _assetBoughtReserve Amount of currency tokens in exchange reserves.\n   * @return price Amount of currency tokens to receive from Niftyswap.\n   */\n  function getSellPriceWithRoyalty(uint256 _tokenId, uint256 _assetSoldAmount, uint256 _assetSoldReserve, uint256 _assetBoughtReserve) external view returns (uint256 price);\n\n  /**\n   * @notice Get amount of currency in reserve for each Token _id in _ids\n   * @param _ids Array of ID sto query currency reserve of\n   * @return amount of currency in reserve for each Token _id\n   */\n  function getCurrencyReserves(uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @notice Return price for `currency => Token _id` trades with an exact token amount.\n   * @param _ids          Array of ID of tokens bought.\n   * @param _tokensBought Amount of Tokens bought.\n   * @return Amount of currency needed to buy Tokens in _ids for amounts in _tokensBought\n   */\n  function getPrice_currencyToToken(uint256[] calldata _ids, uint256[] calldata _tokensBought) external view returns (uint256[] memory);\n\n  /**\n   * @notice Return price for `Token _id => currency` trades with an exact token amount.\n   * @param _ids        Array of IDs  token sold.\n   * @param _tokensSold Array of amount of each Token sold.\n   * @return Amount of currency that can be bought for Tokens in _ids for amounts in _tokensSold\n   */\n  function getPrice_tokenToCurrency(uint256[] calldata _ids, uint256[] calldata _tokensSold) external view returns (uint256[] memory);\n\n  /**\n   * @notice Get total supply of liquidity tokens\n   * @param _ids ID of the Tokens\n   * @return The total supply of each liquidity token id provided in _ids\n   */\n  function getTotalSupply(uint256[] calldata _ids) external view returns (uint256[] memory);\n\n  /**\n   * @return Address of Token that is sold on this exchange.\n   */\n  function getTokenAddress() external view returns (address);\n\n  /**\n   * @return LP fee per 1000 units\n   */\n  function getLPFee() external view returns (uint256);\n\n  /**\n   * @return Address of the currency contract that is used as currency\n   */\n  function getCurrencyInfo() external view returns (address);\n\n  /**\n   * @return Address of factory that created this exchange.\n   */\n  function getFactoryAddress() external view returns (address);\n\n  /**\n   * @return Global royalty fee % if not supporting ERC-2981\n   */\n  function getGlobalRoyaltyFee() external view returns (uint256);  \n\n  /**\n   * @return Global royalty recipient if token not supporting ERC-2981\n   */\n  function getGlobalRoyaltyRecipient() external view returns (address);\n\n  /**\n   * @return Get amount of currency in royalty an address can claim\n   * @param _royaltyRecipient Address to check the claimable royalties\n   */\n  function getRoyalties(address _royaltyRecipient) external view returns (uint256);\n\n  function getRoyaltiesNumerator(address _royaltyRecipient) external view returns (uint256);\n}\n'
      },
      'contracts/utils/DelegatedOwnable.sol': {
        content:
          'pragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\nimport "../interfaces/IOwnable.sol";\n\n/**\n * @title Ownable\n * @dev The Ownable contract inherits the owner of a parent contract as its owner, \n * and provides basic authorization control functions, this simplifies the \n * implementation of "user permissions".\n */\ncontract DelegatedOwnable {\n  address internal ownableParent;\n\n  event ParentOwnerChanged(address indexed previousParent, address indexed newParent);\n\n  /**\n   * @dev The Ownable constructor sets the original `ownableParent` of the contract to the specied address\n   * @param _firstOwnableParent Address of the first ownable parent contract\n   */\n  constructor (address _firstOwnableParent) {\n    try IOwnable(_firstOwnableParent).getOwner() {\n      // Do nothing if parent has ownable function\n    } catch {\n      revert("DO#1"); // PARENT IS NOT OWNABLE\n    }\n    ownableParent = _firstOwnableParent;\n    emit ParentOwnerChanged(address(0), _firstOwnableParent);\n  }\n\n  /**\n   * @dev Throws if called by any account other than the master owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == getOwner(), "DO#2"); // DelegatedOwnable#onlyOwner: SENDER_IS_NOT_OWNER\n    _;\n  }\n\n  /**\n   * @notice Will use the owner address of another parent contract\n   * @param _newParent Address of the new owner\n   */\n  function changeOwnableParent(address _newParent) public onlyOwner {\n    require(_newParent != address(0), "D3"); // DelegatedOwnable#changeOwnableParent: INVALID_ADDRESS\n    ownableParent = _newParent;\n    emit ParentOwnerChanged(ownableParent, _newParent);\n  }\n\n  /**\n   * @notice Returns the address of the owner.\n   */\n  function getOwner() public view returns (address) {\n    return IOwnable(ownableParent).getOwner();\n  }\n}'
      },
      'contracts/interfaces/IERC1155Metadata.sol': {
        content:
          'pragma solidity ^0.7.4;\n\n/**\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\n*/\ninterface IERC1155Metadata {\n    /**\n        @notice A distinct Uniform Resource Identifier (URI) for a given token.\n        @dev URIs are defined in RFC 3986.\n        The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".        \n        @return URI string\n    */\n    function uri(uint256 _id) external view returns (string memory);\n}\n'
      },
      'contracts/interfaces/IDelegatedERC1155Metadata.sol': {
        content:
          'pragma solidity ^0.7.4;\n\nimport "./IERC1155Metadata.sol";\n\n\ninterface IDelegatedERC1155Metadata {\n  function metadataProvider() external view returns (IERC1155Metadata);\n}\n'
      },
      '@uniswap/lib/contracts/libraries/TransferHelper.sol': {
        content:
          "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
      },
      'contracts/interfaces/IOwnable.sol': {
        content:
          'pragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\n\ninterface IOwnable {\n  /**\n   * @notice Transfers the ownership of the contract to new address\n   * @param _newOwner Address of the new owner\n   */\n  function transferOwnership(address _newOwner) external;\n\n  /**\n   * @notice Returns the address of the owner.\n   */\n  function getOwner() external view returns (address);\n}'
      },
      'contracts/utils/ERC1155MetadataPrefix.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\n\nimport "../interfaces/IERC1155Metadata.sol";\nimport "./Ownable.sol";\n\n\ncontract ERC1155MetadataPrefix is IERC1155Metadata, Ownable {\n  string public uriPrefix;\n\n  event URIPrefixChanged(string _uriPrefix);\n\n  bool immutable includeAddress;\n\n  constructor(string memory _prefix, bool _includeAddress) Ownable(msg.sender) {\n    emit URIPrefixChanged(_prefix);\n    uriPrefix = _prefix;\n    includeAddress = _includeAddress;\n  }\n\n  function setUriPrefix(string calldata _uriPrefix) external onlyOwner {\n    emit URIPrefixChanged(_uriPrefix);\n    uriPrefix = _uriPrefix;\n  }\n\n  function uri(uint256 _id) external override view returns (string memory) {\n    string memory suffix = _uint256toString(_id);\n\n    if (includeAddress) {\n      suffix = string(abi.encodePacked(suffix, "@", _addressToString(msg.sender)));\n    }\n\n    return string(abi.encodePacked(uriPrefix, suffix));\n  }\n\n  function _addressToString(address account) public pure returns(string memory) {\n    return _bytesToString(abi.encodePacked(account));\n  }\n\n  function _bytesToString(bytes memory data) public pure returns(string memory) {\n    bytes memory alphabet = "0123456789abcdef";\n\n    bytes memory str = new bytes(2 + data.length * 2);\n    str[0] = "0";\n    str[1] = "x";\n    for (uint i = 0; i < data.length; i++) {\n      str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];\n      str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\n    }\n\n    return string(str);\n  }\n\n  function _uint256toString(uint256 _id) internal pure returns (string memory) {\n    bytes memory reversed = new bytes(78);\n\n    uint256 v = _id;\n    uint256 i = 0;\n    while (v != 0) {\n      uint256 remainder = v % 10;\n      v = v / 10;\n      reversed[i++] = byte(uint8(48 + remainder));\n    }\n\n    bytes memory s = new bytes(i);\n    for (uint256 j = 0; j < i; j++) {\n      s[j] = reversed[i - 1 - j];\n    }\n\n    return string(s);\n  }\n}\n'
      },
      '@0xsequence/erc20-meta-token/contracts/mocks/ERC20Mock.sol': {
        content:
          'pragma solidity 0.7.4;\n\nimport "@0xsequence/erc-1155/contracts/interfaces/IERC20.sol";\nimport "@0xsequence/erc-1155/contracts/utils/SafeMath.sol";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://eips.ethereum.org/EIPS/eip-20\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn\'t required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  /**\n    * @dev Total number of tokens in existence\n    */\n  function totalSupply() public override view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n    * @dev Gets the balance of the specified address.\n    * @param owner The address to query the balance of.\n    * @return A uint256 representing the amount owned by the passed address.\n    */\n  function balanceOf(address owner) public override view returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param owner address The address which owns the funds.\n    * @param spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n  function allowance(address owner, address spender) public override view returns (uint256) {\n    return _allowed[owner][spender];\n  }\n\n  /**\n    * @dev Transfer token to a specified address\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n  function transfer(address to, uint256 value) public override returns (bool) {\n    _transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender\'s allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param spender The address which will spend the funds.\n    * @param value The amount of tokens to be spent.\n    */\n  function approve(address spender, uint256 value) public override returns (bool) {\n    _approve(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n    * @dev Transfer tokens from one address to another.\n    * Note that while this function emits an Approval event, this is not required as per the specification,\n    * and other compliant implementations may not emit the event.\n    * @param from address The address which you want to send tokens from\n    * @param to address The address which you want to transfer to\n    * @param value uint256 the amount of tokens to be transferred\n    */\n  function transferFrom(address from, address to, uint256 value) public override returns (bool) {\n    _transfer(from, to, value);\n    _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n    return true;\n  }\n\n  /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * Emits an Approval event.\n    * @param spender The address which will spend the funds.\n    * @param addedValue The amount of tokens to increase the allowance by.\n    */\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n    return true;\n  }\n\n  /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * Emits an Approval event.\n    * @param spender The address which will spend the funds.\n    * @param subtractedValue The amount of tokens to decrease the allowance by.\n    */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n    return true;\n  }\n\n  /**\n    * @dev Transfer token for a specified addresses\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    */\n  function _transfer(address from, address to, uint256 value) internal {\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(from, to, value);\n  }\n\n  /**\n    * @dev Internal function that mints an amount of the token and assigns it to\n    * an account. This encapsulates the modification of balances such that the\n    * proper events are emitted.\n    * @param account The account that will receive the created tokens.\n    * @param value The amount that will be created.\n    */\n  function _mint(address account, uint256 value) internal {\n    require(account != address(0));\n\n    _totalSupply = _totalSupply.add(value);\n    _balances[account] = _balances[account].add(value);\n    emit Transfer(address(0), account, value);\n  }\n\n  /**\n    * @dev Internal function that burns an amount of the token of a given\n    * account.\n    * @param account The account whose tokens will be burnt.\n    * @param value The amount that will be burnt.\n    */\n  function _burn(address account, uint256 value) internal {\n    require(account != address(0));\n\n    _totalSupply = _totalSupply.sub(value);\n    _balances[account] = _balances[account].sub(value);\n    emit Transfer(account, address(0), value);\n  }\n\n  /**\n    * @dev Approve an address to spend another addresses\' tokens.\n    * @param owner The address that owns the tokens.\n    * @param spender The address that will spend the tokens.\n    * @param value The number of tokens that can be spent.\n    */\n  function _approve(address owner, address spender, uint256 value) internal {\n    require(spender != address(0));\n    require(owner != address(0));\n\n    _allowed[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  }\n\n  /**\n    * @dev Internal function that burns an amount of the token of a given\n    * account, deducting from the sender\'s allowance for said account. Uses the\n    * internal burn function.\n    * Emits an Approval event (reflecting the reduced allowance).\n    * @param account The account whose tokens will be burnt.\n    * @param value The amount that will be burnt.\n    */\n  function _burnFrom(address account, uint256 value) internal {\n    _burn(account, value);\n    _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n  }\n\n}\n\ncontract ERC20Mock is ERC20 {\n  constructor() public { }\n\n  function mockMint(address _address, uint256 _amount) public {\n    _mint(_address, _amount);\n  }\n\n}\n\n\n'
      },
      'contracts/mocks/ERC20TokenMock.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\nimport "@0xsequence/erc20-meta-token/contracts/mocks/ERC20Mock.sol";\n\ncontract ERC20TokenMock is ERC20Mock {\n\n}'
      },
      'contracts/mocks/ERC1155Mock.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport "@0xsequence/erc-1155/contracts/mocks/ERC1155MintBurnMock.sol";\n\n\ncontract ERC1155Mock is ERC1155MintBurnMock {\n  constructor() ERC1155MintBurnMock("TestERC1155", "") {}\n}'
      },
      'contracts/mocks/ERC20WrapperMock.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.4;\npragma experimental ABIEncoderV2;\nimport "@0xsequence/erc20-meta-token/contracts/wrapper/MetaERC20Wrapper.sol";\n\n\ncontract ERC20WrapperMock is MetaERC20Wrapper {\n\n}'
      }
    },
    settings: {
      optimizer: {
        enabled: true,
        runs: 1650,
        details: {
          yul: true
        }
      },
      outputSelection: {
        '*': {
          '*': ['evm.bytecode', 'evm.deployedBytecode', 'abi']
        }
      }
    }
  }
}
