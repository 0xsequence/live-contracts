import { ContractFactory, type ethers } from 'ethers'
import type { VerificationRequest } from 'scripts/types'

// https://github.com/0xsequence/contracts-library/blob/87eea5e3a8b4c58448b275efe856d4c80891cc8f/src/proxies/TransparentUpgradeableBeaconProxy.sol

const abi = [
  {
    inputs: [],
    name: 'InvalidInitialization',
    type: 'error'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: 'address',
        name: 'previousAdmin',
        type: 'address'
      },
      {
        indexed: false,
        internalType: 'address',
        name: 'newAdmin',
        type: 'address'
      }
    ],
    name: 'AdminChanged',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'address',
        name: 'beacon',
        type: 'address'
      }
    ],
    name: 'BeaconUpgraded',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'address',
        name: 'implementation',
        type: 'address'
      }
    ],
    name: 'Upgraded',
    type: 'event'
  },
  {
    stateMutability: 'payable',
    type: 'fallback'
  },
  {
    stateMutability: 'payable',
    type: 'receive'
  }
]

export class TransparentUpgradeableBeaconProxy extends ContractFactory {
  constructor(signer: ethers.Signer) {
    super(
      abi,
      '0x60808060405234610016576111cf908161001c8239f35b600080fdfe604060808152366103825773ffffffffffffffffffffffffffffffffffffffff807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035416158015610b94576000917fcf7a1d77000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000843516146100c057600484517ff92ee8a9000000000000000000000000000000000000000000000000000000008152fd5b6100c8611192565b60049136831161037e5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261037e578235916101088361067f565b602435926101158461067f565b60443567ffffffffffffffff811161037a57610135839136908801610789565b941692156103525761014791166107e3565b803b156102cf578451907f5c60da1b000000000000000000000000000000000000000000000000000000009384835260209687848381865afa9384156102a657889461019d9189916102b2575b503b1515610926565b7fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d5080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff85161790555194827f1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e8880a28451158015906102ab575b610242575b8361023c6107d0565b80519101f35b8592839182525afa9182156102a65761026a9392610277575b506102646109b1565b91610a21565b5038808083818080610233565b610298919250843d861161029f575b610290818361070e565b810190610902565b903861025b565b503d610286565b61091a565b508661022e565b6102c99150863d881161029f57610290818361070e565b38610194565b60848360208751917f08c379a0000000000000000000000000000000000000000000000000000000008352820152602560248201527f455243313936373a206e657720626561636f6e206973206e6f74206120636f6e60448201527f74726163740000000000000000000000000000000000000000000000000000006064820152fd5b8487517ff92ee8a9000000000000000000000000000000000000000000000000000000008152fd5b8680fd5b8380fd5b73ffffffffffffffffffffffffffffffffffffffff807fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035416158015610b94576000907fcf7a1d77000000000000000000000000000000000000000000000000000000007fffffffff00000000000000000000000000000000000000000000000000000000833516146104395760046040517ff92ee8a9000000000000000000000000000000000000000000000000000000008152fd5b610441611192565b60049236841161067b5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261067b5783356104808161067f565b6024359161048d8361067f565b60443567ffffffffffffffff8111610677576104ad829136908901610789565b9316931561064e576104bf91166107e3565b813b156105ca576040517f5c60da1b000000000000000000000000000000000000000000000000000000009283825260209586838281855afa9283156102a65787936105149188916105b357503b1515610926565b7fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d5080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff841617905560405194827f1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e8880a28451158015906102ab57610242578361023c6107d0565b6102c99150853d871161029f57610290818361070e565b6084846020604051917f08c379a0000000000000000000000000000000000000000000000000000000008352820152602560248201527f455243313936373a206e657720626561636f6e206973206e6f74206120636f6e60448201527f74726163740000000000000000000000000000000000000000000000000000006064820152fd5b856040517ff92ee8a9000000000000000000000000000000000000000000000000000000008152fd5b8580fd5b8280fd5b73ffffffffffffffffffffffffffffffffffffffff81160361069d57565b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6020810190811067ffffffffffffffff8211176106ed57604052565b6106a2565b6040810190811067ffffffffffffffff8211176106ed57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176106ed57604052565b67ffffffffffffffff81116106ed57601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b81601f8201121561069d578035906107a08261074f565b926107ae604051948561070e565b8284526020838301011161069d57816000926020809301838601378301015290565b604051906107dd826106d1565b60008252565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61039081547f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f604080519373ffffffffffffffffffffffffffffffffffffffff9081851686521693846020820152a1811561087e577fffffffffffffffffffffffff000000000000000000000000000000000000000016179055565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f455243313936373a206e65772061646d696e20697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152fd5b9081602091031261069d57516109178161067f565b90565b6040513d6000823e3d90fd5b1561092d57565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603060248201527f455243313936373a20626561636f6e20696d706c656d656e746174696f6e206960448201527f73206e6f74206120636f6e7472616374000000000000000000000000000000006064820152fd5b604051906060820182811067ffffffffffffffff8211176106ed57604052602782527f206661696c6564000000000000000000000000000000000000000000000000006040837f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c60208201520152565b6000806109179493602081519101845af43d15610a60573d91610a438361074f565b92610a51604051948561070e565b83523d6000602085013e610acd565b606091610acd565b15610a6f57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152fd5b91929015610aed5750815115610ae1575090565b610917903b1515610a68565b825190915015610b005750805190602001fd5b604051907f08c379a000000000000000000000000000000000000000000000000000000000825281602080600483015282519283602484015260005b848110610b7d575050507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f836000604480968601015201168101030190fd5b818101830151868201604401528593508201610b3c565b610bee610bd57fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1690565b3303610d14576000357fffffffff00000000000000000000000000000000000000000000000000000000167f3659cfe6000000000000000000000000000000000000000000000000000000008103610c515750610c49610f0f565b602081519101f35b7f4f1ef286000000000000000000000000000000000000000000000000000000008103610c865750610c81611083565b610c49565b7f8f283970000000000000000000000000000000000000000000000000000000008103610cb65750610c81610ec5565b7ff851a440000000000000000000000000000000000000000000000000000000008103610ce65750610c81610dfd565b7f5c60da1b0000000000000000000000000000000000000000000000000000000003610d1457610c81610e53565b610d1c610d3b565b6000808092368280378136915af43d82803e15610d37573d90f35b3d90fd5b73ffffffffffffffffffffffffffffffffffffffff807f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc541680610df8575060206004917fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d505416604051928380927f5c60da1b0000000000000000000000000000000000000000000000000000000082525afa9081156102a657600091610de0575090565b610917915060203d811161029f57610290818361070e565b905090565b610e05611192565b73ffffffffffffffffffffffffffffffffffffffff7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103541660405190602082015260208152610917816106f2565b610e5b611192565b610e63610d3b565b73ffffffffffffffffffffffffffffffffffffffff6040519116602082015260208152610917816106f2565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc602091011261069d576004356109178161067f565b610ecd611192565b3660041161069d57610efc73ffffffffffffffffffffffffffffffffffffffff610ef636610e8f565b166107e3565b604051610f08816106d1565b6000815290565b610f17611192565b3660041161069d5773ffffffffffffffffffffffffffffffffffffffff610f3d36610e8f565b1660405190610f4b826106d1565b60008252803b15610fff577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc817fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055807fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a2815115801590610ff7575b610fe3575b5050604051610f08816106d1565b610fef916102646109b1565b503880610fd5565b506000610fd0565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e7472616374000000000000000000000000000000000000006064820152fd5b3660041161069d5760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261069d576004356110c18161067f565b60243567ffffffffffffffff811161069d576110f673ffffffffffffffffffffffffffffffffffffffff913690600401610789565b9116803b15610fff577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc817fffffffffffffffffffffffff0000000000000000000000000000000000000000825416179055807fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b600080a281511580159061118a57610fe3575050604051610f08816106d1565b506001610fd0565b3461069d5756fea264697066735822122019f840d2ec21d6e6c6d650eef546ce8fd590e6d8042a04516b47dd55a17345c664736f6c63430008130033',
      signer
    )
  }
}

export const TUBPROXY_VERIFICATION: Omit<VerificationRequest, 'waitForSuccess'> = {
  contractToVerify: 'src/proxies/TransparentUpgradeableBeaconProxy.sol:TransparentUpgradeableBeaconProxy',
  version: 'v0.8.19+commit.7dd6d404',
  licenceType: 'Apache-2.0',
  compilerInput: {
    language: 'Solidity',
    sources: {
      'node_modules/@openzeppelin/contracts/interfaces/IERC1967.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.9._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n'
      },
      'node_modules/@openzeppelin/contracts/interfaces/draft-IERC1822.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n'
      },
      'node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.3) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport "../beacon/IBeacon.sol";\nimport "../../interfaces/IERC1967.sol";\nimport "../../interfaces/draft-IERC1822.sol";\nimport "../../utils/Address.sol";\nimport "../../utils/StorageSlot.sol";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256(\'eip1967.proxy.beacon\')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n'
      },
      'node_modules/@openzeppelin/contracts/proxy/Proxy.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
      },
      'node_modules/@openzeppelin/contracts/proxy/beacon/IBeacon.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'
      },
      'node_modules/@openzeppelin/contracts/utils/Address.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n'
      },
      'node_modules/@openzeppelin/contracts/utils/StorageSlot.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n'
      },
      'src/proxies/TransparentUpgradeableBeaconProxy.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.19;\r\n\r\nimport {BeaconProxy, Proxy} from "./openzeppelin/BeaconProxy.sol";\r\nimport {TransparentUpgradeableProxy, ERC1967Proxy} from "./openzeppelin/TransparentUpgradeableProxy.sol";\r\n\r\ninterface ITransparentUpgradeableBeaconProxy {\r\n    function initialize(address admin, address beacon, bytes memory data) external;\r\n}\r\n\r\nerror InvalidInitialization();\r\n\r\n/**\r\n * @dev As the underlying proxy implementation (TransparentUpgradeableProxy) allows the admin to call the implementation,\r\n * care must be taken to avoid proxy selector collisions. Implementation selectors must not conflict with the proxy selectors.\r\n * See https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector clashing].\r\n * The proxy selectors are:\r\n * - 0xcf7a1d77: initialize\r\n * - 0x3659cfe6: upgradeTo (from TransparentUpgradeableProxy)\r\n * - 0x4f1ef286: upgradeToAndCall (from TransparentUpgradeableProxy)\r\n * - 0x8f283970: changeAdmin (from TransparentUpgradeableProxy)\r\n * - 0xf851a440: admin (from TransparentUpgradeableProxy)\r\n * - 0x5c60da1b: implementation (from TransparentUpgradeableProxy)\r\n */\r\ncontract TransparentUpgradeableBeaconProxy is TransparentUpgradeableProxy, BeaconProxy {\r\n    /**\r\n     * Decode the initialization data from the msg.data and call the initialize function.\r\n     */\r\n    function _dispatchInitialize() private returns (bytes memory) {\r\n        _requireZeroValue();\r\n\r\n        (address admin, address beacon, bytes memory data) = abi.decode(msg.data[4:], (address, address, bytes));\r\n        initialize(admin, beacon, data);\r\n\r\n        return "";\r\n    }\r\n\r\n    function initialize(address admin, address beacon, bytes memory data) internal {\r\n        if (_admin() != address(0)) {\r\n            // Redundant call. This function can only be called when the admin is not set.\r\n            revert InvalidInitialization();\r\n        }\r\n        _changeAdmin(admin);\r\n        _upgradeBeaconToAndCall(beacon, data, false);\r\n    }\r\n\r\n    /**\r\n     * @dev If the admin is not set, the fallback function is used to initialize the proxy.\r\n     * @dev If the admin is set, the fallback function is used to delegatecall the implementation.\r\n     */\r\n    function _fallback() internal override (TransparentUpgradeableProxy, Proxy) {\r\n        if (_getAdmin() == address(0)) {\r\n            bytes memory ret;\r\n            bytes4 selector = msg.sig;\r\n            if (selector == ITransparentUpgradeableBeaconProxy.initialize.selector) {\r\n                ret = _dispatchInitialize();\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    return(add(ret, 0x20), mload(ret))\r\n                }\r\n            }\r\n            // When the admin is not set, the fallback function is used to initialize the proxy.\r\n            revert InvalidInitialization();\r\n        }\r\n        TransparentUpgradeableProxy._fallback();\r\n    }\r\n\r\n    /**\r\n     * Returns the current implementation address.\r\n     * @dev This is the implementation address set by the admin, or the beacon implementation.\r\n     */\r\n    function _implementation() internal view override (ERC1967Proxy, BeaconProxy) returns (address) {\r\n        address implementation = ERC1967Proxy._implementation();\r\n        if (implementation != address(0)) {\r\n            return implementation;\r\n        }\r\n        return BeaconProxy._implementation();\r\n    }\r\n}\r\n'
      },
      'src/proxies/openzeppelin/BeaconProxy.sol': {
        content:
          '// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\r\n\r\n// Note: This implementation is an exact copy with the constructor removed, and pragma and imports updated.\r\n\r\npragma solidity ^0.8.19;\r\n\r\nimport "@openzeppelin/contracts/proxy/beacon/IBeacon.sol";\r\nimport "@openzeppelin/contracts/proxy/Proxy.sol";\r\nimport "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";\r\n\r\n/**\r\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\r\n *\r\n * The beacon address is stored in storage slot `uint256(keccak256(\'eip1967.proxy.beacon\')) - 1`, so that it doesn\'t\r\n * conflict with the storage layout of the implementation behind the proxy.\r\n *\r\n * _Available since v3.4._\r\n */\r\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\r\n    /**\r\n     * @dev Returns the current beacon address.\r\n     */\r\n    function _beacon() internal view virtual returns (address) {\r\n        return _getBeacon();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation address of the associated beacon.\r\n     */\r\n    function _implementation() internal view virtual override returns (address) {\r\n        return IBeacon(_getBeacon()).implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\r\n     *\r\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `beacon` must be a contract.\r\n     * - The implementation returned by `beacon` must be a contract.\r\n     */\r\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\r\n        _upgradeBeaconToAndCall(beacon, data, false);\r\n    }\r\n}\r\n'
      },
      'src/proxies/openzeppelin/ERC1967Proxy.sol': {
        content:
          '// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\r\n\r\n// Note: This implementation is an exact copy with the constructor removed, and pragma and imports updated.\r\n\r\npragma solidity ^0.8.19;\r\n\r\nimport "@openzeppelin/contracts/proxy/Proxy.sol";\r\nimport "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol";\r\n\r\n/**\r\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\r\n * implementation address that can be changed. This address is stored in storage in the location specified by\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\r\n * implementation behind the proxy.\r\n */\r\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _implementation() internal view virtual override returns (address impl) {\r\n        return ERC1967Upgrade._getImplementation();\r\n    }\r\n}\r\n'
      },
      'src/proxies/openzeppelin/TransparentUpgradeableProxy.sol': {
        content:
          '// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\r\n\r\n/// @notice This implementation is a copy of OpenZeppelin\'s with the following changes:\r\n/// - Pragma updated\r\n/// - Imports updated\r\n/// - Constructor removed\r\n/// - Allows admin to call implementation\r\n\r\npragma solidity ^0.8.19;\r\n\r\nimport "./ERC1967Proxy.sol";\r\n\r\n/**\r\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\r\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\r\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\r\n * include them in the ABI so this interface must be used to interact with it.\r\n */\r\ninterface ITransparentUpgradeableProxy is IERC1967 {\r\n    function admin() external view returns (address);\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    function changeAdmin(address) external;\r\n\r\n    function upgradeTo(address) external;\r\n\r\n    function upgradeToAndCall(address, bytes memory) external payable;\r\n}\r\n\r\n/**\r\n * @dev This contract implements a proxy that is upgradeable by an admin.\r\n *\r\n * Unlike the original OpenZeppelin implementation, this contract does not prevent the admin from calling the implementation.\r\n * This potentially exposes the admin to a proxy selector attack. See\r\n * https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector clashing].\r\n * When using this contract, you must ensure that the implementation function selectors do not clash with the proxy selectors.\r\n * The proxy selectors are:\r\n * - 0x3659cfe6: upgradeTo\r\n * - 0x4f1ef286: upgradeToAndCall\r\n * - 0x8f283970: changeAdmin\r\n * - 0xf851a440: admin\r\n * - 0x5c60da1b: implementation\r\n *\r\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\r\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\r\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\r\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\r\n * implementation.\r\n *\r\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\r\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\r\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\r\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\r\n */\r\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\r\n    /**\r\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\r\n     *\r\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\r\n     * implementation provides a function with the same selector.\r\n     */\r\n    modifier ifAdmin() {\r\n        if (msg.sender == _getAdmin()) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\r\n     */\r\n    function _fallback() internal virtual override {\r\n        if (msg.sender == _getAdmin()) {\r\n            bytes memory ret;\r\n            bytes4 selector = msg.sig;\r\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\r\n                ret = _dispatchUpgradeTo();\r\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\r\n                ret = _dispatchUpgradeToAndCall();\r\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\r\n                ret = _dispatchChangeAdmin();\r\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\r\n                ret = _dispatchAdmin();\r\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\r\n                ret = _dispatchImplementation();\r\n            } else {\r\n                // Call implementation\r\n                return super._fallback();\r\n            }\r\n            assembly {\r\n                return(add(ret, 0x20), mload(ret))\r\n            }\r\n        } else {\r\n            super._fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\r\n     */\r\n    function _dispatchAdmin() private returns (bytes memory) {\r\n        _requireZeroValue();\r\n\r\n        address admin = _getAdmin();\r\n        return abi.encode(admin);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     *\r\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\r\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\r\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\r\n     */\r\n    function _dispatchImplementation() private returns (bytes memory) {\r\n        _requireZeroValue();\r\n\r\n        address implementation = _implementation();\r\n        return abi.encode(implementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     */\r\n    function _dispatchChangeAdmin() private returns (bytes memory) {\r\n        _requireZeroValue();\r\n\r\n        address newAdmin = abi.decode(msg.data[4:], (address));\r\n        _changeAdmin(newAdmin);\r\n\r\n        return "";\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy.\r\n     */\r\n    function _dispatchUpgradeTo() private returns (bytes memory) {\r\n        _requireZeroValue();\r\n\r\n        address newImplementation = abi.decode(msg.data[4:], (address));\r\n        _upgradeToAndCall(newImplementation, bytes(""), false);\r\n\r\n        return "";\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\r\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\r\n     * proxied contract.\r\n     */\r\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\r\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\r\n        _upgradeToAndCall(newImplementation, data, true);\r\n\r\n        return "";\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     *\r\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\r\n     */\r\n    function _admin() internal view virtual returns (address) {\r\n        return _getAdmin();\r\n    }\r\n\r\n    /**\r\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\r\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\r\n     */\r\n    function _requireZeroValue() internal {\r\n        require(msg.value == 0);\r\n    }\r\n}\r\n'
      }
    },
    settings: {
      evmVersion: 'paris',
      libraries: {},
      metadata: { bytecodeHash: 'ipfs' },
      optimizer: { enabled: true, runs: 20000 },
      remappings: [
        ':@0xsequence/contracts-library/=src/',
        ':@0xsequence/erc-1155/=node_modules/@0xsequence/erc-1155/',
        ':@0xsequence/erc20-meta-token/=node_modules/@0xsequence/erc20-meta-token/',
        ':@openzeppelin/=node_modules/@openzeppelin/',
        ':ds-test/=lib/forge-std/lib/ds-test/src/',
        ':erc721a-upgradeable/=node_modules/erc721a-upgradeable/',
        ':erc721a/=node_modules/erc721a/',
        ':forge-std/=lib/forge-std/src/',
        ':murky/=lib/murky/src/',
        ':openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/'
      ],
      viaIR: true,
      outputSelection: {
        '*': {
          '*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']
        }
      }
    }
  }
}
