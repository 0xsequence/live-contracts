import { ContractFactory, type ethers } from 'ethers'
import type { VerificationRequest } from 'scripts/types'

// https://github.com/0xsequence/contracts-library/blob/1353b8c00c6f496342e5948056842ab9d0f0eb36/src/tokens/ERC721/utility/sale/ERC721SaleFactory.sol

const abi = [
  {
    inputs: [
      {
        internalType: 'address',
        name: 'factoryOwner',
        type: 'address'
      }
    ],
    stateMutability: 'nonpayable',
    type: 'constructor'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: 'address',
        name: 'proxyAddr',
        type: 'address'
      }
    ],
    name: 'ERC721SaleDeployed',
    type: 'event'
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'address',
        name: 'previousOwner',
        type: 'address'
      },
      {
        indexed: true,
        internalType: 'address',
        name: 'newOwner',
        type: 'address'
      }
    ],
    name: 'OwnershipTransferred',
    type: 'event'
  },
  {
    inputs: [],
    name: 'beacon',
    outputs: [
      {
        internalType: 'contract UpgradeableBeacon',
        name: '',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'proxyOwner',
        type: 'address'
      },
      {
        internalType: 'address',
        name: 'tokenOwner',
        type: 'address'
      },
      {
        internalType: 'address',
        name: 'items',
        type: 'address'
      },
      {
        internalType: 'address',
        name: 'implicitModeValidator',
        type: 'address'
      },
      {
        internalType: 'bytes32',
        name: 'implicitModeProjectId',
        type: 'bytes32'
      }
    ],
    name: 'deploy',
    outputs: [
      {
        internalType: 'address',
        name: 'proxyAddr',
        type: 'address'
      }
    ],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'proxyOwner',
        type: 'address'
      },
      {
        internalType: 'address',
        name: 'tokenOwner',
        type: 'address'
      },
      {
        internalType: 'address',
        name: 'items',
        type: 'address'
      },
      {
        internalType: 'address',
        name: 'implicitModeValidator',
        type: 'address'
      },
      {
        internalType: 'bytes32',
        name: 'implicitModeProjectId',
        type: 'bytes32'
      }
    ],
    name: 'determineAddress',
    outputs: [
      {
        internalType: 'address',
        name: 'proxyAddr',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'owner',
    outputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address'
      }
    ],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [],
    name: 'renounceOwnership',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'newOwner',
        type: 'address'
      }
    ],
    name: 'transferOwnership',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'implementation',
        type: 'address'
      }
    ],
    name: 'upgradeBeacon',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function'
  }
]

export class ERC721SaleFactory extends ContractFactory {
  constructor(signer?: ethers.Signer) {
    super(
      abi,
      '60806040523461002f576100196100146100f4565b610161565b610021610034565b612485610387823961248590f35b61003a565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100669061003e565b810190811060018060401b0382111761007e57604052565b610048565b9061009661008f610034565b928361005c565b565b5f80fd5b60018060a01b031690565b6100b09061009c565b90565b6100bc816100a7565b036100c357565b5f80fd5b905051906100d4826100b3565b565b906020828203126100ef576100ec915f016100c7565b90565b610098565b610112616ce88038038061010781610083565b9283398101906100d6565b90565b5f0190565b610122610034565b3d5f823e3d90fd5b90565b61014161013c6101469261009c565b61012a565b61009c565b90565b6101529061012d565b90565b61015e90610149565b90565b6101696101c1565b610171610034565b613a63810181811060018060401b038211176101bc576101998291613a6361280c8439610115565b03905ff09081156101b7576101b06101b592610155565b61025a565b565b61011a565b610048565b6101c96101cb565b565b6101db6101d66102ba565b610327565b565b6101e6906100a7565b9052565b91906101fd905f602085019401906101dd565b565b5f1b90565b9061021560018060a01b03916101ff565b9181191691161790565b6102289061012d565b90565b6102349061021f565b90565b90565b9061024f61024a6102569261022b565b610237565b8254610204565b9055565b610262610034565b90610a79820182811060018060401b038211176102b157829161028c91610a7961626f85396101ea565b03905ff09081156102ac576102a56102aa92600161023a565b610327565b565b61011a565b610048565b5f90565b6102c26102b6565b503390565b5f1c90565b60018060a01b031690565b6102e36102e8916102c7565b6102cc565b90565b6102f590546102d7565b90565b61030190610149565b90565b90565b9061031c610317610323926102f8565b610304565b8254610204565b9055565b6103305f6102eb565b61033a825f610307565b9061036e6103687f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936102f8565b916102f8565b91610377610034565b8061038181610115565b0390a356fe60806040526004361015610013575b6103bc565b61001d5f3561008c565b80631bce45831461008757806359659e9014610082578063715018a61461007d5780638da5cb5b14610078578063c4ceb78914610073578063f2fde38b1461006e5763fa52d8e00361000e57610383565b610350565b610317565b610266565b610211565b6101dc565b6100fd565b60e01c90565b60405190565b5f80fd5b5f80fd5b60018060a01b031690565b6100b4906100a0565b90565b6100c0816100ab565b036100c757565b5f80fd5b905035906100d8826100b7565b565b906020828203126100f3576100f0915f016100cb565b90565b61009c565b5f0190565b3461012b576101156101103660046100da565b6104fa565b61011d610092565b80610127816100f8565b0390f35b610098565b5f91031261013a57565b61009c565b1c90565b60018060a01b031690565b61015e906008610163930261013f565b610143565b90565b90610171915461014e565b90565b61018060015f90610166565b90565b90565b61019a61019561019f926100a0565b610183565b6100a0565b90565b6101ab90610186565b90565b6101b7906101a2565b90565b6101c3906101ae565b9052565b91906101da905f602085019401906101ba565b565b3461020c576101ec366004610130565b6102086101f7610174565b6101ff610092565b918291826101c7565b0390f35b610098565b3461023f57610221366004610130565b610229610555565b610231610092565b8061023b816100f8565b0390f35b610098565b61024d906100ab565b9052565b9190610264905f60208501940190610244565b565b3461029657610276366004610130565b61029261028161058f565b610289610092565b91829182610251565b0390f35b610098565b90565b6102a78161029b565b036102ae57565b5f80fd5b905035906102bf8261029e565b565b919060a083820312610312576102d9815f85016100cb565b926102e782602083016100cb565b9261030f6102f884604085016100cb565b9361030681606086016100cb565b936080016102b2565b90565b61009c565b3461034b5761034761033661032d3660046102c1565b93929092610683565b61033e610092565b91829182610251565b0390f35b610098565b3461037e576103686103633660046100da565b6108a8565b610370610092565b8061037a816100f8565b0390f35b610098565b346103b7576103b36103a26103993660046102c1565b939290926108b3565b6103aa610092565b91829182610251565b0390f35b610098565b5f80fd5b6103d1906103cc610994565b610469565b565b5f1c90565b6103e46103e9916103d3565b610143565b90565b6103f690546103d8565b90565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b90610425906103fd565b810190811067ffffffffffffffff82111761043f57604052565b610407565b60e01b90565b5f91031261045457565b61009c565b610461610092565b3d5f823e3d90fd5b61047b61047660016103ec565b6101ae565b90633659cfe690823b156104f5576104b2926104a75f809461049b610092565b96879586948593610444565b835260048301610251565b03925af180156104f0576104c4575b50565b6104e3905f3d81116104e9575b6104db818361041b565b81019061044a565b5f6104c1565b503d6104d1565b610459565b6103f9565b610503906103c0565b565b61050d610994565b610515610542565b565b90565b61052e61052961053392610517565b610183565b6100a0565b90565b61053f9061051a565b90565b61055361054e5f610536565b610a0f565b565b61055d610505565b565b5f90565b60018060a01b031690565b61057a61057f916103d3565b610563565b90565b61058c905461056e565b90565b61059761055f565b506105a15f610582565b90565b6105ad9061029b565b9052565b6105e66105ed946105dc6060949897956105d2608086019a5f870190610244565b6020850190610244565b6040830190610244565b01906105a4565b565b60200190565b5190565b9061060c610605610092565b928361041b565b565b67ffffffffffffffff811161062c576106286020916103fd565b0190565b610407565b9061064361063e8361060e565b6105f9565b918252565b6106515f610631565b90565b61065c610648565b90565b61066890610186565b90565b6106749061065f565b90565b610680906101a2565b90565b6106e49092919261069261055f565b50836106c284916106b3888a906106a7610092565b958694602086016105b1565b6020820181038252038261041b565b6106d46106ce826105f5565b916105ef565b20906106de610654565b91610bf1565b936106f66106f18661066b565b610677565b906363acc14d93929490823b156107af575f9461073186926107269461071a610092565b998a9889978896610444565b8652600486016105b1565b03925af180156107aa5761077e575b50806107787fe3fc4d8c7984f762222579e0c4564a72a74f96cde3f6bae2751d01108c6ec2409161076f610092565b91829182610251565b0390a190565b61079d905f3d81116107a3575b610795818361041b565b81019061044a565b5f610740565b503d61078b565b610459565b6103f9565b6107c5906107c0610994565b610878565b565b60209181520190565b60207f6464726573730000000000000000000000000000000000000000000000000000917f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201520152565b61082a60266040926107c7565b610833816107d0565b0190565b61084c9060208101905f81830391015261081d565b90565b1561085657565b61085e610092565b62461bcd60e51b81528061087460048201610837565b0390fd5b6108a6906108a18161089a61089461088f5f610536565b6100ab565b916100ab565b141561084f565b610a0f565b565b6108b1906107b4565b565b92916108df610910956108ee936108c861055f565b5092946108d3610092565b958694602086016105b1565b6020820181038252038261041b565b6109006108fa826105f5565b916105ef565b209061090a610654565b91610d2d565b90565b5f7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572910152565b610946602080926107c7565b61094f81610913565b0190565b6109689060208101905f81830391015261093a565b90565b1561097257565b61097a610092565b62461bcd60e51b81528061099060048201610953565b0390fd5b6109be61099f61058f565b6109b86109b26109ad610dc3565b6100ab565b916100ab565b1461096b565b565b5f1b90565b906109d660018060a01b03916109c0565b9181191691161790565b6109e9906101a2565b90565b90565b90610a046109ff610a0b926109e0565b6109ec565b82546109c5565b9055565b610a185f610582565b610a22825f6109ef565b90610a56610a507f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0936109e0565b916109e0565b91610a5f610092565b80610a69816100f8565b0390a3565b90565b610a7d610a829161029b565b610a6e565b9052565b60601b90565b610a9590610a86565b90565b610aa190610a8c565b90565b610ab0610ab5916100ab565b610a98565b9052565b905090565b90825f9392825e0152565b610aee610ae592602092610adc816105f5565b94858093610ab9565b93849101610abe565b0190565b60148093610b16602084610b0e610b1e96610b259b9a98610a71565b018092610aa4565b018092610aa4565b0190610ac9565b90565b90565b610b3f610b3a610b4492610517565b610183565b610b28565b90565b610b5090610186565b90565b610b5c90610b47565b90565b610b6890610186565b90565b610b7490610b5f565b90565b610b80906101a2565b90565b60209181520190565b610bab610bb4602093610bb993610ba2816105f5565b93848093610b83565b95869101610abe565b6103fd565b0190565b610be1610bee949293610bd760608401955f850190610244565b6020830190610244565b6040818403910152610b8c565b90565b610c809093929193610c0161055f565b50610c418591610c32610c1c610c1760016103ec565b6101ae565b8690610c26610092565b95869460208601610af2565b6020820181038252038261041b565b610c53610c4d826105f5565b916105ef565b2061141d610c63602082016105f9565b908082526110336020830139610c7b5f929192610b2b565b610f61565b92610c9a610c95610c9086610b53565b610b6b565b610b77565b63cf7a1d779190610cb3610cae60016103ec565b6101ae565b9392813b15610d28575f610cda91610ce58296610cce610092565b98899788968795610444565b855260048501610bbd565b03925af18015610d2357610cf7575b50565b610d16905f3d8111610d1c575b610d0e818361041b565b81019061044a565b5f610cf4565b503d610d04565b610459565b6103f9565b610dc09291610d6a610d7992610d4161055f565b509193610d56610d5160016103ec565b6101ae565b610d5e610092565b95869460208601610af2565b6020820181038252038261041b565b610d8b610d85826105f5565b916105ef565b2061141d610d9b602082016105f9565b908082526110336020830139610db9610db3826105f5565b916105ef565b2090610fe8565b90565b610dcb61055f565b503390565b610dd9906101a2565b90565b5f7f437265617465323a20696e73756666696369656e742062616c616e6365000000910152565b610e10601d6020926107c7565b610e1981610ddc565b0190565b610e329060208101905f818303910152610e03565b90565b15610e3c57565b610e44610092565b62461bcd60e51b815280610e5a60048201610e1d565b0390fd5b5f7f437265617465323a2062797465636f6465206c656e677468206973207a65726f910152565b610e91602080926107c7565b610e9a81610e5e565b0190565b610eb39060208101905f818303910152610e85565b90565b15610ebd57565b610ec5610092565b62461bcd60e51b815280610edb60048201610e9e565b0390fd5b5f7f437265617465323a204661696c6564206f6e206465706c6f7900000000000000910152565b610f1360196020926107c7565b610f1c81610edf565b0190565b610f359060208101905f818303910152610f06565b90565b15610f3f57565b610f47610092565b62461bcd60e51b815280610f5d60048201610f20565b0390fd5b919091610f6c61055f565b50610f93610f7930610dd0565b31610f8c610f8684610b28565b91610b28565b1015610e35565b610fb8610f9f836105f5565b610fb1610fab5f610b2b565b91610b28565b1415610eb6565b60208251920190f590610fe682610fdf610fd9610fd45f610536565b6100ab565b916100ab565b1415610f38565b565b9061100691610ff561055f565b509061100030610dd0565b91611009565b90565b90605592600b9261101861055f565b50604051926040840152602083015281520160ff8153209056fe608060405234601c57600e6020565b6113f261002b82396113f290f35b6026565b60405190565b5f80fdfe6080604052361561006a5761006a565b90565b60018060a01b031690565b90565b61003461002f6100399261000f565b61001d565b610012565b90565b61004590610020565b90565b61005190610012565b90565b606090565b63ffffffff60e01b1690565b5f0190565b610072610177565b61008c6100866100815f61003c565b610048565b91610048565b0361045757610099610054565b5063ffffffff60e01b5f35166100be6100b863cf7a1d7760e01b610059565b91610059565b146100df575f63f92ee8a960e01b8152806100db60048201610065565b0390fd5b6100e76103ed565b602081519101f35b5f90565b90565b90565b5f1b90565b61011261010d610117926100f3565b6100f9565b6100f6565b90565b6101437fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61036100fe565b90565b5f1c90565b60018060a01b031690565b61016261016791610146565b61014b565b90565b6101749054610156565b90565b61017f6100ef565b5061019a5f61019461018f61011a565b610586565b0161016a565b90565b90565b90565b6101b76101b26101bc9261019d565b61001d565b6101a0565b90565b60405190565b5f80fd5b5f80fd5b909392938483116101ed5784116101e8576001820201920390565b6101c9565b6101c5565b91565b5f80fd5b5f80fd5b61020690610012565b90565b610212816101fd565b0361021957565b5f80fd5b9050359061022a82610209565b565b5f80fd5b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b9061025c90610234565b810190811067ffffffffffffffff82111761027657604052565b61023e565b9061028e6102876101bf565b9283610252565b565b67ffffffffffffffff81116102ae576102aa602091610234565b0190565b61023e565b90825f939282370152565b909291926102d36102ce82610290565b61027b565b938185526020850190828401116102ef576102ed926102b3565b565b610230565b9080601f830112156103125781602061030f933591016102be565b90565b61022c565b916060838303126103635761032e825f850161021d565b9261033c836020830161021d565b92604082013567ffffffffffffffff811161035e5761035b92016102f4565b90565b6101f9565b6101f5565b61037c61037761038192610012565b61001d565b610012565b90565b61038d90610368565b90565b61039990610384565b90565b67ffffffffffffffff81116103ba576103b6602091610234565b0190565b61023e565b906103d16103cc8361039c565b61027b565b918252565b6103df5f6103bf565b90565b6103ea6103d6565b90565b6103f5610054565b506103fe6105b0565b61044c61044261043c61043261042a6104245f3661041c60046101a3565b9080926101cd565b906101f2565b810190610317565b9391929092610390565b91610390565b91909190916105ce565b6104546103e2565b90565b3361047161046b610466610177565b610048565b91610048565b145f1461058157610480610054565b5063ffffffff60e01b5f3516806104a66104a0631b2ce7f360e11b610059565b91610059565b145f146104bf57506104b66107f1565b5b602081519101f35b806104d96104d363278f794360e11b610059565b91610059565b145f146104ef57506104e961079c565b5b6104b7565b806105096105036308f2839760e41b610059565b91610059565b145f1461051f5750610519610700565b5b6104ea565b806105396105336303e1469160e61b610059565b91610059565b145f1461054f575061054961069d565b5b61051a565b610568610562635c60da1b60e01b610059565b91610059565b145f1461057c57610577610658565b61054a565b610629565b610629565b90565b61059d6105986105a29261000f565b61001d565b6101a0565b90565b156105ac57565b5f80fd5b6105cc346105c66105c05f610589565b916101a0565b146105a5565b565b91906105d8610852565b6105f26105ec6105e75f61003c565b610048565b91610048565b0361060d5761060361060b93610889565b905f91610961565b565b5f63f92ee8a960e01b81528061062560048201610065565b0390fd5b610631610a78565b610ab8565b61063f90610048565b9052565b9190610656905f60208501940190610636565b565b610660610054565b506106696105b0565b61068b61069a610677610a78565b61067f6101bf565b92839160208301610643565b60208201810382520382610252565b90565b6106a5610054565b506106ae6105b0565b6106d06106df6106bc610177565b6106c46101bf565b92839160208301610643565b60208201810382520382610252565b90565b906020828203126106fb576106f8915f0161021d565b90565b6101f5565b610708610054565b506107116105b0565b61074c61074761074261073a6107345f3661072c60046101a3565b9080926101cd565b906101f2565b8101906106e2565b610390565b610889565b6107546103e2565b90565b91909160408184031261079757610770835f830161021d565b92602082013567ffffffffffffffff81116107925761078f92016102f4565b90565b6101f9565b6101f5565b6107a4610054565b506107e66107dd6107d66107ce6107c85f366107c060046101a3565b9080926101cd565b906101f2565b810190610757565b9190610390565b90600191610ad6565b6107ee6103e2565b90565b6107f9610054565b506108026105b0565b61084761083861083361082b6108255f3661081d60046101a3565b9080926101cd565b906101f2565b8101906106e2565b610390565b6108406103e2565b5f91610ad6565b61084f6103e2565b90565b61085a6100ef565b50610863610177565b90565b91602061088792949361088060408201965f830190610636565b0190610636565b565b6108d490610895610177565b817f7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f916108cc6108c36101bf565b92839283610866565b0390a1610c16565b565b6108df90610384565b90565b5190565b6108ef90610368565b90565b6108fb906108e6565b90565b61090790610384565b90565b60e01b90565b61091981610048565b0361092057565b5f80fd5b9050519061093182610910565b565b9060208282031261094c57610949915f01610924565b90565b6101f5565b6109596101bf565b3d5f823e3d90fd5b9161096b83610df3565b826109967f1cf3b03a6cf19fa2baba4df148e9dcabedea7f8a5c07840e207e5c089be95d3e916108d6565b9061099f6101bf565b806109a981610065565b0390a26109b5826108e2565b6109c76109c15f610589565b916101a0565b11908115610a70575b506109da575b5050565b60206109f06109eb610a06946108f2565b6108fe565b635c60da1b906109fe6101bf565b94859261090a565b82528180610a1660048201610065565b03915afa908115610a6b57610a33925f92610a3b575b5090610f25565b505f806109d6565b610a5d91925060203d8111610a64575b610a558183610252565b810190610933565b905f610a2c565b503d610a4b565b610951565b90505f6109d0565b610a806100ef565b50610a89610f45565b80610aa4610a9e610a995f61003c565b610048565b91610048565b03610ab55750610ab2610f59565b90565b90565b5f8091368280378136915af43d5f803e5f14610ad2573d5ff35b3d5ffd5b91610ae083610fee565b610ae9826108e2565b610afb610af55f610589565b916101a0565b11908115610b1f575b50610b0e575b5050565b610b1791610f25565b505f80610b0a565b90505f610b04565b60209181520190565b60207f6464726573730000000000000000000000000000000000000000000000000000917f455243313936373a206e65772061646d696e20697320746865207a65726f20615f8201520152565b610b8a6026604092610b27565b610b9381610b30565b0190565b610bac9060208101905f818303910152610b7d565b90565b15610bb657565b610bbe6101bf565b62461bcd60e51b815280610bd460048201610b97565b0390fd5b90610be960018060a01b03916100f9565b9181191691161790565b90565b90610c0b610c06610c12926108d6565b610bf3565b8254610bd8565b9055565b610c5690610c3f81610c38610c32610c2d5f61003c565b610048565b91610048565b1415610baf565b5f610c50610c4b61011a565b610586565b01610bf6565b565b60207f7472616374000000000000000000000000000000000000000000000000000000917f455243313936373a206e657720626561636f6e206973206e6f74206120636f6e5f8201520152565b610cb26025604092610b27565b610cbb81610c58565b0190565b610cd49060208101905f818303910152610ca5565b90565b15610cde57565b610ce66101bf565b62461bcd60e51b815280610cfc60048201610cbf565b0390fd5b60207f73206e6f74206120636f6e747261637400000000000000000000000000000000917f455243313936373a20626561636f6e20696d706c656d656e746174696f6e20695f8201520152565b610d5a6030604092610b27565b610d6381610d00565b0190565b610d7c9060208101905f818303910152610d4d565b90565b15610d8657565b610d8e6101bf565b62461bcd60e51b815280610da460048201610d67565b0390fd5b90565b610dbf610dba610dc492610da8565b6100f9565b6100f6565b90565b610df07fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50610dab565b90565b610e3190610e08610e038261103d565b610cd7565b6020610e1b610e16836108f2565b6108fe565b635c60da1b90610e296101bf565b94859261090a565b82528180610e4160048201610065565b03915afa8015610eaf57610e63610e6891610e7f945f91610e81575b5061103d565b610d7f565b5f610e79610e74610dc7565b610586565b01610bf6565b565b610ea2915060203d8111610ea8575b610e9a8183610252565b810190610933565b5f610e5d565b503d610e90565b610951565b60207f206661696c656400000000000000000000000000000000000000000000000000917f416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c5f8201520152565b610f0b60276103bf565b90610f1860208301610eb4565b565b610f22610f01565b90565b90610f4291610f32610054565b5090610f3c610f1a565b9161109d565b90565b610f4d6100ef565b50610f5661111a565b90565b610f616100ef565b50610f956020610f7f610f7a610f75611140565b6108f2565b6108fe565b635c60da1b90610f8d6101bf565b93849261090a565b82528180610fa560048201610065565b03915afa908115610fe9575f91610fbb575b5090565b610fdc915060203d8111610fe2575b610fd48183610252565b810190610933565b5f610fb7565b503d610fca565b610951565b610ff78161120e565b6110217fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b916108d6565b9061102a6101bf565b8061103481610065565b0390a2565b5f90565b611045611039565b503b6110596110535f610589565b916101a0565b1190565b9061106f61106a83610290565b61027b565b918252565b3d5f1461108f576110843d61105d565b903d5f602084013e5b565b611097610054565b9061108d565b90915f806110cc946110ad610054565b508490602081019051915af4916110c2611074565b90929091926112be565b90565b90565b6110e66110e16110eb926110cf565b6100f9565b6100f6565b90565b6111177f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc6110d2565b90565b6111226100ef565b5061113d5f6111376111326110ee565b610586565b0161016a565b90565b6111486100ef565b506111635f61115d611158610dc7565b610586565b0161016a565b90565b60207f6f74206120636f6e747261637400000000000000000000000000000000000000917f455243313936373a206e657720696d706c656d656e746174696f6e206973206e5f8201520152565b6111c0602d604092610b27565b6111c981611166565b0190565b6111e29060208101905f8183039101526111b3565b90565b156111ec57565b6111f46101bf565b62461bcd60e51b81528061120a600482016111cd565b0390fd5b61123a9061122361121e8261103d565b6111e5565b5f61123461122f6110ee565b610586565b01610bf6565b565b5f7f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000910152565b611270601d602092610b27565b6112798161123c565b0190565b6112929060208101905f818303910152611263565b90565b1561129c57565b6112a46101bf565b62461bcd60e51b8152806112ba6004820161127d565b0390fd5b9192906112c9610054565b505f1461130d57506112da826108e2565b6112ec6112e65f610589565b916101a0565b146112f6575b5090565b6113026113079161103d565b611295565b5f6112f2565b8261136b565b5190565b90825f9392825e0152565b61134161134a60209361134f9361133881611313565b93848093610b27565b95869101611317565b610234565b0190565b6113689160208201915f818403910152611322565b90565b90611375826108e2565b6113876113815f610589565b916101a0565b115f146113975750805190602001fd5b6113b8906113a36101bf565b91829162461bcd60e51b835260048301611353565b0390fdfea26469706673582212209ecaa0b841deba8f11929becdb35117f1c6ccdbd9c9d4b4ed429cd79b7d598d564736f6c634300081b0033a26469706673582212208b3819780b2e8b0d61244d08cc4b6ce7a87247bf8b9f417550339cdc125b174a64736f6c634300081b0033608060405234601c57600e6020565b613a3861002b8239613a3890f35b6026565b60405190565b5f80fdfe60806040526004361015610013575b610b83565b61001d5f3561015c565b806301ffc9a7146101575780630668d0bb146101525780630bb310de1461014d578063248a9ca3146101485780632f2ff15d146101435780633474a4a61461013e57806336568abe1461013957806344004cc1146101345780634782f7791461012f57806363acc14d1461012a5780638c17030f146101255780639010d07c1461012057806391d148541461011b5780639d043a6614610116578063a217fddf14610111578063a971e8421461010c578063bad4366114610107578063ca15c87314610102578063d547741f146100fd5763ed4c2ac70361000e57610b50565b610b1c565b610ae7565b610a8c565b6109f5565b6109c0565b61094f565b610886565b610850565b6107c7565b610709565b61068f565b61062e565b6105c0565b61058b565b610486565b610424565b61038b565b61033d565b6101e8565b60e01c90565b60405190565b5f80fd5b5f80fd5b5f80fd5b63ffffffff60e01b1690565b61018981610174565b0361019057565b5f80fd5b905035906101a182610180565b565b906020828203126101bc576101b9915f01610194565b90565b61016c565b151590565b6101cf906101c1565b9052565b91906101e6905f602085019401906101c6565b565b34610218576102146102036101fe3660046101a3565b610b8b565b61020b610162565b918291826101d3565b0390f35b610168565b60018060a01b031690565b6102319061021d565b90565b61023d81610228565b0361024457565b5f80fd5b9050359061025582610234565b565b90565b61026381610257565b0361026a57565b5f80fd5b9050359061027b8261025a565b565b5f80fd5b5f80fd5b5f80fd5b909182601f830112156102c35781359167ffffffffffffffff83116102be5760200192602083028401116102b957565b610285565b610281565b61027d565b91909160a081840312610333576102e1835f8301610248565b926102ef816020840161026e565b926102fd8260408501610248565b9261030b836060830161026e565b92608082013567ffffffffffffffff811161032e5761032a9201610289565b9091565b610170565b61016c565b5f0190565b61035761034b3660046102c8565b94939093929192610df6565b61035f610162565b8061036981610338565b0390f35b9060208282031261038657610383915f01610248565b90565b61016c565b346103b9576103a361039e36600461036d565b61108e565b6103ab610162565b806103b581610338565b0390f35b610168565b90565b6103ca816103be565b036103d157565b5f80fd5b905035906103e2826103c1565b565b906020828203126103fd576103fa915f016103d5565b90565b61016c565b61040b906103be565b9052565b9190610422905f60208501940190610402565b565b346104545761045061043f61043a3660046103e4565b6110e3565b610447610162565b9182918261040f565b0390f35b610168565b9190604083820312610481578061047561047e925f86016103d5565b93602001610248565b90565b61016c565b346104b55761049f610499366004610459565b9061112d565b6104a7610162565b806104b181610338565b0390f35b610168565b5f9103126104c457565b61016c565b6104d290610257565b9052565b6104df90610228565b9052565b67ffffffffffffffff1690565b6104f9906104e3565b9052565b610506906103be565b9052565b9060a080610574936105225f8201515f8601906104c9565b610534602082015160208601906104c9565b610546604082015160408601906104d6565b610558606082015160608601906104f0565b61056a608082015160808601906104f0565b01519101906104fd565b565b9190610589905f60c0850194019061050a565b565b346105bb5761059b3660046104ba565b6105b76105a661131f565b6105ae610162565b91829182610576565b0390f35b610168565b346105ef576105d96105d3366004610459565b906113e6565b6105e1610162565b806105eb81610338565b0390f35b610168565b90916060828403126106295761062661060f845f8501610248565b9361061d8160208601610248565b9360400161026e565b90565b61016c565b3461065d576106476106413660046105f4565b91611485565b61064f610162565b8061065981610338565b0390f35b610168565b919060408382031261068a578061067e610687925f8601610248565b9360200161026e565b90565b61016c565b346106be576106a86106a2366004610662565b90611586565b6106b0610162565b806106ba81610338565b0390f35b610168565b608081830312610704576106d9825f8301610248565b926107016106ea8460208501610248565b936106f88160408601610248565b936060016103d5565b90565b61016c565b3461073b5761072561071c3660046106c3565b92919091611674565b61072d610162565b8061073781610338565b0390f35b610168565b610749816104e3565b0361075057565b5f80fd5b9050359061076182610740565b565b909160c0828403126107c25761077b835f840161026e565b92610789816020850161026e565b926107978260408301610248565b926107bf6107a88460608501610754565b936107b68160808601610754565b9360a0016103d5565b90565b61016c565b346107fc576107e66107da366004610763565b94939093929192611ac5565b6107ee610162565b806107f881610338565b0390f35b610168565b9190604083820312610829578061081d610826925f86016103d5565b9360200161026e565b90565b61016c565b61083790610228565b9052565b919061084e905f6020850194019061082e565b565b346108815761087d61086c610866366004610801565b90611af2565b610874610162565b9182918261083b565b0390f35b610168565b346108b7576108b36108a261089c366004610459565b90611b30565b6108aa610162565b918291826101d3565b0390f35b610168565b5f80fd5b908160c09103126108ce5790565b6108bc565b908160e09103126108e15790565b6108bc565b9160608383031261094a576108fd825f8501610248565b92602081013567ffffffffffffffff8111610945578361091e9183016108c0565b92604082013567ffffffffffffffff81116109405761093d92016108d3565b90565b610170565b610170565b61016c565b346109805761097c61096b6109653660046108e6565b91611e48565b610973610162565b9182918261040f565b0390f35b610168565b90565b5f1b90565b6109a161099c6109a692610985565b610988565b6103be565b90565b6109b25f61098d565b90565b6109bd6109a9565b90565b346109f0576109d03660046104ba565b6109ec6109db6109b5565b6109e3610162565b9182918261040f565b0390f35b610168565b34610a2557610a053660046104ba565b610a21610a10611ee8565b610a18610162565b9182918261083b565b0390f35b610168565b91608083830312610a8757610a41825f85016103d5565b9260208101359167ffffffffffffffff8311610a8257610a6684610a7f948401610289565b939094610a768160408601610248565b936060016103d5565b90565b610170565b61016c565b34610ac057610abc610aab610aa2366004610a2a565b93929092612020565b610ab3610162565b918291826101d3565b0390f35b610168565b610ace90610257565b9052565b9190610ae5905f60208501940190610ac5565b565b34610b1757610b13610b02610afd3660046103e4565b6120c7565b610b0a610162565b91829182610ad2565b0390f35b610168565b34610b4b57610b35610b2f366004610459565b90612117565b610b3d610162565b80610b4781610338565b0390f35b610168565b34610b7e57610b68610b633660046103e4565b61214b565b610b70610162565b80610b7a81610338565b0390f35b610168565b5f80fd5b5f90565b610b93610b87565b5080610bae610ba8635f05bb8960e11b610174565b91610174565b148015610bd2575b908115610bc2575b5090565b610bcc915061218f565b5f610bbe565b50610bdc81612156565b610bb6565b60081c90565b60018060a01b031690565b610bfe610c0391610be1565b610be7565b90565b610c109054610bf2565b90565b90565b610c2a610c25610c2f9261021d565b610c13565b61021d565b90565b610c3b90610c16565b90565b610c4790610c32565b90565b610c5390610c16565b90565b610c5f90610c4a565b90565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b90610c8e90610c66565b810190811067ffffffffffffffff821117610ca857604052565b610c70565b60e01b90565b90505190610cc08261025a565b565b90602082820312610cdb57610cd8915f01610cb3565b90565b61016c565b610ce8610162565b3d5f823e3d90fd5b5f1c90565b90565b610d04610d0991610cf0565b610cf5565b90565b610d169054610cf8565b90565b610d2d610d28610d3292610985565b610c13565b610257565b90565b634e487b7160e01b5f52601160045260245ffd5b610d58610d5e91939293610257565b92610257565b8201809211610d6957565b610d35565b604090610d97610d9e9496959396610d8d60608401985f850190610ac5565b6020830190610ac5565b0190610ac5565b565b610da990610c16565b90565b610db590610da0565b90565b610dc190610c4a565b90565b5f910312610dce57565b61016c565b916020610df4929493610ded60408201965f83019061082e565b0190610ac5565b565b93610e09939591958693909192936122cd565b610e3e6020610e28610e23610e1e6005610c06565b610c3e565b610c56565b6318160ddd90610e36610162565b938492610cad565b82528180610e4e60048201610338565b03915afa908115610fd3575f91610fa5575b50610e6d5f600601610d0c565b9081610e81610e7b5f610d19565b91610257565b1180610f81575b610f61575050610ea8610ea3610e9e6005610c06565b610dac565b610db8565b6340c10f19828492803b15610f5c57610ed45f8094610edf610ec8610162565b97889687958694610cad565b845260048401610dd3565b03925af18015610f5757610f2b575b50907ff32d98590495ee51bacb93809409a188e7ab8268b70b4c969d9da3a883c539f791610f26610f1d610162565b92839283610dd3565b0390a1565b610f4a905f3d8111610f50575b610f428183610c84565b810190610dc4565b5f610eee565b503d610f38565b610ce0565b610c62565b610f7d84925f938493630a92278360e41b855260048501610d6e565b0390fd5b50610f8d818590610d49565b610f9f610f9984610257565b91610257565b11610e88565b610fc6915060203d8111610fcc575b610fbe8183610c84565b810190610cc2565b5f610e60565b503d610fb4565b610ce0565b7f70649ec320b507febad3e8ef750e5f580b9ae32f9f50d4c7b121332c8197153090565b6110159061101061100b610fd8565b6124b2565b611079565b565b61102090610c16565b90565b61102c90611017565b90565b9061104060018060a01b0391610988565b9181191691161790565b61105390611017565b90565b90565b9061106e6110696110759261104a565b611056565b825461102f565b9055565b61108561108c91611023565b6003611059565b565b61109790610ffc565b565b5f90565b6110a6906103be565b90565b906110b39061109d565b5f5260205260405f2090565b90565b6110ce6110d391610cf0565b6110bf565b90565b6110e090546110c2565b90565b60016110fb611101926110f4611099565b505f6110a9565b016110d6565b90565b9061111f9161111a611115826110e3565b6124b2565b611121565b565b9061112b916124c6565b565b9061113791611104565b565b9061114c611145610162565b9283610c84565b565b61115860c0611139565b90565b5f90565b5f90565b5f90565b5f90565b61117361114e565b90602080808080808761118461115b565b81520161118f61115b565b81520161119a61115f565b8152016111a5611163565b8152016111b0611163565b8152016111bb611167565b81525050565b6111c961116b565b90565b906111d690610257565b9052565b6111e66111eb91610cf0565b610be7565b90565b6111f890546111da565b90565b9061120590610228565b9052565b60a01c90565b67ffffffffffffffff1690565b61122861122d91611209565b61120f565b90565b61123a905461121c565b90565b90611247906104e3565b9052565b61125761125c91610cf0565b61120f565b90565b611269905461124b565b90565b90611276906103be565b9052565b90611311611308600461128b61114e565b946112a261129a5f8301610d0c565b5f88016111cc565b6112ba6112b160018301610d0c565b602088016111cc565b6112d26112c9600283016111ee565b604088016111fb565b6112ea6112e160028301611230565b6060880161123d565b6113026112f96003830161125f565b6080880161123d565b016110d6565b60a0840161126c565b565b61131c9061127a565b90565b6113276111c1565b506113326006611313565b90565b60209181520190565b60207f20726f6c657320666f722073656c660000000000000000000000000000000000917f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e63655f8201520152565b611398602f604092611335565b6113a18161133e565b0190565b6113ba9060208101905f81830391015261138b565b90565b156113c457565b6113cc610162565b62461bcd60e51b8152806113e2600482016113a5565b0390fd5b906114139161140e826114086114026113fd6124f0565b610228565b91610228565b146113bd565b6124fd565b565b7f5d8e12c39142ff96d79d04d15d1ba1269e4fe57bb9d26f43523628b34ba108ec90565b90611454929161144f61144a611415565b6124b2565b61146e565b565b61145f90610c16565b90565b61146b90611456565b90565b9161147b61148393611462565b919091612558565b565b906114909291611439565b565b906114ac916114a76114a2611415565b6124b2565b611536565b565b905090565b6114be5f80926114ae565b0190565b6114cb906114b3565b90565b67ffffffffffffffff81116114ec576114e8602091610c66565b0190565b610c70565b906115036114fe836114ce565b611139565b918252565b606090565b3d5f146115285761151d3d6114f1565b903d5f602084013e5b565b611530611508565b90611526565b5f61156492819290611546610162565b9081611551816114c2565b03925af161155d61150d565b50156101c1565b61156a57565b5f631d42c86760e21b81528061158260048201610338565b0390fd5b9061159091611492565b565b60ff1690565b6115a46115a991610cf0565b611592565b90565b6115b69054611598565b90565b60081b90565b906115d2610100600160a81b03916115b9565b9181191691161790565b6115e590610c4a565b90565b90565b906116006115fb611607926115dc565b6115e8565b82546115bf565b9055565b7f4c02318d8c3aadc98ccf18aebbf3126f651e0c3f6a1de5ff8edcf6724a2ad5c290565b9061163b60ff91610988565b9181191691161790565b61164e906101c1565b90565b90565b9061166961166461167092611645565b611651565b825461162f565b9055565b92909261168160056115ac565b6116df576116936116d19460056115eb565b6116a561169e6109a9565b82906124c6565b6116b76116b061160b565b82906124c6565b6116c96116c2611415565b82906124c6565b9190916125a3565b6116dd60016005611654565b565b5f63f92ee8a960e01b8152806116f760048201610338565b0390fd5b90611719959493929161171461170f61160b565b6124b2565b6119c6565b565b61172f61172a611734926104e3565b610c13565b610257565b90565b61174160c0611139565b90565b61174e9051610257565b90565b9061175d5f1991610988565b9181191691161790565b61177b61177661178092610257565b610c13565b610257565b90565b90565b9061179b6117966117a292611767565b611783565b8254611751565b9055565b6117b09051610228565b90565b906117c86117c36117cf926115dc565b6115e8565b825461102f565b9055565b6117dd90516104e3565b90565b60a01b90565b906117fc67ffffffffffffffff60a01b916117e0565b9181191691161790565b61181a61181561181f926104e3565b610c13565b6104e3565b90565b90565b9061183a61183561184192611806565b611822565b82546117e6565b9055565b9061185867ffffffffffffffff91610988565b9181191691161790565b9061187761187261187e92611806565b611822565b8254611845565b9055565b61188c90516103be565b90565b61189890610cf0565b90565b906118b06118ab6118b79261109d565b61188f565b8254611751565b9055565b9061194a60a06004611950946118de5f82016118d85f8801611744565b90611786565b6118f7600182016118f160208801611744565b90611786565b6119106002820161190a604088016117a6565b906117b3565b61192960028201611923606088016117d3565b90611825565b6119426003820161193c608088016117d3565b90611862565b019201611882565b9061189b565b565b9061195c916118bb565b565b611967906104e3565b9052565b91946119b36119bd929897956119a960a09661199f6119c49a61199560c08a019e5f8b0190610ac5565b6020890190610ac5565b604087019061082e565b606085019061195e565b608083019061195e565b0190610402565b565b9193909294816119de6119d8886104e3565b916104e3565b108015611aaa575b611a8e5782611a50611a8994611a4987611a408a611a378d611a2e8b93611a258c97611a1c611a13611737565b9b5f8d016111cc565b60208b016111cc565b604089016111fb565b6060870161123d565b6080850161123d565b60a0830161126c565b6006611952565b9394959190917fabec13ca1773eed55d54d2f64593c33fa520ee45cac73a162f13928a2ebee23396611a80610162565b9687968761196b565b0390a1565b5f6310ba94e960e31b815280611aa660048201610338565b0390fd5b5081611abe611ab842610257565b9161171b565b11156119e6565b90611ad395949392916116fb565b565b5f90565b90611ae39061109d565b5f5260205260405f2090565b90565b90611b12611b0d611b1793611b05611ad5565b506001611ad9565b611aef565b6125f3565b90565b90611b24906115dc565b5f5260205260405f2090565b611b56915f611b4b611b5193611b44610b87565b50826110a9565b01611b1a565b6115ac565b90565b60018060a01b031690565b611b70611b7591610cf0565b611b59565b90565b611b829054611b64565b90565b611b8e90610c4a565b90565b90505190611b9e826103c1565b565b90602082820312611bb957611bb6915f01611b91565b90565b61016c565b50611bcd906020810190610248565b90565b50611bdf906020810190610194565b90565b611beb90610174565b9052565b50611bfe9060208101906103d5565b90565b5f80fd5b5f80fd5b5f80fd5b9035600160200382360303811215611c4e57016020813591019167ffffffffffffffff8211611c49576001820236038313611c4457565b611c05565b611c01565b611c09565b60209181520190565b90825f939282370152565b9190611c8181611c7a81611c8695611c53565b8095611c5c565b610c66565b0190565b9035600160400382360303811215611ca0570190565b611c09565b9035600160200382360303811215611ce657016020813591019167ffffffffffffffff8211611ce1576001820236038313611cdc57565b611c05565b611c01565b611c09565b60209181520190565b9190611d0e81611d0781611d1395611ceb565b8095611c5c565b610c66565b0190565b50611d26906020810190610754565b90565b90611d65906020611d5d611d5360408401611d465f880188611ca5565b908683035f880152611cf4565b9482810190611d17565b9101906104f0565b90565b611e1091611e02611df760c08301611d8e611d855f870187611bbe565b5f8601906104d6565b611da8611d9e6020870187611bd0565b6020860190611be2565b611dc2611db86040870187611bef565b60408601906104fd565b611ddc611dd26060870187611bef565b60608601906104fd565b611de96080860186611c0d565b908583036080870152611c67565b9260a0810190611c8a565b9060a0818403910152611d29565b90565b939290611e3e604091611e4694611e3160608901925f8a019061082e565b8782036020890152611d68565b940190610402565b565b9150602090611e55611099565b50611e68611e636003611b78565b611b85565b611e94633808a90b949294611e9f611e8060046110d6565b611e88610162565b97889687958695610cad565b855260048501611e13565b03915afa908115611ee3575f91611eb5575b5090565b611ed6915060203d8111611edc575b611ece8183610c84565b810190611ba0565b5f611eb1565b503d611ec4565b610ce0565b611ef0611ad5565b50611efb6005610c06565b90565b90611f08906115dc565b5f5260205260405f2090565b90611f1e9061109d565b5f5260205260405f2090565b60601b90565b611f3990611f2a565b90565b611f4590611f30565b90565b611f54611f5991610228565b611f3c565b9052565b90565b611f6c611f71916103be565b611f5d565b9052565b601481611f88611f909360209695611f48565b018092611f60565b0190565b60200190565b5190565b67ffffffffffffffff8111611fb65760208091020190565b610c70565b90929192611fd0611fcb82611f9e565b611139565b938185526020808601920283019281841161200d57915b838310611ff45750505050565b6020809161200284866103d5565b815201920191611fe7565b610285565b61201d913691611fbb565b90565b909392919261202d610b87565b5061205561204f61204a61204360028790611efe565b8590611f14565b6115ac565b156101c1565b9485612064575b505050505090565b6120b995509061209b6120b4939295929461208c612080610162565b93849260208401611f75565b60208201810382520382610c84565b6120ad6120a782611f9a565b91611f94565b2093612012565b61262b565b5f8080808061205c565b5f90565b6120e66120e16120eb926120d96120c3565b506001611ad9565b611aef565b612655565b90565b90612109916121046120ff826110e3565b6124b2565b61210b565b565b90612115916124fd565b565b90612121916120ee565b565b61213c90612137612132610fd8565b6124b2565b61213e565b565b61214990600461189b565b565b61215490612123565b565b61215e610b87565b508061217261216c5f610174565b91610174565b1490811561217f575b5090565b6121899150612674565b5f61217b565b612197610b87565b506121a181612674565b9081156121ad575b5090565b6121b791506126b4565b5f6121a9565b5f90565b6121d06121d691939293610257565b92610257565b916121e2838202610257565b9281840414901517156121f157565b610d35565b6121ff90610d19565b9052565b60409061222c612233949695939661222260608401985f85019061082e565b6020830190610ac5565b01906121f6565b565b60409061225e612265949695939661225460608401985f85019061082e565b6020830190610ac5565b0190610ac5565b565b61227b61227661228092610985565b610c13565b61021d565b90565b61228c90612267565b90565b61229890610c4a565b90565b6040906122c46122cb94969593966122ba60608401985f85019061082e565b60208301906121f6565b0190610ac5565b565b909291936123066122e16002600601611230565b6123006122fa6122f4600360060161125f565b9261171b565b9161171b565b906126f4565b61249657612343926123319161231f60046006016110d6565b9190339161232b6121bd565b936127e8565b61233e6001600601610d0c565b6121c1565b918161236361235d61235860026006016111ee565b610228565b91610228565b03612469578061237b61237585610257565b91610257565b1061244757508061239c6123966123915f612283565b610228565b91610228565b145f146123df57346123b66123b084610257565b91610257565b036123c05750505b565b6123db345f938493630f55e7df60e11b855260048501612235565b0390fd5b90346123f36123ed5f610d19565b91610257565b115f14612424576124035f612283565b5f90612420345f938493630f55e7df60e11b85526004850161229b565b0390fd5b61243061244292611462565b903361243b3061228f565b91926128b9565b6123be565b826124658391925f938493630f55e7df60e11b855260048501612235565b0390fd5b8261247760026006016111ee565b6124925f5f938493630f55e7df60e11b855260048501612203565b0390fd5b5f630fe219dd60e21b8152806124ae60048201610338565b0390fd5b6124c4906124be6124f0565b90612a58565b565b906124e86124e36124ed936124dc818590612af1565b6001611ad9565b611aef565b612bd6565b50565b6124f8611ad5565b503390565b9061251f61251a61252493612513818590612c10565b6001611ad9565b611aef565b612ca7565b50565b61253090610c4a565b90565b63ffffffff1690565b61255061254b61255592612533565b610cad565b610174565b90565b9161259c60049261258d6125a1959361257463a9059cbb61253c565b9261257d610162565b9687946020860190815201610dd3565b60208201810382520383610c84565b612e4f565b565b906125b96125be93926125b4610fd8565b6124c6565b612ebb565b565b90565b6125cf6125d491610cf0565b611767565b90565b6125eb6125e66125f092610257565b610c13565b61021d565b90565b61261e612619612628936126145f6126239561260d611ad5565b50016125c0565b612f4e565b6125c3565b6125d7565b610c4a565b90565b612645612651929361264b9261263f610b87565b50612fa2565b926103be565b916103be565b1490565b61266c5f612671926126656120c3565b50016125c0565b61300c565b90565b61267c610b87565b5080612697612691635a05180f60e01b610174565b91610174565b149081156126a4575b5090565b6126ae9150613023565b5f6126a0565b6126bc610b87565b50806126d76126d1634e821d3360e11b610174565b91610174565b149081156126e4575b5090565b6126ee9150612156565b5f6126e0565b6126fc610b87565b508161271061270a5f610d19565b91610257565b14908115612743575b50908115612726575b5090565b905061273b6127354292610257565b91610257565b10155f612722565b90506127586127524292610257565b91610257565b105f612719565b60209181520190565b5f80fd5b9037565b90918261277c9161275f565b9160018060fb1b03811161279f578291602061279b920293849161276c565b0190565b612768565b906127d46127df916127e6969897956060956127c760808701935f880190610402565b8583036020870152612770565b96604083019061082e565b0190610402565b565b9293836128056127ff6127fa5f61098d565b6103be565b916103be565b03612812575b5050505050565b61282a61282485848689918693612020565b156101c1565b61285a575050509061284b612850926128466001936002611efe565b611f14565b611654565b5f8080808061280b565b846128839185939491909161286d610162565b9586956304cb8cd560e31b8752600487016127a4565b0390fd5b6040906128b06128b794969593966128a660608401985f85019061082e565b602083019061082e565b0190610ac5565b565b61290693916128f260049461290193946128d66323b872dd61253c565b939190916128e2610162565b9788956020870190815201612887565b60208201810382520383610c84565b612e4f565b565b90565b61291f61291a61292492612908565b610c13565b610257565b90565b905090565b5f7f416363657373436f6e74726f6c3a206163636f756e7420000000000000000000910152565b61295f60178092612927565b6129688161292c565b0190565b5190565b90825f9392825e0152565b6129a06129979260209261298e8161296c565b94858093612927565b93849101612970565b0190565b5f7f206973206d697373696e6720726f6c6520000000000000000000000000000000910152565b6129d760118092612927565b6129e0816129a4565b0190565b6129fe612a0993926129f8612a0393612953565b9061297b565b6129cb565b9061297b565b90565b90565b612a2e612a37602093612a3c93612a258161296c565b93848093611335565b95869101612970565b610c66565b0190565b612a559160208201915f818403910152612a0f565b90565b90612a6d612a67838390611b30565b156101c1565b612a75575050565b612aed91612acb612aa4612a94612a8e612ad0956130b6565b936125c3565b612a9e602061290b565b906132b1565b91612abc612ab0610162565b938492602084016129e4565b60208201810382520382610c84565b612a0c565b612ad8610162565b91829162461bcd60e51b835260048301612a40565b0390fd5b612b05612aff828490611b30565b156101c1565b612b0e575b5050565b612b2f6001612b2a5f612b228186906110a9565b018590611b1a565b611654565b90612b386124f0565b90612b75612b6f612b697f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d9561109d565b926115dc565b926115dc565b92612b7e610162565b80612b8881610338565b0390a45f80612b0a565b612b9b90610c16565b90565b612bb2612bad612bb79261021d565b610c13565b610257565b90565b612bce612bc9612bd392610257565b610988565b6103be565b90565b90612c08612c02612bfd612bf85f612c0d96612bf0610b87565b500194612b92565b612b9e565b612bba565b916125c0565b6134c6565b90565b612c1b818390611b30565b612c24575b5050565b612c445f612c3f5f612c378186906110a9565b018590611b1a565b611654565b90612c4d6124f0565b90612c8a612c84612c7e7ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9561109d565b926115dc565b926115dc565b92612c93610162565b80612c9d81610338565b0390a45f80612c20565b90612cd9612cd3612cce612cc95f612cde96612cc1610b87565b500194612b92565b612b9e565b612bba565b916125c0565b6135db565b90565b67ffffffffffffffff8111612cff57612cfb602091610c66565b0190565b610c70565b90612d16612d1183612ce1565b611139565b918252565b5f7f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564910152565b612d4c6020612d04565b90612d5960208301612d1b565b565b612d63612d42565b90565b612d6f816101c1565b03612d7657565b5f80fd5b90505190612d8782612d66565b565b90602082820312612da257612d9f915f01612d7a565b90565b61016c565b60207f6f74207375636365656400000000000000000000000000000000000000000000917f5361666545524332303a204552433230206f7065726174696f6e20646964206e5f8201520152565b612e01602a604092611335565b612e0a81612da7565b0190565b612e239060208101905f818303910152612df4565b90565b15612e2d57565b612e35610162565b62461bcd60e51b815280612e4b60048201612e0e565b0390fd5b612e9891612e5f612e6e92612527565b90612e68612d5b565b916136e1565b612e7781611f9a565b612e89612e835f610d19565b91610257565b14908115612e9a575b50612e26565b565b612eb591506020612eaa82611f9a565b818301019101612d89565b5f612e92565b90612ed2612ecb612ed993611023565b6003611059565b600461189b565b565b634e487b7160e01b5f52603260045260245ffd5b5490565b5f5260205f2090565b612f0581612eef565b821015612f1f57612f17600191612ef3565b910201905f90565b612edb565b1c90565b612f38906008612f3d9302612f24565b6110bf565b90565b90612f4b9154612f28565b90565b612f6c915f612f6692612f5f611099565b5001612efc565b90612f40565b90565b6001612f7b9101610257565b90565b5190565b90612f8c82612f7e565b811015612f9d576020809102010190565b612edb565b9190612fac611099565b50612fb65f610d19565b905b81612fd3612fcd612fc887612f7e565b610257565b91610257565b101561300557612ff9612fff91612ff3612fee878690612f82565b611882565b90613703565b91612f6f565b90612fb8565b9192505090565b5f613020916130196120c3565b5001612eef565b90565b61302b610b87565b5080613046613040637965db0b60e01b610174565b91610174565b14908115613053575b5090565b61305d9150613742565b5f61304f565b606090565b90565b60ff1690565b61308561308061308a92613068565b610c13565b61306b565b90565b6130976014613071565b90565b6130ae6130a96130b39261306b565b610c13565b610257565b90565b6130d36130ce6130e9926130c8613063565b50612b92565b612b9e565b6130e36130de61308d565b61309a565b906132b1565b90565b90565b6131036130fe613108926130ec565b610c13565b610257565b90565b369037565b9061313561311d836114f1565b9260208061312b86936114ce565b920191039061310b565b565b600360fc1b90565b9061314982611f9a565b81101561315b57600160209102010190565b612edb565b600f60fb1b90565b90565b61317f61317a61318492613168565b610c13565b610257565b90565b61319090610257565b5f811461319e576001900390565b610d35565b6f181899199a1a9b1b9c1cb0b131b232b360811b90565b6131c26131a3565b90565b90565b6131dc6131d76131e1926131c5565b610c13565b610257565b90565b60f81b90565b90565b6132016131fc613206926131ea565b610c13565b61306b565b90565b6132289061322261321c61322d9461306b565b91610257565b90612f24565b610257565b90565b5f7f537472696e67733a20686578206c656e67746820696e73756666696369656e74910152565b61326360208092611335565b61326c81613230565b0190565b6132859060208101905f818303910152613257565b90565b1561328f57565b613297610162565b62461bcd60e51b8152806132ad60048201613270565b0390fd5b91906132bb613063565b506133526133426132f16132ec6132dc60026132d787916130ef565b6121c1565b6132e660026130ef565b90610d49565b613110565b926132fa613137565b6133118561330b5f935f1a93610d19565b9061313f565b5361331a613160565b6133328561332c6001935f1a9361316b565b9061313f565b5361333d60026130ef565b6121c1565b61334c600161316b565b90610d49565b925b83613368613362600161316b565b91610257565b11156133ce576133766131ba565b81613381600f6131c8565b169160108310156133c95761339d6133bd926133c3941a6131e4565b6133ac859188905f1a9261313f565b536133b760046131ed565b90613209565b93613187565b92613354565b612edb565b6133f59293506133f0906133ea6133e45f610d19565b91610257565b14613288565b612a0c565b90565b90565b5f5260205f2090565b5490565b61341181613404565b82101561342b576134236001916133fb565b910201905f90565b612edb565b1b90565b9190600861344f9102916134495f1984613430565b92613430565b9181191691161790565b919061346f61346a6134779361109d565b61188f565b908354613434565b9055565b90815491680100000000000000008310156134ab57826134a39160016134a995018155613408565b90613459565b565b610c70565b906134ba9061109d565b5f5260205260405f2090565b6134ce610b87565b506134e36134dd828490613768565b156101c1565b5f146135235761351961351e926135056134fe5f85016133f8565b829061347b565b60016135125f8501612eef565b93016134b0565b611786565b600190565b50505f90565b61353861353e91939293610257565b92610257565b820391821161354957565b610d35565b634e487b7160e01b5f52603160045260245ffd5b6135749161356e611099565b91613459565b565b61357f81613404565b80156135a057600190039061359d6135978383613408565b90613562565b55565b61354e565b91906135bb6135b66135c393611767565b611783565b908354613434565b9055565b6135d9916135d36120c3565b916135a5565b565b6135e3610b87565b506135fa6135f56001830184906134b0565b610d0c565b908161360e6136085f610d19565b91610257565b14155f146136da5761368c92600161368792846136355f9661362f8561316b565b90613529565b613652613643888501612eef565b61364c8661316b565b90613529565b8061366561365f84610257565b91610257565b03613691575b50505061368161367c8683016133f8565b613576565b016134b0565b6135c7565b600190565b6136d2926136c46136b06136aa6136cd948c8901612efc565b90612f40565b936136be85918c8901612efc565b90613459565b918585016134b0565b611786565b5f808061366b565b5050505f90565b9061370092916136ef611508565b50906136fa5f610d19565b91613851565b90565b61370b611099565b508061371f613719846103be565b916103be565b105f146137345790613730916138aa565b5b90565b61373d916138aa565b613731565b61374a610b87565b5061376461375e6301ffc9a760e01b610174565b91610174565b1490565b6137869160016137819261377a610b87565b50016134b0565b610d0c565b6137986137925f610d19565b91610257565b141590565b6137a690610c4a565b90565b60207f722063616c6c0000000000000000000000000000000000000000000000000000917f416464726573733a20696e73756666696369656e742062616c616e636520666f5f8201520152565b6138036026604092611335565b61380c816137a9565b0190565b6138259060208101905f8183039101526137f6565b90565b1561382f57565b613837610162565b62461bcd60e51b81528061384d60048201613810565b0390fd5b915f80916138a79593613862611508565b5061388961386f3061379d565b3161388261387c85610257565b91610257565b1015613828565b8591602082019151925af19161389d61150d565b9092909192613941565b90565b6138b2611099565b505f5260205260405f2090565b5f7f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000910152565b6138f3601d602092611335565b6138fc816138bf565b0190565b6139159060208101905f8183039101526138e6565b90565b1561391f57565b613927610162565b62461bcd60e51b81528061393d60048201613900565b0390fd5b91929061394c611508565b505f14613990575061395d82611f9a565b61396f6139695f610d19565b91610257565b14613979575b5090565b61398561398a916139e2565b613918565b5f613975565b829061399b82611f9a565b6139ad6139a75f610d19565b91610257565b115f146139bd5750805190602001fd5b6139de906139c9610162565b91829162461bcd60e51b835260048301612a40565b0390fd5b6139ea610b87565b503b6139fe6139f85f610d19565b91610257565b119056fea264697066735822122030e9c5f5a9633f4ebee30fc3dda4406b14283dcf8cc6336572516eab3e14241d64736f6c634300081b003360806040523461002f576100196100146100f4565b610115565b610021610034565b610709610370823961070990f35b61003a565b60405190565b5f80fd5b601f801991011690565b634e487b7160e01b5f52604160045260245ffd5b906100669061003e565b810190811060018060401b0382111761007e57604052565b610048565b9061009661008f610034565b928361005c565b565b5f80fd5b60018060a01b031690565b6100b09061009c565b90565b6100bc816100a7565b036100c357565b5f80fd5b905051906100d4826100b3565b565b906020828203126100ef576100ec915f016100c7565b90565b610098565b610112610a798038038061010781610083565b9283398101906100d6565b90565b61012690610121610128565b610265565b565b610138610133610287565b6102ca565b565b60209181520190565b60207f6e206973206e6f74206120636f6e747261637400000000000000000000000000917f5570677261646561626c65426561636f6e3a20696d706c656d656e746174696f5f8201520152565b61019d603360409261013a565b6101a681610143565b0190565b6101bf9060208101905f818303910152610190565b90565b156101c957565b6101d1610034565b62461bcd60e51b8152806101e7600482016101aa565b0390fd5b5f1b90565b9061020160018060a01b03916101eb565b9181191691161790565b90565b61022261021d6102279261009c565b61020b565b61009c565b90565b6102339061020e565b90565b61023f9061022a565b90565b90565b9061025a61025561026192610236565b610242565b82546101f0565b9055565b6102819061027a6102758261034f565b6101c2565b6001610245565b565b5f90565b61028f610283565b503390565b5f1c90565b60018060a01b031690565b6102b06102b591610294565b610299565b90565b6102c290546102a4565b90565b5f0190565b6102d35f6102b8565b6102dd825f610245565b9061031161030b7f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093610236565b91610236565b9161031a610034565b80610324816102c5565b0390a3565b5f90565b90565b90565b61034761034261034c92610330565b61020b565b61032d565b90565b610357610329565b503b61036b6103655f610333565b9161032d565b119056fe60806040526004361015610013575b610211565b61001d5f3561006c565b80633659cfe6146100675780635c60da1b14610062578063715018a61461005d5780638da5cb5b146100585763f2fde38b0361000e576101de565b6101a9565b610176565b610141565b6100dd565b60e01c90565b60405190565b5f80fd5b5f80fd5b60018060a01b031690565b61009490610080565b90565b6100a08161008b565b036100a757565b5f80fd5b905035906100b882610097565b565b906020828203126100d3576100d0915f016100ab565b90565b61007c565b5f0190565b3461010b576100f56100f03660046100ba565b6102aa565b6100fd610072565b80610107816100d8565b0390f35b610078565b5f91031261011a57565b61007c565b6101289061008b565b9052565b919061013f905f6020850194019061011f565b565b3461017157610151366004610110565b61016d61015c6102ea565b610164610072565b9182918261012c565b0390f35b610078565b346101a457610186366004610110565b61018e610350565b610196610072565b806101a0816100d8565b0390f35b610078565b346101d9576101b9366004610110565b6101d56101c461035a565b6101cc610072565b9182918261012c565b0390f35b610078565b3461020c576101f66101f13660046100ba565b610463565b6101fe610072565b80610208816100d8565b0390f35b610078565b5f80fd5b610226906102216104ef565b61025f565b565b90565b61023f61023a61024492610080565b610228565b610080565b90565b6102509061022b565b90565b61025c90610247565b90565b61026881610606565b6102927fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b91610253565b9061029b610072565b806102a5816100d8565b0390a2565b6102b390610215565b565b5f90565b5f1c90565b60018060a01b031690565b6102d56102da916102b9565b6102be565b90565b6102e790546102c9565b90565b6102f26102b5565b506102fd60016102dd565b90565b6103086104ef565b61031061033d565b565b90565b61032961032461032e92610312565b610228565b610080565b90565b61033a90610315565b90565b61034e6103495f610331565b610624565b565b610358610300565b565b6103626102b5565b5061036c5f6102dd565b90565b6103809061037b6104ef565b610433565b565b60209181520190565b60207f6464726573730000000000000000000000000000000000000000000000000000917f4f776e61626c653a206e6577206f776e657220697320746865207a65726f20615f8201520152565b6103e56026604092610382565b6103ee8161038b565b0190565b6104079060208101905f8183039101526103d8565b90565b1561041157565b610419610072565b62461bcd60e51b81528061042f600482016103f2565b0390fd5b6104619061045c8161045561044f61044a5f610331565b61008b565b9161008b565b141561040a565b610624565b565b61046c9061036f565b565b5f7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572910152565b6104a160208092610382565b6104aa8161046e565b0190565b6104c39060208101905f818303910152610495565b90565b156104cd57565b6104d5610072565b62461bcd60e51b8152806104eb600482016104ae565b0390fd5b6105196104fa61035a565b61051361050d610508610683565b61008b565b9161008b565b146104c6565b565b60207f6e206973206e6f74206120636f6e747261637400000000000000000000000000917f5570677261646561626c65426561636f6e3a20696d706c656d656e746174696f5f8201520152565b6105756033604092610382565b61057e8161051b565b0190565b6105979060208101905f818303910152610568565b90565b156105a157565b6105a9610072565b62461bcd60e51b8152806105bf60048201610582565b0390fd5b5f1b90565b906105d960018060a01b03916105c3565b9181191691161790565b90565b906105fb6105f661060292610253565b6105e3565b82546105c8565b9055565b6106229061061b610616826106b3565b61059a565b60016105e6565b565b61062d5f6102dd565b610637825f6105e6565b9061066b6106657f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e093610253565b91610253565b91610674610072565b8061067e816100d8565b0390a3565b61068b6102b5565b503390565b5f90565b90565b6106ab6106a66106b092610312565b610228565b610694565b90565b6106bb610690565b503b6106cf6106c95f610697565b91610694565b119056fea2646970667358221220fe4a5eb99a708c9299f6d8db20171a05afd9f65b1bb37523137ed0d30a2c2b6964736f6c634300081b0033',
      signer
    )
  }
}

export const ERC721SALEFACTORY_VERIFICATION: Omit<VerificationRequest, 'waitForSuccess'> = {
  contractToVerify: 'src/tokens/ERC721/utility/sale/ERC721SaleFactory.sol:ERC721SaleFactory',
  version: 'v0.8.27+commit.40a35a09',
  licenceType: 'Apache-2.0',
  compilerInput: {
    language: 'Solidity',
    sources: {
      'src/tokens/ERC721/utility/sale/ERC721SaleFactory.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport { SequenceProxyFactory } from "../../../../proxies/SequenceProxyFactory.sol";\nimport { ERC721Sale } from "./ERC721Sale.sol";\nimport { IERC721SaleFactory, IERC721SaleFactoryFunctions } from "./IERC721SaleFactory.sol";\n\n/**\n * Deployer of ERC-721 Sale proxies.\n */\ncontract ERC721SaleFactory is IERC721SaleFactory, SequenceProxyFactory {\n\n    /**\n     * Creates an ERC-721 Sale Factory.\n     * @param factoryOwner The owner of the ERC-721 Sale Factory\n     */\n    constructor(\n        address factoryOwner\n    ) {\n        ERC721Sale impl = new ERC721Sale();\n        SequenceProxyFactory._initialize(address(impl), factoryOwner);\n    }\n\n    /// @inheritdoc IERC721SaleFactoryFunctions\n    function deploy(\n        address proxyOwner,\n        address tokenOwner,\n        address items,\n        address implicitModeValidator,\n        bytes32 implicitModeProjectId\n    ) external returns (address proxyAddr) {\n        bytes32 salt = keccak256(abi.encode(tokenOwner, items, implicitModeValidator, implicitModeProjectId));\n        proxyAddr = _createProxy(salt, proxyOwner, "");\n        ERC721Sale(proxyAddr).initialize(tokenOwner, items, implicitModeValidator, implicitModeProjectId);\n        emit ERC721SaleDeployed(proxyAddr);\n        return proxyAddr;\n    }\n\n    /// @inheritdoc IERC721SaleFactoryFunctions\n    function determineAddress(\n        address proxyOwner,\n        address tokenOwner,\n        address items,\n        address implicitModeValidator,\n        bytes32 implicitModeProjectId\n    ) external view returns (address proxyAddr) {\n        bytes32 salt = keccak256(abi.encode(tokenOwner, items, implicitModeValidator, implicitModeProjectId));\n        return _computeProxyAddress(salt, proxyOwner, "");\n    }\n\n}\n'
      },
      'src/proxies/SequenceProxyFactory.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport {\n    ITransparentUpgradeableBeaconProxy,\n    TransparentUpgradeableBeaconProxy\n} from "./TransparentUpgradeableBeaconProxy.sol";\n\nimport { Ownable } from "openzeppelin-contracts/contracts/access/Ownable.sol";\nimport { UpgradeableBeacon } from "openzeppelin-contracts/contracts/proxy/beacon/UpgradeableBeacon.sol";\nimport { Create2 } from "openzeppelin-contracts/contracts/utils/Create2.sol";\n\n/**\n * An proxy factory that deploys upgradeable beacon proxies.\n * @dev The factory owner is able to upgrade the beacon implementation.\n * @dev Proxy deployers are able to override the beacon reference with their own.\n */\nabstract contract SequenceProxyFactory is Ownable {\n\n    UpgradeableBeacon public beacon;\n\n    /**\n     * Initialize a Sequence Proxy Factory.\n     * @param implementation The initial beacon implementation.\n     * @param factoryOwner The owner of the factory.\n     */\n    function _initialize(address implementation, address factoryOwner) internal {\n        beacon = new UpgradeableBeacon(implementation);\n        Ownable._transferOwnership(factoryOwner);\n    }\n\n    /**\n     * Deploys and initializes a new proxy instance.\n     * @param _salt The deployment salt.\n     * @param _proxyOwner The owner of the proxy.\n     * @param _data The initialization data.\n     * @return proxyAddress The address of the deployed proxy.\n     */\n    function _createProxy(\n        bytes32 _salt,\n        address _proxyOwner,\n        bytes memory _data\n    ) internal returns (address proxyAddress) {\n        bytes32 saltedHash = keccak256(abi.encodePacked(_salt, _proxyOwner, address(beacon), _data));\n        bytes memory bytecode = type(TransparentUpgradeableBeaconProxy).creationCode;\n\n        proxyAddress = Create2.deploy(0, saltedHash, bytecode);\n        ITransparentUpgradeableBeaconProxy(payable(proxyAddress)).initialize(_proxyOwner, address(beacon), _data);\n    }\n\n    /**\n     * Computes the address of a proxy instance.\n     * @param _salt The deployment salt.\n     * @param _proxyOwner The owner of the proxy.\n     * @return proxy The expected address of the deployed proxy.\n     */\n    function _computeProxyAddress(\n        bytes32 _salt,\n        address _proxyOwner,\n        bytes memory _data\n    ) internal view returns (address) {\n        bytes32 saltedHash = keccak256(abi.encodePacked(_salt, _proxyOwner, address(beacon), _data));\n        bytes32 bytecodeHash = keccak256(type(TransparentUpgradeableBeaconProxy).creationCode);\n\n        return Create2.computeAddress(saltedHash, bytecodeHash);\n    }\n\n    /**\n     * Upgrades the beacon implementation.\n     * @param implementation The new beacon implementation.\n     */\n    function upgradeBeacon(\n        address implementation\n    ) public onlyOwner {\n        beacon.upgradeTo(implementation);\n    }\n\n}\n'
      },
      'src/tokens/ERC721/utility/sale/ERC721Sale.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport { MerkleProofSingleUse } from "../../../common/MerkleProofSingleUse.sol";\nimport { SignalsImplicitModeControlled } from "../../../common/SignalsImplicitModeControlled.sol";\nimport { AccessControlEnumerable, IERC20, SafeERC20, WithdrawControlled } from "../../../common/WithdrawControlled.sol";\nimport { IERC721ItemsFunctions } from "../../presets/items/IERC721Items.sol";\nimport { IERC721Sale, IERC721SaleFunctions } from "./IERC721Sale.sol";\n\nimport { IERC721A } from "erc721a/extensions/ERC721AQueryable.sol";\n\n/**\n * An ERC-721 token contract with primary sale mechanisms.\n */\ncontract ERC721Sale is IERC721Sale, WithdrawControlled, MerkleProofSingleUse, SignalsImplicitModeControlled {\n\n    bytes32 internal constant MINT_ADMIN_ROLE = keccak256("MINT_ADMIN_ROLE");\n\n    bool private _initialized;\n    address private _items;\n    SaleDetails private _saleDetails;\n\n    /**\n     * Initialize the contract.\n     * @param owner The owner of the contract\n     * @param items The ERC-721 Items contract address\n     * @param implicitModeValidator Implicit session validator address\n     * @param implicitModeProjectId Implicit session project id\n     * @dev This should be called immediately after deployment.\n     */\n    function initialize(\n        address owner,\n        address items,\n        address implicitModeValidator,\n        bytes32 implicitModeProjectId\n    ) public virtual {\n        if (_initialized) {\n            revert InvalidInitialization();\n        }\n\n        _items = items;\n\n        _grantRole(DEFAULT_ADMIN_ROLE, owner);\n        _grantRole(MINT_ADMIN_ROLE, owner);\n        _grantRole(WITHDRAW_ROLE, owner);\n\n        _initializeImplicitMode(owner, implicitModeValidator, implicitModeProjectId);\n\n        _initialized = true;\n    }\n\n    /**\n     * Checks if the current block.timestamp is out of the give timestamp range.\n     * @param _startTime Earliest acceptable timestamp (inclusive).\n     * @param _endTime Latest acceptable timestamp (exclusive).\n     * @dev A zero endTime value is always considered out of bounds.\n     */\n    function _blockTimeOutOfBounds(uint256 _startTime, uint256 _endTime) private view returns (bool) {\n        // 0 end time indicates inactive sale.\n        return _endTime == 0 || block.timestamp < _startTime || block.timestamp >= _endTime; // solhint-disable-line not-rely-on-time\n    }\n\n    /**\n     * Checks the sale is active and takes payment.\n     * @param _amount Amount of tokens to mint.\n     * @param _expectedPaymentToken ERC20 token address to accept payment in. address(0) indicates ETH.\n     * @param _maxTotal Maximum amount of payment tokens.\n     * @param _proof Merkle proof for allowlist minting.\n     */\n    function _payForActiveMint(\n        uint256 _amount,\n        address _expectedPaymentToken,\n        uint256 _maxTotal,\n        bytes32[] calldata _proof\n    ) private {\n        // Active sale test\n        if (_blockTimeOutOfBounds(_saleDetails.startTime, _saleDetails.endTime)) {\n            revert SaleInactive();\n        }\n        requireMerkleProof(_saleDetails.merkleRoot, _proof, msg.sender, "");\n\n        uint256 total = _saleDetails.cost * _amount;\n        if (_expectedPaymentToken != _saleDetails.paymentToken) {\n            // Caller expected different payment token\n            revert InsufficientPayment(_saleDetails.paymentToken, total, 0);\n        }\n        if (_maxTotal < total) {\n            // Caller expected to pay less\n            revert InsufficientPayment(_expectedPaymentToken, total, _maxTotal);\n        }\n        if (_expectedPaymentToken == address(0)) {\n            // Paid in ETH\n            if (msg.value != total) {\n                // We expect exact value match\n                revert InsufficientPayment(_expectedPaymentToken, total, msg.value);\n            }\n        } else if (msg.value > 0) {\n            // Paid in ERC20, but sent ETH\n            revert InsufficientPayment(address(0), 0, msg.value);\n        } else {\n            // Paid in ERC20\n            SafeERC20.safeTransferFrom(IERC20(_expectedPaymentToken), msg.sender, address(this), total);\n        }\n    }\n\n    //\n    // Minting\n    //\n\n    /**\n     * Mint tokens.\n     * @param to Address to mint tokens to.\n     * @param amount Amount of tokens to mint.\n     * @param paymentToken ERC20 token address to accept payment in. address(0) indicates ETH.\n     * @param maxTotal Maximum amount of payment tokens.\n     * @param proof Merkle proof for allowlist minting.\n     * @notice Sale must be active for all tokens.\n     * @dev An empty proof is supplied when no proof is required.\n     * @dev `paymentToken` must match the `paymentToken` in the sale details.\n     */\n    function mint(\n        address to,\n        uint256 amount,\n        address paymentToken,\n        uint256 maxTotal,\n        bytes32[] calldata proof\n    ) public payable {\n        _payForActiveMint(amount, paymentToken, maxTotal, proof);\n\n        uint256 currentSupply = IERC721A(_items).totalSupply();\n        uint256 supplyCap = _saleDetails.supplyCap;\n        if (supplyCap > 0 && currentSupply + amount > supplyCap) {\n            revert InsufficientSupply(currentSupply, amount, supplyCap);\n        }\n\n        IERC721ItemsFunctions(_items).mint(to, amount);\n        emit ItemsMinted(to, amount);\n    }\n\n    /**\n     * Set the sale details.\n     * @param supplyCap The maximum number of tokens that can be minted by the items contract. 0 indicates unlimited supply.\n     * @param cost The amount of payment tokens to accept for each token minted.\n     * @param paymentToken The ERC20 token address to accept payment in. address(0) indicates ETH.\n     * @param startTime The start time of the sale. Tokens cannot be minted before this time.\n     * @param endTime The end time of the sale. Tokens cannot be minted after this time.\n     * @param merkleRoot The merkle root for allowlist minting.\n     * @dev A zero end time indicates an inactive sale.\n     */\n    function setSaleDetails(\n        uint256 supplyCap,\n        uint256 cost,\n        address paymentToken,\n        uint64 startTime,\n        uint64 endTime,\n        bytes32 merkleRoot\n    ) public onlyRole(MINT_ADMIN_ROLE) {\n        // solhint-disable-next-line not-rely-on-time\n        if (endTime < startTime || endTime <= block.timestamp) {\n            revert InvalidSaleDetails();\n        }\n        _saleDetails = SaleDetails(supplyCap, cost, paymentToken, startTime, endTime, merkleRoot);\n        emit SaleDetailsUpdated(supplyCap, cost, paymentToken, startTime, endTime, merkleRoot);\n    }\n\n    //\n    // Views\n    //\n    function itemsContract() external view returns (address) {\n        return address(_items);\n    }\n\n    /**\n     * Get sale details.\n     * @return Sale details.\n     */\n    function saleDetails() external view returns (SaleDetails memory) {\n        return _saleDetails;\n    }\n\n    /**\n     * Check interface support.\n     * @param interfaceId Interface id\n     * @return True if supported\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(WithdrawControlled, SignalsImplicitModeControlled) returns (bool) {\n        return interfaceId == type(IERC721SaleFunctions).interfaceId\n            || WithdrawControlled.supportsInterface(interfaceId)\n            || SignalsImplicitModeControlled.supportsInterface(interfaceId);\n    }\n\n}\n'
      },
      'src/tokens/ERC721/utility/sale/IERC721SaleFactory.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ninterface IERC721SaleFactoryFunctions {\n\n    /**\n     * Creates an ERC-721 Sale for given token contract\n     * @param proxyOwner The owner of the ERC-721 Sale proxy\n     * @param tokenOwner The owner of the ERC-721 Sale implementation\n     * @param items The ERC-721 Items contract address\n     * @param implicitModeValidator The implicit mode validator address\n     * @param implicitModeProjectId The implicit mode project id\n     * @return proxyAddr The address of the ERC-721 Sale Proxy\n     * @notice The deployed contract must be granted the MINTER_ROLE on the ERC-721 Items contract.\n     */\n    function deploy(\n        address proxyOwner,\n        address tokenOwner,\n        address items,\n        address implicitModeValidator,\n        bytes32 implicitModeProjectId\n    ) external returns (address proxyAddr);\n\n    /**\n     * Computes the address of a proxy instance.\n     * @param proxyOwner The owner of the ERC-721 Sale proxy\n     * @param tokenOwner The owner of the ERC-721 Sale implementation\n     * @param items The ERC-721 Items contract address\n     * @param implicitModeValidator The implicit mode validator address\n     * @param implicitModeProjectId The implicit mode project id\n     * @return proxyAddr The address of the ERC-721 Sale Proxy\n     */\n    function determineAddress(\n        address proxyOwner,\n        address tokenOwner,\n        address items,\n        address implicitModeValidator,\n        bytes32 implicitModeProjectId\n    ) external returns (address proxyAddr);\n\n}\n\ninterface IERC721SaleFactorySignals {\n\n    /**\n     * Event emitted when a new ERC-721 Sale proxy contract is deployed.\n     * @param proxyAddr The address of the deployed proxy.\n     */\n    event ERC721SaleDeployed(address proxyAddr);\n\n}\n\ninterface IERC721SaleFactory is IERC721SaleFactoryFunctions, IERC721SaleFactorySignals { }\n'
      },
      'src/proxies/TransparentUpgradeableBeaconProxy.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport { BeaconProxy, Proxy } from "./openzeppelin/BeaconProxy.sol";\nimport { ERC1967Proxy, TransparentUpgradeableProxy } from "./openzeppelin/TransparentUpgradeableProxy.sol";\n\ninterface ITransparentUpgradeableBeaconProxy {\n\n    function initialize(address admin, address beacon, bytes memory data) external;\n\n}\n\nerror InvalidInitialization();\n\n/**\n * @dev As the underlying proxy implementation (TransparentUpgradeableProxy) allows the admin to call the implementation,\n * care must be taken to avoid proxy selector collisions. Implementation selectors must not conflict with the proxy selectors.\n * See https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector clashing].\n * The proxy selectors are:\n * - 0xcf7a1d77: initialize\n * - 0x3659cfe6: upgradeTo (from TransparentUpgradeableProxy)\n * - 0x4f1ef286: upgradeToAndCall (from TransparentUpgradeableProxy)\n * - 0x8f283970: changeAdmin (from TransparentUpgradeableProxy)\n * - 0xf851a440: admin (from TransparentUpgradeableProxy)\n * - 0x5c60da1b: implementation (from TransparentUpgradeableProxy)\n */\ncontract TransparentUpgradeableBeaconProxy is TransparentUpgradeableProxy, BeaconProxy {\n\n    /**\n     * Decode the initialization data from the msg.data and call the initialize function.\n     */\n    function _dispatchInitialize() private returns (bytes memory) {\n        _requireZeroValue();\n\n        (address admin, address beacon, bytes memory data) = abi.decode(msg.data[4:], (address, address, bytes));\n        initialize(admin, beacon, data);\n\n        return "";\n    }\n\n    function initialize(address admin, address beacon, bytes memory data) internal {\n        if (_admin() != address(0)) {\n            // Redundant call. This function can only be called when the admin is not set.\n            revert InvalidInitialization();\n        }\n        _changeAdmin(admin);\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev If the admin is not set, the fallback function is used to initialize the proxy.\n     * @dev If the admin is set, the fallback function is used to delegatecall the implementation.\n     */\n    function _fallback() internal override(TransparentUpgradeableProxy, Proxy) {\n        if (_getAdmin() == address(0)) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableBeaconProxy.initialize.selector) {\n                ret = _dispatchInitialize();\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    return(add(ret, 0x20), mload(ret))\n                }\n            }\n            // When the admin is not set, the fallback function is used to initialize the proxy.\n            revert InvalidInitialization();\n        }\n        TransparentUpgradeableProxy._fallback();\n    }\n\n    /**\n     * Returns the current implementation address.\n     * @dev This is the implementation address set by the admin, or the beacon implementation.\n     */\n    function _implementation() internal view override(ERC1967Proxy, BeaconProxy) returns (address) {\n        address implementation = ERC1967Proxy._implementation();\n        if (implementation != address(0)) {\n            return implementation;\n        }\n        return BeaconProxy._implementation();\n    }\n\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/access/Ownable.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport "../utils/Context.sol";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/proxy/beacon/UpgradeableBeacon.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\n\npragma solidity ^0.8.0;\n\nimport "./IBeacon.sol";\nimport "../../access/Ownable.sol";\nimport "../../utils/Address.sol";\n\n/**\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\n * implementation contract, which is where they will delegate all function calls.\n *\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\n */\ncontract UpgradeableBeacon is IBeacon, Ownable {\n    address private _implementation;\n\n    /**\n     * @dev Emitted when the implementation returned by the beacon is changed.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\n     * beacon.\n     */\n    constructor(address implementation_) {\n        _setImplementation(implementation_);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function implementation() public view virtual override returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Upgrades the beacon to a new implementation.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * Requirements:\n     *\n     * - msg.sender must be the owner of the contract.\n     * - `newImplementation` must be a contract.\n     */\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Sets the implementation contract address for this beacon\n     *\n     * Requirements:\n     *\n     * - `newImplementation` must be a contract.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), "UpgradeableBeacon: implementation is not a contract");\n        _implementation = newImplementation;\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/Create2.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as \'counterfactual interactions\'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        require(address(this).balance >= amount, "Create2: insufficient balance");\n        require(bytecode.length != 0, "Create2: bytecode length is zero");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), "Create2: Failed on deploy");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract\'s address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n'
      },
      'src/tokens/common/MerkleProofSingleUse.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport { IMerkleProofSingleUse } from "./IMerkleProofSingleUse.sol";\n\nimport { MerkleProof } from "openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol";\n\n/**\n * Require single use merkle proofs per address.\n */\nabstract contract MerkleProofSingleUse is IMerkleProofSingleUse {\n\n    // Stores proofs used by an address\n    mapping(address => mapping(bytes32 => bool)) private _proofUsed;\n\n    /**\n     * Requires the given merkle proof to be valid.\n     * @param root Merkle root.\n     * @param proof Merkle proof.\n     * @param addr Address to check.\n     * @param salt Salt used to generate the merkle leaf.\n     * @notice Fails when the proof is invalid or the proof has already been claimed by this address.\n     * @dev This function reverts on failure.\n     */\n    function requireMerkleProof(bytes32 root, bytes32[] calldata proof, address addr, bytes32 salt) internal {\n        if (root != bytes32(0)) {\n            if (!checkMerkleProof(root, proof, addr, salt)) {\n                revert MerkleProofInvalid(root, proof, addr, salt);\n            }\n            _proofUsed[addr][root] = true;\n        }\n    }\n\n    /**\n     * Checks if the given merkle proof is valid.\n     * @param root Merkle root.\n     * @param proof Merkle proof.\n     * @param addr Address to check.\n     * @param salt Salt used to generate the merkle leaf.\n     * @return True if the proof is valid and has not yet been used by {addr}.\n     */\n    function checkMerkleProof(\n        bytes32 root,\n        bytes32[] calldata proof,\n        address addr,\n        bytes32 salt\n    ) public view returns (bool) {\n        return !_proofUsed[addr][root] && MerkleProof.verify(proof, root, keccak256(abi.encodePacked(addr, salt)));\n    }\n\n}\n'
      },
      'src/tokens/common/SignalsImplicitModeControlled.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport { AccessControlEnumerable } from "openzeppelin-contracts/contracts/access/AccessControlEnumerable.sol";\nimport {\n    IERC165,\n    IImplicitProjectValidation,\n    SignalsImplicitMode\n} from "signals-implicit-mode/src/helper/SignalsImplicitMode.sol";\n\n/**\n * An abstract contract that allows implicit session access for a given project.\n */\nabstract contract SignalsImplicitModeControlled is AccessControlEnumerable, SignalsImplicitMode {\n\n    bytes32 internal constant _IMPLICIT_MODE_ADMIN_ROLE = keccak256("IMPLICIT_MODE_ADMIN_ROLE");\n\n    function _initializeImplicitMode(address owner, address validator, bytes32 projectId) internal {\n        _grantRole(_IMPLICIT_MODE_ADMIN_ROLE, owner);\n        _initializeSignalsImplicitMode(validator, projectId);\n    }\n\n    /**\n     * Updates the validator for implicit mode validation.\n     * @param validator The validator address.\n     * @notice Only callable by an address with the project admin role.\n     */\n    function setImplicitModeValidator(\n        address validator\n    ) external onlyRole(_IMPLICIT_MODE_ADMIN_ROLE) {\n        _validator = IImplicitProjectValidation(validator);\n    }\n\n    /**\n     * Updates the settings for implicit mode validation.\n     * @param projectId The project id.\n     * @notice Only callable by an address with the project admin role.\n     */\n    function setImplicitModeProjectId(\n        bytes32 projectId\n    ) external onlyRole(_IMPLICIT_MODE_ADMIN_ROLE) {\n        _projectId = projectId;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerable, SignalsImplicitMode) returns (bool) {\n        return\n            AccessControlEnumerable.supportsInterface(interfaceId) || SignalsImplicitMode.supportsInterface(interfaceId);\n    }\n\n}\n'
      },
      'src/tokens/common/WithdrawControlled.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\nimport { IWithdrawControlled } from "./IWithdrawControlled.sol";\n\nimport { AccessControlEnumerable, ERC165 } from "openzeppelin-contracts/contracts/access/AccessControlEnumerable.sol";\nimport { IERC20, SafeERC20 } from "openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";\n\n/**\n * An abstract contract that allows ETH and ERC20 tokens stored in the contract to be withdrawn.\n */\nabstract contract WithdrawControlled is AccessControlEnumerable, IWithdrawControlled {\n\n    bytes32 internal constant WITHDRAW_ROLE = keccak256("WITHDRAW_ROLE");\n\n    //\n    // Withdraw\n    //\n\n    /**\n     * Withdraws ERC20 tokens owned by this contract.\n     * @param token The ERC20 token address.\n     * @param to Address to withdraw to.\n     * @param value Amount to withdraw.\n     * @notice Only callable by an address with the withdraw role.\n     */\n    function withdrawERC20(address token, address to, uint256 value) public onlyRole(WITHDRAW_ROLE) {\n        SafeERC20.safeTransfer(IERC20(token), to, value);\n    }\n\n    /**\n     * Withdraws ETH owned by this sale contract.\n     * @param to Address to withdraw to.\n     * @param value Amount to withdraw.\n     * @notice Only callable by an address with the withdraw role.\n     */\n    function withdrawETH(address to, uint256 value) public onlyRole(WITHDRAW_ROLE) {\n        (bool success,) = to.call{ value: value }("");\n        if (!success) {\n            revert WithdrawFailed();\n        }\n    }\n\n    /// @inheritdoc ERC165\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControlEnumerable) returns (bool) {\n        return interfaceId == type(IWithdrawControlled).interfaceId\n            || AccessControlEnumerable.supportsInterface(interfaceId);\n    }\n\n}\n'
      },
      'src/tokens/ERC721/presets/items/IERC721Items.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ninterface IERC721ItemsFunctions {\n\n    /**\n     * Mint tokens.\n     * @param to Address to mint tokens to.\n     * @param amount Amount of tokens to mint.\n     */\n    function mint(address to, uint256 amount) external;\n\n}\n\ninterface IERC721ItemsSignals {\n\n    /**\n     * Invalid initialization error.\n     */\n    error InvalidInitialization();\n\n}\n\ninterface IERC721Items is IERC721ItemsFunctions, IERC721ItemsSignals { }\n'
      },
      'src/tokens/ERC721/utility/sale/IERC721Sale.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ninterface IERC721SaleFunctions {\n\n    struct SaleDetails {\n        uint256 supplyCap; // 0 supply cap indicates unlimited supply\n        uint256 cost;\n        address paymentToken; // ERC20 token address for payment. address(0) indicated payment in ETH.\n        uint64 startTime;\n        uint64 endTime; // 0 end time indicates sale inactive\n        bytes32 merkleRoot; // Root of allowed addresses\n    }\n\n    /**\n     * Mint tokens.\n     * @param to Address to mint tokens to.\n     * @param amount Amount of tokens to mint.\n     * @param paymentToken ERC20 token address to accept payment in. address(0) indicates ETH.\n     * @param maxTotal Maximum amount of payment tokens.\n     * @param proof Merkle proof for allowlist minting.\n     * @notice Sale must be active for all tokens.\n     * @dev An empty proof is supplied when no proof is required.\n     */\n    function mint(\n        address to,\n        uint256 amount,\n        address paymentToken,\n        uint256 maxTotal,\n        bytes32[] memory proof\n    ) external payable;\n\n    /**\n     * Set the sale details.\n     * @param supplyCap The maximum number of tokens that can be minted by the items contract. 0 indicates unlimited supply.\n     * @param cost The amount of payment tokens to accept for each token minted.\n     * @param paymentToken The ERC20 token address to accept payment in. address(0) indicates ETH.\n     * @param startTime The start time of the sale. Tokens cannot be minted before this time.\n     * @param endTime The end time of the sale. Tokens cannot be minted after this time.\n     * @param merkleRoot The merkle root for allowlist minting.\n     */\n    function setSaleDetails(\n        uint256 supplyCap,\n        uint256 cost,\n        address paymentToken,\n        uint64 startTime,\n        uint64 endTime,\n        bytes32 merkleRoot\n    ) external;\n\n    /**\n     * Get sale details.\n     * @return Sale details.\n     */\n    function saleDetails() external view returns (SaleDetails memory);\n\n}\n\ninterface IERC721SaleSignals {\n\n    event SaleDetailsUpdated(\n        uint256 supplyCap, uint256 cost, address paymentToken, uint64 startTime, uint64 endTime, bytes32 merkleRoot\n    );\n    event ItemsMinted(address to, uint256 amount);\n\n    /**\n     * Contract already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * Sale details supplied are invalid.\n     */\n    error InvalidSaleDetails();\n\n    /**\n     * Sale is not active.\n     */\n    error SaleInactive();\n\n    /**\n     * Insufficient supply.\n     * @param currentSupply Current supply.\n     * @param amount Amount to mint.\n     * @param maxSupply Maximum supply.\n     */\n    error InsufficientSupply(uint256 currentSupply, uint256 amount, uint256 maxSupply);\n\n    /**\n     * Insufficient tokens for payment.\n     * @param currency Currency address. address(0) indicates ETH.\n     * @param expected Expected amount of tokens.\n     * @param actual Actual amount of tokens.\n     */\n    error InsufficientPayment(address currency, uint256 expected, uint256 actual);\n\n}\n\ninterface IERC721Sale is IERC721SaleFunctions, IERC721SaleSignals { }\n'
      },
      'lib/erc721a/contracts/extensions/ERC721AQueryable.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.3.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC721AQueryable.sol';\nimport '../ERC721A.sol';\n\n/**\n * @title ERC721AQueryable.\n *\n * @dev ERC721A subclass with convenience query functions.\n */\nabstract contract ERC721AQueryable is ERC721A, IERC721AQueryable {\n    /**\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\n     *\n     * If the `tokenId` is out of bounds:\n     *\n     * - `addr = address(0)`\n     * - `startTimestamp = 0`\n     * - `burned = false`\n     * - `extraData = 0`\n     *\n     * If the `tokenId` is burned:\n     *\n     * - `addr = <Address of owner before token was burned>`\n     * - `startTimestamp = <Timestamp when token was burned>`\n     * - `burned = true`\n     * - `extraData = <Extra data when token was burned>`\n     *\n     * Otherwise:\n     *\n     * - `addr = <Address of owner>`\n     * - `startTimestamp = <Timestamp of start of ownership>`\n     * - `burned = false`\n     * - `extraData = <Extra data at start of ownership>`\n     */\n    function explicitOwnershipOf(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (TokenOwnership memory ownership)\n    {\n        unchecked {\n            if (tokenId >= _startTokenId()) {\n                if (tokenId > _sequentialUpTo()) return _ownershipAt(tokenId);\n\n                if (tokenId < _nextTokenId()) {\n                    // If the `tokenId` is within bounds,\n                    // scan backwards for the initialized ownership slot.\n                    while (!_ownershipIsInitialized(tokenId)) --tokenId;\n                    return _ownershipAt(tokenId);\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\n     * See {ERC721AQueryable-explicitOwnershipOf}\n     */\n    function explicitOwnershipsOf(uint256[] calldata tokenIds)\n        external\n        view\n        virtual\n        override\n        returns (TokenOwnership[] memory)\n    {\n        TokenOwnership[] memory ownerships;\n        uint256 i = tokenIds.length;\n        assembly {\n            // Grab the free memory pointer.\n            ownerships := mload(0x40)\n            // Store the length.\n            mstore(ownerships, i)\n            // Allocate one word for the length,\n            // `tokenIds.length` words for the pointers.\n            i := shl(5, i) // Multiply `i` by 32.\n            mstore(0x40, add(add(ownerships, 0x20), i))\n        }\n        while (i != 0) {\n            uint256 tokenId;\n            assembly {\n                i := sub(i, 0x20)\n                tokenId := calldataload(add(tokenIds.offset, i))\n            }\n            TokenOwnership memory ownership = explicitOwnershipOf(tokenId);\n            assembly {\n                // Store the pointer of `ownership` in the `ownerships` array.\n                mstore(add(add(ownerships, 0x20), i), ownership)\n            }\n        }\n        return ownerships;\n    }\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`,\n     * in the range [`start`, `stop`)\n     * (i.e. `start <= tokenId < stop`).\n     *\n     * This function allows for tokens to be queried if the collection\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\n     *\n     * Requirements:\n     *\n     * - `start < stop`\n     */\n    function tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) external view virtual override returns (uint256[] memory) {\n        return _tokensOfOwnerIn(owner, start, stop);\n    }\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\n     * multiple smaller scans if the collection is large enough to cause\n     * an out-of-gas error (10K collections should be fine).\n     */\n    function tokensOfOwner(address owner) external view virtual override returns (uint256[] memory) {\n        // If spot mints are enabled, full-range scan is disabled.\n        if (_sequentialUpTo() != type(uint256).max) _revert(NotCompatibleWithSpotMints.selector);\n        uint256 start = _startTokenId();\n        uint256 stop = _nextTokenId();\n        uint256[] memory tokenIds;\n        if (start != stop) tokenIds = _tokensOfOwnerIn(owner, start, stop);\n        return tokenIds;\n    }\n\n    /**\n     * @dev Helper function for returning an array of token IDs owned by `owner`.\n     *\n     * Note that this function is optimized for smaller bytecode size over runtime gas,\n     * since it is meant to be called off-chain.\n     */\n    function _tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) private view returns (uint256[] memory tokenIds) {\n        unchecked {\n            if (start >= stop) _revert(InvalidQueryRange.selector);\n            // Set `start = max(start, _startTokenId())`.\n            if (start < _startTokenId()) start = _startTokenId();\n            uint256 nextTokenId = _nextTokenId();\n            // If spot mints are enabled, scan all the way until the specified `stop`.\n            uint256 stopLimit = _sequentialUpTo() != type(uint256).max ? stop : nextTokenId;\n            // Set `stop = min(stop, stopLimit)`.\n            if (stop >= stopLimit) stop = stopLimit;\n            // Number of tokens to scan.\n            uint256 tokenIdsMaxLength = balanceOf(owner);\n            // Set `tokenIdsMaxLength` to zero if the range contains no tokens.\n            if (start >= stop) tokenIdsMaxLength = 0;\n            // If there are one or more tokens to scan.\n            if (tokenIdsMaxLength != 0) {\n                // Set `tokenIdsMaxLength = min(balanceOf(owner), tokenIdsMaxLength)`.\n                if (stop - start <= tokenIdsMaxLength) tokenIdsMaxLength = stop - start;\n                uint256 m; // Start of available memory.\n                assembly {\n                    // Grab the free memory pointer.\n                    tokenIds := mload(0x40)\n                    // Allocate one word for the length, and `tokenIdsMaxLength` words\n                    // for the data. `shl(5, x)` is equivalent to `mul(32, x)`.\n                    m := add(tokenIds, shl(5, add(tokenIdsMaxLength, 1)))\n                    mstore(0x40, m)\n                }\n                // We need to call `explicitOwnershipOf(start)`,\n                // because the slot at `start` may not be initialized.\n                TokenOwnership memory ownership = explicitOwnershipOf(start);\n                address currOwnershipAddr;\n                // If the starting slot exists (i.e. not burned),\n                // initialize `currOwnershipAddr`.\n                // `ownership.address` will not be zero,\n                // as `start` is clamped to the valid token ID range.\n                if (!ownership.burned) currOwnershipAddr = ownership.addr;\n                uint256 tokenIdsIdx;\n                // Use a do-while, which is slightly more efficient for this case,\n                // as the array will at least contain one element.\n                do {\n                    if (_sequentialUpTo() != type(uint256).max) {\n                        // Skip the remaining unused sequential slots.\n                        if (start == nextTokenId) start = _sequentialUpTo() + 1;\n                        // Reset `currOwnershipAddr`, as each spot-minted token is a batch of one.\n                        if (start > _sequentialUpTo()) currOwnershipAddr = address(0);\n                    }\n                    ownership = _ownershipAt(start); // This implicitly allocates memory.\n                    assembly {\n                        switch mload(add(ownership, 0x40))\n                        // if `ownership.burned == false`.\n                        case 0 {\n                            // if `ownership.addr != address(0)`.\n                            // The `addr` already has it's upper 96 bits clearned,\n                            // since it is written to memory with regular Solidity.\n                            if mload(ownership) {\n                                currOwnershipAddr := mload(ownership)\n                            }\n                            // if `currOwnershipAddr == owner`.\n                            // The `shl(96, x)` is to make the comparison agnostic to any\n                            // dirty upper 96 bits in `owner`.\n                            if iszero(shl(96, xor(currOwnershipAddr, owner))) {\n                                tokenIdsIdx := add(tokenIdsIdx, 1)\n                                mstore(add(tokenIds, shl(5, tokenIdsIdx)), start)\n                            }\n                        }\n                        // Otherwise, reset `currOwnershipAddr`.\n                        // This handles the case of batch burned tokens\n                        // (burned bit of first slot set, remaining slots left uninitialized).\n                        default {\n                            currOwnershipAddr := 0\n                        }\n                        start := add(start, 1)\n                        // Free temporary memory implicitly allocated for ownership\n                        // to avoid quadratic memory expansion costs.\n                        mstore(0x40, m)\n                    }\n                } while (!(start == stop || tokenIdsIdx == tokenIdsMaxLength));\n                // Store the length of the array.\n                assembly {\n                    mstore(tokenIds, tokenIdsIdx)\n                }\n            }\n        }\n    }\n}\n"
      },
      'src/proxies/openzeppelin/BeaconProxy.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\n// Note: This implementation is an exact copy with the constructor removed, and pragma and imports updated.\n\npragma solidity ^0.8.19;\n\nimport "openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol";\nimport "openzeppelin-contracts/contracts/proxy/Proxy.sol";\nimport "openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256(\'eip1967.proxy.beacon\')) - 1`, so that it doesn\'t\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it\'s used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n}\n'
      },
      'src/proxies/openzeppelin/TransparentUpgradeableProxy.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\n/// @notice This implementation is a copy of OpenZeppelin\'s with the following changes:\n/// - Pragma updated\n/// - Imports updated\n/// - Constructor removed\n/// - Allows admin to call implementation\n\npragma solidity ^0.8.19;\n\nimport "./ERC1967Proxy.sol";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(\n        address\n    ) external;\n\n    function upgradeTo(\n        address\n    ) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * Unlike the original OpenZeppelin implementation, this contract does not prevent the admin from calling the implementation.\n * This potentially exposes the admin to a proxy selector attack. See\n * https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector clashing].\n * When using this contract, you must ensure that the implementation function selectors do not clash with the proxy selectors.\n * The proxy selectors are:\n * - 0x3659cfe6: upgradeTo\n * - 0x4f1ef286: upgradeToAndCall\n * - 0x8f283970: changeAdmin\n * - 0xf851a440: admin\n * - 0x5c60da1b: implementation\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                // Call implementation\n                return super._fallback();\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return "";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(""), false);\n\n        return "";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return "";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() internal {\n        require(msg.value == 0);\n    }\n\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/Context.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/Address.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n'
      },
      'src/tokens/common/IMerkleProofSingleUse.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ninterface IMerkleProofSingleUseFunctions {\n\n    /**\n     * Checks if the given merkle proof is valid.\n     * @param root Merkle root.\n     * @param proof Merkle proof.\n     * @param addr Address to check.\n     * @param salt Salt used to generate the merkle leaf.\n     * @return True if the proof is valid and has not yet been used by {addr}.\n     */\n    function checkMerkleProof(\n        bytes32 root,\n        bytes32[] calldata proof,\n        address addr,\n        bytes32 salt\n    ) external view returns (bool);\n\n}\n\ninterface IMerkleProofSingleUseSignals {\n\n    /**\n     * Thrown when the merkle proof is invalid or has already been used.\n     * @param root Merkle root.\n     * @param proof Merkle proof.\n     * @param addr Address to check.\n     * @param salt Salt used to generate the merkle leaf.\n     */\n    error MerkleProofInvalid(bytes32 root, bytes32[] proof, address addr, bytes32 salt);\n\n}\n\ninterface IMerkleProofSingleUse is IMerkleProofSingleUseFunctions, IMerkleProofSingleUseSignals { }\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin\'s JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, "MerkleProof: invalid multiproof");\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, "MerkleProof: invalid multiproof");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proofLen - 1 == totalHashes, "MerkleProof: invalid multiproof");\n\n        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue\'s "pop".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the "main queue" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            require(proofPos == proofLen, "MerkleProof: invalid multiproof");\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/access/AccessControlEnumerable.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport "./IAccessControlEnumerable.sol";\nimport "./AccessControl.sol";\nimport "../utils/structs/EnumerableSet.sol";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n}\n'
      },
      'lib/signals-implicit-mode/src/helper/SignalsImplicitMode.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IImplicitProjectValidation } from "../registry/IImplicitProjectValidation.sol";\n\nimport { ERC165, IERC165 } from "openzeppelin-contracts/contracts/utils/introspection/ERC165.sol";\nimport { Attestation } from "sequence-v3/src/extensions/sessions/implicit/Attestation.sol";\nimport { ISignalsImplicitMode } from "sequence-v3/src/extensions/sessions/implicit/ISignalsImplicitMode.sol";\nimport { Payload } from "sequence-v3/src/modules/Payload.sol";\n\n/// @title SignalsImplicitMode\n/// @author Michael Standen\n/// @notice Base contract for implicit mode validation by project\nabstract contract SignalsImplicitMode is ISignalsImplicitMode, ERC165 {\n\n  IImplicitProjectValidation internal _validator;\n  bytes32 internal _projectId;\n\n  /// @notice Initialize implicit mode validation\n  /// @param validator The IImplicitProjectValidation address\n  /// @param projectId The project id\n  function _initializeSignalsImplicitMode(address validator, bytes32 projectId) internal {\n    _validator = IImplicitProjectValidation(validator);\n    _projectId = projectId;\n  }\n\n  /// @inheritdoc ISignalsImplicitMode\n  function acceptImplicitRequest(\n    address wallet,\n    Attestation calldata attestation,\n    Payload.Call calldata call\n  ) external view returns (bytes32) {\n    _validateImplicitRequest(wallet, attestation, call);\n    return _validator.validateAttestation(wallet, attestation, _projectId);\n  }\n\n  /// @notice Validates an implicit request\n  /// @dev Optional hook for additional validation of the implicit requests\n  /// @param wallet The wallet\'s address\n  /// @param attestation The attestation data\n  /// @param call The call to validate\n  function _validateImplicitRequest(\n    address wallet,\n    Attestation calldata attestation,\n    Payload.Call calldata call\n  ) internal view virtual { }\n\n  /// @inheritdoc IERC165\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(ISignalsImplicitMode).interfaceId || super.supportsInterface(interfaceId);\n  }\n\n}\n'
      },
      'src/tokens/common/IWithdrawControlled.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.19;\n\ninterface IWithdrawControlledFunctions {\n\n    /**\n     * Withdraws ERC20 tokens owned by this contract.\n     * @param token The ERC20 token address.\n     * @param to Address to withdraw to.\n     * @param value Amount to withdraw.\n     */\n    function withdrawERC20(address token, address to, uint256 value) external;\n\n    /**\n     * Withdraws ETH owned by this sale contract.\n     * @param to Address to withdraw to.\n     * @param value Amount to withdraw.\n     */\n    function withdrawETH(address to, uint256 value) external;\n\n}\n\ninterface IWithdrawControlledSignals {\n\n    /**\n     * Withdraw failed error.\n     */\n    error WithdrawFailed();\n\n}\n\ninterface IWithdrawControlled is IWithdrawControlledFunctions, IWithdrawControlledSignals { }\n'
      },
      'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport "../IERC20.sol";\nimport "../extensions/IERC20Permit.sol";\nimport "../../../utils/Address.sol";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // \'safeIncreaseAllowance\' and \'safeDecreaseAllowance\'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            "SafeERC20: approve from non-zero to non-zero allowance"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity\'s return data size checking mechanism, since\n        // we\'re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n'
      },
      'lib/erc721a/contracts/extensions/IERC721AQueryable.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.3.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../IERC721A.sol';\n\n/**\n * @dev Interface of ERC721AQueryable.\n */\ninterface IERC721AQueryable is IERC721A {\n    /**\n     * Invalid query range (`start` >= `stop`).\n     */\n    error InvalidQueryRange();\n\n    /**\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\n     *\n     * If the `tokenId` is out of bounds:\n     *\n     * - `addr = address(0)`\n     * - `startTimestamp = 0`\n     * - `burned = false`\n     * - `extraData = 0`\n     *\n     * If the `tokenId` is burned:\n     *\n     * - `addr = <Address of owner before token was burned>`\n     * - `startTimestamp = <Timestamp when token was burned>`\n     * - `burned = true`\n     * - `extraData = <Extra data when token was burned>`\n     *\n     * Otherwise:\n     *\n     * - `addr = <Address of owner>`\n     * - `startTimestamp = <Timestamp of start of ownership>`\n     * - `burned = false`\n     * - `extraData = <Extra data at start of ownership>`\n     */\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\n\n    /**\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\n     * See {ERC721AQueryable-explicitOwnershipOf}\n     */\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`,\n     * in the range [`start`, `stop`)\n     * (i.e. `start <= tokenId < stop`).\n     *\n     * This function allows for tokens to be queried if the collection\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\n     *\n     * Requirements:\n     *\n     * - `start < stop`\n     */\n    function tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\n     * multiple smaller scans if the collection is large enough to cause\n     * an out-of-gas error (10K collections should be fine).\n     */\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\n}\n"
      },
      'lib/erc721a/contracts/ERC721A.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.3.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC721A.sol';\n\n/**\n * @dev Interface of ERC721 token receiver.\n */\ninterface ERC721A__IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title ERC721A\n *\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\n * Non-Fungible Token Standard, including the Metadata extension.\n * Optimized for lower gas during batch mints.\n *\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\n * starting from `_startTokenId()`.\n *\n * The `_sequentialUpTo()` function can be overriden to enable spot mints\n * (i.e. non-consecutive mints) for `tokenId`s greater than `_sequentialUpTo()`.\n *\n * Assumptions:\n *\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721A is IERC721A {\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\n    struct TokenApprovalRef {\n        address value;\n    }\n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // Mask of an entry in packed address data.\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant _BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\n\n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n    // The bit position of `extraData` in packed ownership.\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\n    // This limit is to prevent overflows on the address data entries.\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n    // is required to cause an overflow, which is unrealistic.\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    // The next token ID to be minted.\n    uint256 private _currentIndex;\n\n    // The number of tokens burned.\n    uint256 private _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned.\n    // See {_packedOwnershipOf} implementation for details.\n    //\n    // Bits Layout:\n    // - [0..159]   `addr`\n    // - [160..223] `startTimestamp`\n    // - [224]      `burned`\n    // - [225]      `nextInitialized`\n    // - [232..255] `extraData`\n    mapping(uint256 => uint256) private _packedOwnerships;\n\n    // Mapping owner address to address data.\n    //\n    // Bits Layout:\n    // - [0..63]    `balance`\n    // - [64..127]  `numberMinted`\n    // - [128..191] `numberBurned`\n    // - [192..255] `aux`\n    mapping(address => uint256) private _packedAddressData;\n\n    // Mapping from token ID to approved address.\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // The amount of tokens minted above `_sequentialUpTo()`.\n    // We call these spot mints (i.e. non-sequential mints).\n    uint256 private _spotMinted;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n\n        if (_sequentialUpTo() < _startTokenId()) _revert(SequentialUpToTooSmall.selector);\n    }\n\n    // =============================================================\n    //                   TOKEN COUNTING OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the starting token ID for sequential mints.\n     *\n     * Override this function to change the starting token ID for sequential mints.\n     *\n     * Note: The value returned must never change after any tokens have been minted.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the maximum token ID (inclusive) for sequential mints.\n     *\n     * Override this function to return a value less than 2**256 - 1,\n     * but greater than `_startTokenId()`, to enable spot (non-sequential) mints.\n     *\n     * Note: The value returned must never change after any tokens have been minted.\n     */\n    function _sequentialUpTo() internal view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId() internal view virtual returns (uint256) {\n        return _currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() public view virtual override returns (uint256 result) {\n        // Counter underflow is impossible as `_burnCounter` cannot be incremented\n        // more than `_currentIndex + _spotMinted - _startTokenId()` times.\n        unchecked {\n            // With spot minting, the intermediate `result` can be temporarily negative,\n            // and the computation must be unchecked.\n            result = _currentIndex - _burnCounter - _startTokenId();\n            if (_sequentialUpTo() != type(uint256).max) result += _spotMinted;\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view virtual returns (uint256 result) {\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\n        // and it is initialized to `_startTokenId()`.\n        unchecked {\n            result = _currentIndex - _startTokenId();\n            if (_sequentialUpTo() != type(uint256).max) result += _spotMinted;\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned() internal view virtual returns (uint256) {\n        return _burnCounter;\n    }\n\n    /**\n     * @dev Returns the total number of tokens that are spot-minted.\n     */\n    function _totalSpotMinted() internal view virtual returns (uint256) {\n        return _spotMinted;\n    }\n\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        if (owner == address(0)) _revert(BalanceQueryForZeroAddress.selector);\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal virtual {\n        uint256 packed = _packedAddressData[owner];\n        uint256 auxCasted;\n        // Cast `aux` with assembly to avoid redundant masking.\n        assembly {\n            auxCasted := aux\n        }\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\n        _packedAddressData[owner] = packed;\n    }\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) _revert(URIQueryForNonexistentToken.selector);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, it can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }\n\n    /**\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Returns whether the ownership slot at `index` is initialized.\n     * An uninitialized slot does not necessarily mean that the slot has no owner.\n     */\n    function _ownershipIsInitialized(uint256 index) internal view virtual returns (bool) {\n        return _packedOwnerships[index] != 0;\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(uint256 index) internal virtual {\n        if (_packedOwnerships[index] == 0) {\n            _packedOwnerships[index] = _packedOwnershipOf(index);\n        }\n    }\n\n    /**\n     * @dev Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {\n        if (_startTokenId() <= tokenId) {\n            packed = _packedOwnerships[tokenId];\n\n            if (tokenId > _sequentialUpTo()) {\n                if (_packedOwnershipExists(packed)) return packed;\n                _revert(OwnerQueryForNonexistentToken.selector);\n            }\n\n            // If the data at the starting slot does not exist, start the scan.\n            if (packed == 0) {\n                if (tokenId >= _currentIndex) _revert(OwnerQueryForNonexistentToken.selector);\n                // Invariant:\n                // There will always be an initialized ownership slot\n                // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\n                // before an unintialized ownership slot\n                // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\n                // Hence, `tokenId` will not underflow.\n                //\n                // We can directly compare the packed value.\n                // If the address is zero, packed will be zero.\n                for (;;) {\n                    unchecked {\n                        packed = _packedOwnerships[--tokenId];\n                    }\n                    if (packed == 0) continue;\n                    if (packed & _BITMASK_BURNED == 0) return packed;\n                    // Otherwise, the token is burned, and we must revert.\n                    // This handles the case of batch burned tokens, where only the burned bit\n                    // of the starting slot is set, and remaining slots are left uninitialized.\n                    _revert(OwnerQueryForNonexistentToken.selector);\n                }\n            }\n            // Otherwise, the data exists and we can skip the scan.\n            // This is possible because we have already achieved the target condition.\n            // This saves 2143 gas on transfers of initialized tokens.\n            // If the token is not burned, return `packed`. Otherwise, revert.\n            if (packed & _BITMASK_BURNED == 0) return packed;\n        }\n        _revert(OwnerQueryForNonexistentToken.selector);\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\n        ownership.burned = packed & _BITMASK_BURNED != 0;\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\n    }\n\n    /**\n     * @dev Packs ownership data into a single uint256.\n     */\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n        }\n    }\n\n    /**\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n     */\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\n        // For branchless setting of the `nextInitialized` flag.\n        assembly {\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n        }\n    }\n\n    // =============================================================\n    //                      APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     */\n    function approve(address to, uint256 tokenId) public payable virtual override {\n        _approve(to, tokenId, true);\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        if (!_exists(tokenId)) _revert(ApprovalQueryForNonexistentToken.selector);\n\n        return _tokenApprovals[tokenId].value;\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted. See {_mint}.\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool result) {\n        if (_startTokenId() <= tokenId) {\n            if (tokenId > _sequentialUpTo()) return _packedOwnershipExists(_packedOwnerships[tokenId]);\n\n            if (tokenId < _currentIndex) {\n                uint256 packed;\n                while ((packed = _packedOwnerships[tokenId]) == 0) --tokenId;\n                result = packed & _BITMASK_BURNED == 0;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns whether `packed` represents a token that exists.\n     */\n    function _packedOwnershipExists(uint256 packed) private pure returns (bool result) {\n        assembly {\n            // The following is equivalent to `owner != address(0) && burned == false`.\n            // Symbolically tested.\n            result := gt(and(packed, _BITMASK_ADDRESS), and(packed, _BITMASK_BURNED))\n        }\n    }\n\n    /**\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\n     */\n    function _isSenderApprovedOrOwner(\n        address approvedAddress,\n        address owner,\n        address msgSender\n    ) private pure returns (bool result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\n            // `msgSender == owner || msgSender == approvedAddress`.\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\n        }\n    }\n\n    /**\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\n     */\n    function _getApprovedSlotAndAddress(uint256 tokenId)\n        private\n        view\n        returns (uint256 approvedAddressSlot, address approvedAddress)\n    {\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\n        assembly {\n            approvedAddressSlot := tokenApproval.slot\n            approvedAddress := sload(approvedAddressSlot)\n        }\n    }\n\n    // =============================================================\n    //                      TRANSFER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        // Mask `from` to the lower 160 bits, in case the upper bits somehow aren't clean.\n        from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS));\n\n        if (address(uint160(prevOwnershipPacked)) != from) _revert(TransferFromIncorrectOwner.selector);\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n        uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\n        assembly {\n            // Emit the `Transfer` event.\n            log4(\n                0, // Start of data (0, since no data).\n                0, // End of data (0, since no data).\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\n                from, // `from`.\n                toMasked, // `to`.\n                tokenId // `tokenId`.\n            )\n        }\n        if (toMasked == 0) _revert(TransferToZeroAddress.selector);\n\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public payable virtual override {\n        transferFrom(from, to, tokenId);\n        if (to.code.length != 0)\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\n            }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token IDs\n     * are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token IDs\n     * have been transferred. This includes minting.\n     * And also called after one token has been burned.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * `from` - Previous owner of the given token ID.\n     * `to` - Target address that will receive the token.\n     * `tokenId` - Token ID to be transferred.\n     * `_data` - Optional data to send along with the call.\n     *\n     * Returns whether the call correctly returned the expected magic value.\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\n            bytes4 retval\n        ) {\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                _revert(TransferToNonERC721ReceiverImplementer.selector);\n            }\n            assembly {\n                revert(add(32, reason), mload(reason))\n            }\n        }\n    }\n\n    // =============================================================\n    //                        MINT OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mint(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\n        // `tokenId` has a maximum limit of 2**256.\n        unchecked {\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\n\n            if (toMasked == 0) _revert(MintToZeroAddress.selector);\n\n            uint256 end = startTokenId + quantity;\n            uint256 tokenId = startTokenId;\n\n            if (end - 1 > _sequentialUpTo()) _revert(SequentialMintExceedsLimit.selector);\n\n            do {\n                assembly {\n                    // Emit the `Transfer` event.\n                    log4(\n                        0, // Start of data (0, since no data).\n                        0, // End of data (0, since no data).\n                        _TRANSFER_EVENT_SIGNATURE, // Signature.\n                        0, // `address(0)`.\n                        toMasked, // `to`.\n                        tokenId // `tokenId`.\n                    )\n                }\n                // The `!=` check ensures that large values of `quantity`\n                // that overflows uint256 will make the loop run out of gas.\n            } while (++tokenId != end);\n\n            _currentIndex = end;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * This function is intended for efficient minting only during contract creation.\n     *\n     * It emits only one {ConsecutiveTransfer} as defined in\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\n     * instead of a sequence of {Transfer} event(s).\n     *\n     * Calling this function outside of contract creation WILL make your contract\n     * non-compliant with the ERC721 standard.\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {ConsecutiveTransfer} event.\n     */\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) _revert(MintToZeroAddress.selector);\n        if (quantity == 0) _revert(MintZeroQuantity.selector);\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) _revert(MintERC2309QuantityExceedsLimit.selector);\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            if (startTokenId + quantity - 1 > _sequentialUpTo()) _revert(SequentialMintExceedsLimit.selector);\n\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\n\n            _currentIndex = startTokenId + quantity;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * See {_mint}.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, quantity);\n\n        unchecked {\n            if (to.code.length != 0) {\n                uint256 end = _currentIndex;\n                uint256 index = end - quantity;\n                do {\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\n                        _revert(TransferToNonERC721ReceiverImplementer.selector);\n                    }\n                } while (index < end);\n                // This prevents reentrancy to `_safeMint`.\n                // It does not prevent reentrancy to `_safeMintSpot`.\n                if (_currentIndex != end) revert();\n            }\n        }\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\n     */\n    function _safeMint(address to, uint256 quantity) internal virtual {\n        _safeMint(to, quantity, '');\n    }\n\n    /**\n     * @dev Mints a single token at `tokenId`.\n     *\n     * Note: A spot-minted `tokenId` that has been burned can be re-minted again.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` must be greater than `_sequentialUpTo()`.\n     * - `tokenId` must not exist.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mintSpot(address to, uint256 tokenId) internal virtual {\n        if (tokenId <= _sequentialUpTo()) _revert(SpotMintTokenIdTooSmall.selector);\n        uint256 prevOwnershipPacked = _packedOwnerships[tokenId];\n        if (_packedOwnershipExists(prevOwnershipPacked)) _revert(TokenAlreadyExists.selector);\n\n        _beforeTokenTransfers(address(0), to, tokenId, 1);\n\n        // Overflows are incredibly unrealistic.\n        // The `numberMinted` for `to` is incremented by 1, and has a max limit of 2**64 - 1.\n        // `_spotMinted` is incremented by 1, and has a max limit of 2**256 - 1.\n        unchecked {\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true` (as `quantity == 1`).\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(1) | _nextExtraData(address(0), to, prevOwnershipPacked)\n            );\n\n            // Updates:\n            // - `balance += 1`.\n            // - `numberMinted += 1`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += (1 << _BITPOS_NUMBER_MINTED) | 1;\n\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;\n\n            if (toMasked == 0) _revert(MintToZeroAddress.selector);\n\n            assembly {\n                // Emit the `Transfer` event.\n                log4(\n                    0, // Start of data (0, since no data).\n                    0, // End of data (0, since no data).\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\n                    0, // `address(0)`.\n                    toMasked, // `to`.\n                    tokenId // `tokenId`.\n                )\n            }\n\n            ++_spotMinted;\n        }\n\n        _afterTokenTransfers(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Safely mints a single token at `tokenId`.\n     *\n     * Note: A spot-minted `tokenId` that has been burned can be re-minted again.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}.\n     * - `tokenId` must be greater than `_sequentialUpTo()`.\n     * - `tokenId` must not exist.\n     *\n     * See {_mintSpot}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMintSpot(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mintSpot(to, tokenId);\n\n        unchecked {\n            if (to.code.length != 0) {\n                uint256 currentSpotMinted = _spotMinted;\n                if (!_checkContractOnERC721Received(address(0), to, tokenId, _data)) {\n                    _revert(TransferToNonERC721ReceiverImplementer.selector);\n                }\n                // This prevents reentrancy to `_safeMintSpot`.\n                // It does not prevent reentrancy to `_safeMint`.\n                if (_spotMinted != currentSpotMinted) revert();\n            }\n        }\n    }\n\n    /**\n     * @dev Equivalent to `_safeMintSpot(to, tokenId, '')`.\n     */\n    function _safeMintSpot(address to, uint256 tokenId) internal virtual {\n        _safeMintSpot(to, tokenId, '');\n    }\n\n    // =============================================================\n    //                       APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_approve(to, tokenId, false)`.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _approve(to, tokenId, false);\n    }\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        bool approvalCheck\n    ) internal virtual {\n        address owner = ownerOf(tokenId);\n\n        if (approvalCheck && _msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                _revert(ApprovalCallerNotOwnerNorApproved.selector);\n            }\n\n        _tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    // =============================================================\n    //                        BURN OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        if (approvalCheck) {\n            // The nested ifs save around 20+ gas over a compound boolean condition.\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n                if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                from,\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as `_burnCounter` cannot be exceed `_currentIndex + _spotMinted` times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    // =============================================================\n    //                     EXTRA DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Directly sets the extra data for the ownership data `index`.\n     */\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\n        uint256 packed = _packedOwnerships[index];\n        if (packed == 0) _revert(OwnershipNotInitializedForExtraData.selector);\n        uint256 extraDataCasted;\n        // Cast `extraData` with assembly to avoid redundant masking.\n        assembly {\n            extraDataCasted := extraData\n        }\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\n        _packedOwnerships[index] = packed;\n    }\n\n    /**\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\n     * Intended to be overridden by the cosumer contract.\n     *\n     * `previousExtraData` - the value of `extraData` before transfer.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _extraData(\n        address from,\n        address to,\n        uint24 previousExtraData\n    ) internal view virtual returns (uint24) {}\n\n    /**\n     * @dev Returns the next extra data for the packed ownership data.\n     * The returned result is shifted into position.\n     */\n    function _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n    }\n\n    // =============================================================\n    //                       OTHER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the message sender (defaults to `msg.sender`).\n     *\n     * If you are writing GSN compatible contracts, you need to override this function.\n     */\n    function _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @dev Converts a uint256 to its ASCII string decimal representation.\n     */\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /**\n     * @dev For more efficient reverts.\n     */\n    function _revert(bytes4 errorSelector) internal pure {\n        assembly {\n            mstore(0x00, errorSelector)\n            revert(0x00, 0x04)\n        }\n    }\n}\n"
      },
      'lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport "../beacon/IBeacon.sol";\nimport "../../interfaces/IERC1967.sol";\nimport "../../interfaces/draft-IERC1822.sol";\nimport "../../utils/Address.sol";\nimport "../../utils/StorageSlot.sol";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");\n            } catch {\n                revert("ERC1967Upgrade: new implementation is not UUPS");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256(\'eip1967.proxy.beacon\')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            "ERC1967: beacon implementation is not a contract"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/proxy/Proxy.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
      },
      'src/proxies/openzeppelin/ERC1967Proxy.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\n// Note: This implementation is an exact copy with the constructor removed, and pragma and imports updated.\n\npragma solidity ^0.8.19;\n\nimport "openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol";\nimport "openzeppelin-contracts/contracts/proxy/Proxy.sol";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn\'t conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/access/IAccessControlEnumerable.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport "./IAccessControl.sol";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/access/AccessControl.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport "./IAccessControl.sol";\nimport "../utils/Context.sol";\nimport "../utils/Strings.sol";\nimport "../utils/introspection/ERC165.sol";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn\'t allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role\'s admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        "AccessControl: account ",\n                        Strings.toHexString(account),\n                        " is missing role ",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role\'s admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``\'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function\'s\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn\'t perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``\'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
      },
      'lib/signals-implicit-mode/src/registry/IImplicitProjectValidation.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Attestation } from "sequence-v3/src/extensions/sessions/implicit/Attestation.sol";\n\n/// @title IImplicitProjectValidation\n/// @author Michael Standen\n/// @notice Interface for contracts supporting validation of implicit sessions for projects\ninterface IImplicitProjectValidation {\n\n  /// @notice Invalid redirect url error\n  error InvalidRedirectUrl();\n\n  /// @notice Check if a project has a code\n  /// @param wallet The wallet address\n  /// @param attestation The attestation\n  /// @param projectId The project id\n  /// @return magic The attestation magic bytes for the wallet address\n  function validateAttestation(\n    address wallet,\n    Attestation calldata attestation,\n    bytes32 projectId\n  ) external view returns (bytes32);\n\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport "./IERC165.sol";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n'
      },
      'lib/signals-implicit-mode/lib/sequence-v3/src/extensions/sessions/implicit/Attestation.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibBytes } from "../../../utils/LibBytes.sol";\nimport { ACCEPT_IMPLICIT_REQUEST_MAGIC_PREFIX } from "./ISignalsImplicitMode.sol";\n\nusing LibBytes for bytes;\n\n/// @notice Attestation for a specific session\n/// @param approvedSigner Address of the approved signer\n/// @param identityType Identity type\n/// @param issuerHash Hash of the issuer\n/// @param audienceHash Hash of the audience\n/// @param applicationData Unspecified application data\n/// @param authData Auth data\nstruct Attestation {\n  address approvedSigner;\n  bytes4 identityType;\n  bytes32 issuerHash;\n  bytes32 audienceHash;\n  bytes applicationData;\n  AuthData authData;\n}\n\n/// @notice Auth data for an attestation\n/// @param redirectUrl Authorization redirect URL\n/// @param issuedAt Timestamp of the attestation issuance\nstruct AuthData {\n  string redirectUrl;\n  uint64 issuedAt;\n}\n\n/// @title LibAttestation\n/// @author Michael Standen\n/// @notice Library for attestation management\nlibrary LibAttestation {\n\n  /// @notice Hashes an attestation\n  function toHash(\n    Attestation memory attestation\n  ) internal pure returns (bytes32) {\n    return keccak256(toPacked(attestation));\n  }\n\n  /// @notice Decodes an attestation from a packed bytes array\n  /// @param encoded The packed bytes array\n  /// @param pointer The pointer to the start of the attestation\n  /// @return attestation The decoded attestation\n  /// @return newPointer The new pointer to the end of the attestation\n  function fromPacked(\n    bytes calldata encoded,\n    uint256 pointer\n  ) internal pure returns (Attestation memory attestation, uint256 newPointer) {\n    newPointer = pointer;\n    (attestation.approvedSigner, newPointer) = encoded.readAddress(newPointer);\n    (attestation.identityType, newPointer) = encoded.readBytes4(newPointer);\n    (attestation.issuerHash, newPointer) = encoded.readBytes32(newPointer);\n    (attestation.audienceHash, newPointer) = encoded.readBytes32(newPointer);\n    // Application data (arbitrary bytes)\n    uint256 dataSize;\n    (dataSize, newPointer) = encoded.readUint24(newPointer);\n    attestation.applicationData = encoded[newPointer:newPointer + dataSize];\n    newPointer += dataSize;\n    // Auth data\n    (attestation.authData, newPointer) = fromPackedAuthData(encoded, newPointer);\n    return (attestation, newPointer);\n  }\n\n  /// @notice Decodes the auth data from a packed bytes\n  /// @param encoded The packed bytes containing the auth data\n  /// @param pointer The pointer to the start of the auth data within the encoded data\n  /// @return authData The decoded auth data\n  /// @return newPointer The pointer to the end of the auth data within the encoded data\n  function fromPackedAuthData(\n    bytes calldata encoded,\n    uint256 pointer\n  ) internal pure returns (AuthData memory authData, uint256 newPointer) {\n    uint24 redirectUrlLength;\n    (redirectUrlLength, pointer) = encoded.readUint24(pointer);\n    authData.redirectUrl = string(encoded[pointer:pointer + redirectUrlLength]);\n    pointer += redirectUrlLength;\n    (authData.issuedAt, pointer) = encoded.readUint64(pointer);\n    return (authData, pointer);\n  }\n\n  /// @notice Encodes an attestation into a packed bytes array\n  /// @param attestation The attestation to encode\n  /// @return encoded The packed bytes array\n  function toPacked(\n    Attestation memory attestation\n  ) internal pure returns (bytes memory encoded) {\n    return abi.encodePacked(\n      attestation.approvedSigner,\n      attestation.identityType,\n      attestation.issuerHash,\n      attestation.audienceHash,\n      uint24(attestation.applicationData.length),\n      attestation.applicationData,\n      toPackAuthData(attestation.authData)\n    );\n  }\n\n  /// @notice Encodes the auth data into a packed bytes array\n  /// @param authData The auth data to encode\n  /// @return encoded The packed bytes array\n  function toPackAuthData(\n    AuthData memory authData\n  ) internal pure returns (bytes memory encoded) {\n    return abi.encodePacked(uint24(bytes(authData.redirectUrl).length), bytes(authData.redirectUrl), authData.issuedAt);\n  }\n\n  /// @notice Generates the implicit request magic return value\n  /// @param attestation The attestation\n  /// @param wallet The wallet\n  /// @return magic The expected implicit request magic\n  function generateImplicitRequestMagic(Attestation memory attestation, address wallet) internal pure returns (bytes32) {\n    return keccak256(\n      abi.encodePacked(ACCEPT_IMPLICIT_REQUEST_MAGIC_PREFIX, wallet, attestation.audienceHash, attestation.issuerHash)\n    );\n  }\n\n}\n'
      },
      'lib/signals-implicit-mode/lib/sequence-v3/src/extensions/sessions/implicit/ISignalsImplicitMode.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from "../../../modules/Payload.sol";\nimport { Attestation } from "./Attestation.sol";\n\n/// @dev Magic prefix for the implicit request\nbytes32 constant ACCEPT_IMPLICIT_REQUEST_MAGIC_PREFIX = keccak256(abi.encodePacked("acceptImplicitRequest"));\n\n/// @title ISignalsImplicitMode\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Interface for the contracts that support implicit mode validation\ninterface ISignalsImplicitMode {\n\n  /// @notice Determines if an implicit request is valid\n  /// @param wallet The wallet\'s address\n  /// @param attestation The attestation data\n  /// @param call The call to validate\n  /// @return magic The hash of the implicit request if valid\n  function acceptImplicitRequest(\n    address wallet,\n    Attestation calldata attestation,\n    Payload.Call calldata call\n  ) external view returns (bytes32 magic);\n\n}\n'
      },
      'lib/signals-implicit-mode/lib/sequence-v3/src/modules/Payload.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibBytes } from "../utils/LibBytes.sol";\n\nusing LibBytes for bytes;\n\n/// @title Payload\n/// @author Agustin Aguilar, Michael Standen, William Hua\n/// @notice Library for encoding and decoding payloads\nlibrary Payload {\n\n  /// @notice Error thrown when the kind is invalid\n  error InvalidKind(uint8 kind);\n\n  /// @dev keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")\n  bytes32 private constant EIP712_DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n  /// @dev keccak256("Sequence Wallet")\n  bytes32 private constant EIP712_DOMAIN_NAME_SEQUENCE =\n    0x4aa45ca7ad825ceb1bf35643f0a58c295239df563b1b565c2485f96477c56318;\n\n  /// @dev keccak256("3")\n  bytes32 private constant EIP712_DOMAIN_VERSION_SEQUENCE =\n    0x2a80e1ef1d7842f27f2e6be0972bb708b9a135c38860dbe73c27c3486c34f4de;\n\n  function domainSeparator(bool _noChainId, address _wallet) internal view returns (bytes32 _domainSeparator) {\n    return keccak256(\n      abi.encode(\n        EIP712_DOMAIN_TYPEHASH,\n        EIP712_DOMAIN_NAME_SEQUENCE,\n        EIP712_DOMAIN_VERSION_SEQUENCE,\n        _noChainId ? uint256(0) : uint256(block.chainid),\n        _wallet\n      )\n    );\n  }\n\n  /// @dev keccak256("Call(address to,uint256 value,bytes data,uint256 gasLimit,bool delegateCall,bool onlyFallback,uint256 behaviorOnError)")\n  bytes32 private constant CALL_TYPEHASH = 0x0603985259a953da1f65a522f589c17bd1d0117ec1d3abb7c0788aef251ef437;\n\n  /// @dev keccak256("Calls(Call[] calls,uint256 space,uint256 nonce,address[] wallets)Call(address to,uint256 value,bytes data,uint256 gasLimit,bool delegateCall,bool onlyFallback,uint256 behaviorOnError)")\n  bytes32 private constant CALLS_TYPEHASH = 0x11e1e4079a79a66e4ade50033cfe2678cdd5341d2dfe5ef9513edb1a0be147a2;\n\n  /// @dev keccak256("Message(bytes message,address[] wallets)")\n  bytes32 private constant MESSAGE_TYPEHASH = 0xe19a3b94fc3c7ece3f890d98a99bc422615537a08dea0603fa8425867d87d466;\n\n  /// @dev keccak256("ConfigUpdate(bytes32 imageHash,address[] wallets)")\n  bytes32 private constant CONFIG_UPDATE_TYPEHASH = 0x11fdeb7e8373a1aa96bfac8d0ea91526b2c5d15e5cee20e0543e780258f3e8e4;\n\n  /// @notice Kind of transaction\n  uint8 public constant KIND_TRANSACTIONS = 0x00;\n  /// @notice Kind of digest\n  uint8 public constant KIND_MESSAGE = 0x01;\n  /// @notice Kind of config update\n  uint8 public constant KIND_CONFIG_UPDATE = 0x02;\n  /// @notice Kind of message\n  uint8 public constant KIND_DIGEST = 0x03;\n\n  /// @notice Behavior on error: ignore error\n  uint8 public constant BEHAVIOR_IGNORE_ERROR = 0x00;\n  /// @notice Behavior on error: revert on error\n  uint8 public constant BEHAVIOR_REVERT_ON_ERROR = 0x01;\n  /// @notice Behavior on error: abort on error\n  uint8 public constant BEHAVIOR_ABORT_ON_ERROR = 0x02;\n\n  /// @notice Payload call information\n  /// @param to Address of the target contract\n  /// @param value Value to send with the call\n  /// @param data Data to send with the call\n  /// @param gasLimit Gas limit for the call\n  /// @param delegateCall If the call is a delegate call\n  /// @param onlyFallback If the call should only be executed in an error scenario\n  /// @param behaviorOnError Behavior on error\n  struct Call {\n    address to;\n    uint256 value;\n    bytes data;\n    uint256 gasLimit;\n    bool delegateCall;\n    bool onlyFallback;\n    uint256 behaviorOnError;\n  }\n\n  /// @notice Decoded payload\n  /// @param kind Kind of payload\n  /// @param noChainId If the chain ID should be omitted\n  /// @param calls Array of calls (transaction kind)\n  /// @param space Nonce space for the calls (transaction kind)\n  /// @param nonce Nonce value for the calls (transaction kind)\n  /// @param message Message to validate (message kind)\n  /// @param imageHash Image hash to update to (config update kind)\n  /// @param digest Digest to validate (digest kind)\n  /// @param parentWallets Parent wallets\n  struct Decoded {\n    uint8 kind;\n    bool noChainId;\n    // Transaction kind\n    Call[] calls;\n    uint256 space;\n    uint256 nonce;\n    // Message kind\n    // TODO: Maybe native 721 ?\n    bytes message;\n    // Config update kind\n    bytes32 imageHash;\n    // Digest kind for 1271\n    bytes32 digest;\n    // Parent wallets\n    address[] parentWallets;\n  }\n\n  function fromMessage(\n    bytes memory message\n  ) internal pure returns (Decoded memory _decoded) {\n    _decoded.kind = KIND_MESSAGE;\n    _decoded.message = message;\n  }\n\n  function fromConfigUpdate(\n    bytes32 imageHash\n  ) internal pure returns (Decoded memory _decoded) {\n    _decoded.kind = KIND_CONFIG_UPDATE;\n    _decoded.imageHash = imageHash;\n  }\n\n  function fromDigest(\n    bytes32 digest\n  ) internal pure returns (Decoded memory _decoded) {\n    _decoded.kind = KIND_DIGEST;\n    _decoded.digest = digest;\n  }\n\n  function fromPackedCalls(\n    bytes calldata packed\n  ) internal view returns (Decoded memory _decoded) {\n    _decoded.kind = KIND_TRANSACTIONS;\n\n    // Read the global flag\n    (uint256 globalFlag, uint256 pointer) = packed.readFirstUint8();\n\n    // First bit determines if space is zero or not\n    if (globalFlag & 0x01 == 0x01) {\n      _decoded.space = 0;\n    } else {\n      (_decoded.space, pointer) = packed.readUint160(pointer);\n    }\n\n    // Next 3 bits determine the size of the nonce\n    uint256 nonceSize = (globalFlag >> 1) & 0x07;\n\n    if (nonceSize > 0) {\n      // Read the nonce\n      (_decoded.nonce, pointer) = packed.readUintX(pointer, nonceSize);\n    }\n\n    uint256 numCalls;\n\n    // Bit 5 determines if the batch contains a single call\n    if (globalFlag & 0x10 == 0x10) {\n      numCalls = 1;\n    } else {\n      // Bit 6 determines if the number of calls uses 1 byte or 2 bytes\n      if (globalFlag & 0x20 == 0x20) {\n        (numCalls, pointer) = packed.readUint16(pointer);\n      } else {\n        (numCalls, pointer) = packed.readUint8(pointer);\n      }\n    }\n\n    // Read the calls\n    _decoded.calls = new Call[](numCalls);\n\n    for (uint256 i = 0; i < numCalls; i++) {\n      uint8 flags;\n      (flags, pointer) = packed.readUint8(pointer);\n\n      // First bit determines if this is a call to self\n      // or a call to another address\n      if (flags & 0x01 == 0x01) {\n        // Call to self\n        _decoded.calls[i].to = address(this);\n      } else {\n        // Call to another address\n        (_decoded.calls[i].to, pointer) = packed.readAddress(pointer);\n      }\n\n      // Second bit determines if the call has value or not\n      if (flags & 0x02 == 0x02) {\n        (_decoded.calls[i].value, pointer) = packed.readUint256(pointer);\n      }\n\n      // Third bit determines if the call has data or not\n      if (flags & 0x04 == 0x04) {\n        // 3 bytes determine the size of the calldata\n        uint256 calldataSize;\n        (calldataSize, pointer) = packed.readUint24(pointer);\n        _decoded.calls[i].data = packed[pointer:pointer + calldataSize];\n        pointer += calldataSize;\n      }\n\n      // Fourth bit determines if the call has a gas limit or not\n      if (flags & 0x08 == 0x08) {\n        (_decoded.calls[i].gasLimit, pointer) = packed.readUint256(pointer);\n      }\n\n      // Fifth bit determines if the call is a delegate call or not\n      _decoded.calls[i].delegateCall = (flags & 0x10 == 0x10);\n\n      // Sixth bit determines if the call is fallback only\n      _decoded.calls[i].onlyFallback = (flags & 0x20 == 0x20);\n\n      // Last 2 bits are directly mapped to the behavior on error\n      _decoded.calls[i].behaviorOnError = (flags & 0xC0) >> 6;\n    }\n  }\n\n  function hashCall(\n    Call memory c\n  ) internal pure returns (bytes32) {\n    return keccak256(\n      abi.encode(\n        CALL_TYPEHASH, c.to, c.value, keccak256(c.data), c.gasLimit, c.delegateCall, c.onlyFallback, c.behaviorOnError\n      )\n    );\n  }\n\n  function hashCalls(\n    Call[] memory calls\n  ) internal pure returns (bytes32) {\n    // In EIP712, an array is often hashed as the keccak256 of the concatenated\n    // hashes of each item. So we hash each Call, pack them, and hash again.\n    bytes32[] memory callHashes = new bytes32[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      callHashes[i] = hashCall(calls[i]);\n    }\n    return keccak256(abi.encodePacked(callHashes));\n  }\n\n  function toEIP712(\n    Decoded memory _decoded\n  ) internal pure returns (bytes32) {\n    bytes32 walletsHash = keccak256(abi.encodePacked(_decoded.parentWallets));\n\n    if (_decoded.kind == KIND_TRANSACTIONS) {\n      bytes32 callsHash = hashCalls(_decoded.calls);\n      // The top-level struct for Calls might be something like:\n      // Calls(bytes32 callsHash,uint256 space,uint256 nonce,bytes32 walletsHash)\n      return keccak256(abi.encode(CALLS_TYPEHASH, callsHash, _decoded.space, _decoded.nonce, walletsHash));\n    } else if (_decoded.kind == KIND_MESSAGE) {\n      // If you define your top-level as: Message(bytes32 messageHash,bytes32 walletsHash)\n      return keccak256(abi.encode(MESSAGE_TYPEHASH, keccak256(_decoded.message), walletsHash));\n    } else if (_decoded.kind == KIND_CONFIG_UPDATE) {\n      // Top-level: ConfigUpdate(bytes32 imageHash,bytes32 walletsHash)\n      return keccak256(abi.encode(CONFIG_UPDATE_TYPEHASH, _decoded.imageHash, walletsHash));\n    } else if (_decoded.kind == KIND_DIGEST) {\n      // Top-level: Use MESSAGE_TYPEHASH but assume the digest is already the hashed message\n      return keccak256(abi.encode(MESSAGE_TYPEHASH, _decoded.digest, walletsHash));\n    } else {\n      // Unknown kind\n      revert InvalidKind(_decoded.kind);\n    }\n  }\n\n  function hash(\n    Decoded memory _decoded\n  ) internal view returns (bytes32) {\n    bytes32 domain = domainSeparator(_decoded.noChainId, address(this));\n    bytes32 structHash = toEIP712(_decoded);\n    return keccak256(abi.encodePacked("\\x19\\x01", domain, structHash));\n  }\n\n  function hashFor(Decoded memory _decoded, address _wallet) internal view returns (bytes32) {\n    bytes32 domain = domainSeparator(_decoded.noChainId, _wallet);\n    bytes32 structHash = toEIP712(_decoded);\n    return keccak256(abi.encodePacked("\\x19\\x01", domain, structHash));\n  }\n\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
      },
      'lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
      },
      'lib/erc721a/contracts/IERC721A.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.3.0\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    /**\n     * `_sequentialUpTo()` must be greater than `_startTokenId()`.\n     */\n    error SequentialUpToTooSmall();\n\n    /**\n     * The `tokenId` of a sequential mint exceeds `_sequentialUpTo()`.\n     */\n    error SequentialMintExceedsLimit();\n\n    /**\n     * Spot minting requires a `tokenId` greater than `_sequentialUpTo()`.\n     */\n    error SpotMintTokenIdTooSmall();\n\n    /**\n     * Cannot mint over a token that already exists.\n     */\n    error TokenAlreadyExists();\n\n    /**\n     * The feature is not compatible with spot mints.\n     */\n    error NotCompatibleWithSpotMints();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"
      },
      'lib/openzeppelin-contracts/contracts/interfaces/IERC1967.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/access/IAccessControl.sol': {
        content:
          "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
      },
      'lib/openzeppelin-contracts/contracts/utils/Strings.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport "./math/Math.sol";\nimport "./math/SignedMath.sol";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n'
      },
      'lib/signals-implicit-mode/lib/sequence-v3/src/utils/LibBytes.sol': {
        content:
          '// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\n/// @title Library for reading data from bytes arrays\n/// @author Agustin Aguilar (aa@horizon.io), Michael Standen (mstan@horizon.io)\n/// @notice This library contains functions for reading data from bytes arrays.\n/// @dev These functions do not check if the input index is within the bounds of the data array.\n/// @dev Reading out of bounds may return dirty values.\nlibrary LibBytes {\n\n  function readFirstUint8(\n    bytes calldata _data\n  ) internal pure returns (uint8 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(_data.offset)\n      a := shr(248, word)\n      newPointer := 1\n    }\n  }\n\n  function readUint8(bytes calldata _data, uint256 _index) internal pure returns (uint8 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(248, word)\n      newPointer := add(_index, 1)\n    }\n  }\n\n  function readUint16(bytes calldata _data, uint256 _index) internal pure returns (uint16 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(240, word)\n      newPointer := add(_index, 2)\n    }\n  }\n\n  function readUint24(bytes calldata _data, uint256 _index) internal pure returns (uint24 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(232, word)\n      newPointer := add(_index, 3)\n    }\n  }\n\n  function readUint64(bytes calldata _data, uint256 _index) internal pure returns (uint64 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(192, word)\n      newPointer := add(_index, 8)\n    }\n  }\n\n  function readUint160(bytes calldata _data, uint256 _index) internal pure returns (uint160 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := shr(96, word)\n      newPointer := add(_index, 20)\n    }\n  }\n\n  function readUint256(bytes calldata _data, uint256 _index) internal pure returns (uint256 a, uint256 newPointer) {\n    assembly {\n      a := calldataload(add(_index, _data.offset))\n      newPointer := add(_index, 32)\n    }\n  }\n\n  function readUintX(\n    bytes calldata _data,\n    uint256 _index,\n    uint256 _length\n  ) internal pure returns (uint256 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      let shift := sub(256, mul(_length, 8))\n      a := and(shr(shift, word), sub(shl(mul(8, _length), 1), 1))\n      newPointer := add(_index, _length)\n    }\n  }\n\n  function readBytes4(bytes calldata _data, uint256 _pointer) internal pure returns (bytes4 a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_pointer, _data.offset))\n      a := and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000)\n      newPointer := add(_pointer, 4)\n    }\n  }\n\n  function readBytes32(bytes calldata _data, uint256 _pointer) internal pure returns (bytes32 a, uint256 newPointer) {\n    assembly {\n      a := calldataload(add(_pointer, _data.offset))\n      newPointer := add(_pointer, 32)\n    }\n  }\n\n  function readAddress(bytes calldata _data, uint256 _index) internal pure returns (address a, uint256 newPointer) {\n    assembly {\n      let word := calldataload(add(_index, _data.offset))\n      a := and(shr(96, word), 0xffffffffffffffffffffffffffffffffffffffff)\n      newPointer := add(_index, 20)\n    }\n  }\n\n  /// @dev ERC-2098 Compact Signature\n  function readRSVCompact(\n    bytes calldata _data,\n    uint256 _index\n  ) internal pure returns (bytes32 r, bytes32 s, uint8 v, uint256 newPointer) {\n    uint256 yParityAndS;\n    assembly {\n      r := calldataload(add(_index, _data.offset))\n      yParityAndS := calldataload(add(_index, add(_data.offset, 32)))\n      newPointer := add(_index, 64)\n    }\n    uint256 yParity = uint256(yParityAndS >> 255);\n    s = bytes32(uint256(yParityAndS) & ((1 << 255) - 1));\n    v = uint8(yParity) + 27;\n  }\n\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/math/Math.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, "Math: mulDiv overflow");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n'
      },
      'lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol': {
        content:
          '// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book "Hacker\'s Delight"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n'
      }
    },
    settings: {
      remappings: [
        '@openzeppelin/contracts/=lib/murky/lib/openzeppelin-contracts/contracts/',
        'ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/',
        'erc2470-libs/=lib/erc2470-libs/',
        'erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/',
        'erc721a/=lib/erc721a/contracts/',
        'forge-std/=lib/forge-std/src/',
        'halmos-cheatcodes/=lib/signals-implicit-mode/lib/sequence-v3/lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/',
        'murky/=lib/murky/',
        'openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/',
        'openzeppelin-contracts/=lib/openzeppelin-contracts/',
        'openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/',
        'sequence-v3/=lib/signals-implicit-mode/lib/sequence-v3/',
        'signals-implicit-mode/=lib/signals-implicit-mode/',
        'solady/=lib/solady/src/'
      ],
      optimizer: {
        enabled: false,
        runs: 200
      },
      metadata: {
        useLiteralContent: true,
        bytecodeHash: 'ipfs',
        appendCBOR: true
      },
      outputSelection: {
        '*': {
          '*': ['evm.bytecode', 'evm.deployedBytecode', 'devdoc', 'userdoc', 'metadata', 'abi']
        }
      },
      evmVersion: 'cancun',
      viaIR: true,
      libraries: {}
    }
  }
}
